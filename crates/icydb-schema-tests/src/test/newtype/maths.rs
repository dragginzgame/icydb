//!
//! Behavioral tests for numeric newtypes.
//!
//! These tests assert algebraic correctness of the math traits
//! generated by `#[newtype]` codegen or handwritten impls.
//!
//! This file intentionally:
//! - does NOT test serialization
//! - does NOT test Value / ORM plumbing
//! - does NOT care how traits are implemented
//!
//! It only cares that they behave correctly.
//!

/// -------------------------
/// Integer types
/// -------------------------

#[cfg(test)]
mod test {
    use crate::test::newtype::*;
    use std::{
        fmt::Debug,
        iter::Sum,
        ops::{Add, AddAssign, Mul, MulAssign, Rem, Sub, SubAssign},
    };

    /// -------------------------
    /// Shared helpers
    /// -------------------------

    fn assert_add<T>(a: T, b: T, expected: T)
    where
        T: Copy + Add<Output = T> + PartialEq + Debug,
    {
        assert_eq!(a + b, expected);
    }

    fn assert_add_assign<T>(mut a: T, b: T, expected: T)
    where
        T: Copy + AddAssign + PartialEq + Debug,
    {
        a += b;
        assert_eq!(a, expected);
    }

    fn assert_sub<T>(a: T, b: T, expected: T)
    where
        T: Copy + Sub<Output = T> + PartialEq + Debug,
    {
        assert_eq!(a - b, expected);
    }

    fn assert_sub_assign<T>(mut a: T, b: T, expected: T)
    where
        T: Copy + SubAssign + PartialEq + Debug,
    {
        a -= b;
        assert_eq!(a, expected);
    }

    fn assert_mul<T>(a: T, b: T, expected: T)
    where
        T: Copy + Mul<Output = T> + PartialEq + Debug,
    {
        assert_eq!(a * b, expected);
    }

    fn assert_mul_assign<T>(mut a: T, b: T, expected: T)
    where
        T: Copy + MulAssign + PartialEq + Debug,
    {
        a *= b;
        assert_eq!(a, expected);
    }

    fn assert_rem<T>(a: T, b: T, expected: T)
    where
        T: Copy + Rem<Output = T> + PartialEq + Debug,
    {
        assert_eq!(a % b, expected);
    }

    fn assert_sum<T>(values: &[T], expected: T)
    where
        T: Copy + Sum + PartialEq + Debug,
    {
        let s: T = values.iter().copied().sum();
        assert_eq!(s, expected);
    }

    #[test]
    fn int32_math() {
        let a = Int32N::from(10);
        let b = Int32N::from(3);

        assert_add(a, b, Int32N::from(13));
        assert_add_assign(a, b, Int32N::from(13));

        assert_sub(a, b, Int32N::from(7));
        assert_sub_assign(a, b, Int32N::from(7));

        assert_mul(a, b, Int32N::from(30));
        assert_mul_assign(a, b, Int32N::from(30));

        assert_rem(a, b, Int32N::from(1));

        assert_sum(&[a, b], Int32N::from(13));
    }

    #[test]
    fn int128_math() {
        let a = Int128N::from(100);
        let b = Int128N::from(7);

        assert_add(a, b, Int128N::from(107));
        assert_sub(a, b, Int128N::from(93));
        assert_mul(a, b, Int128N::from(700));
        assert_rem(a, b, Int128N::from(2));
        assert_sum(&[a, b], Int128N::from(107));
    }

    /// -------------------------
    /// Natural numbers
    /// -------------------------

    #[test]
    fn nat64_math() {
        let a = Nat64N::from(20u64);
        let b = Nat64N::from(6u64);

        assert_add(a, b, Nat64N::from(26u64));
        assert_sub(a, b, Nat64N::from(14u64));
        assert_mul(a, b, Nat64N::from(120u64));
        assert_rem(a, b, Nat64N::from(2u64));
        assert_sum(&[a, b], Nat64N::from(26u64));
    }

    #[test]
    fn nat128_math() {
        let a = Nat128N::from(50u128);
        let b = Nat128N::from(7u128);

        assert_add(a, b, Nat128N::from(57u128));
        assert_sub(a, b, Nat128N::from(43u128));
        assert_mul(a, b, Nat128N::from(350u128));
        assert_rem(a, b, Nat128N::from(1u128));
        assert_sum(&[a, b], Nat128N::from(57u128));
    }

    /// -------------------------
    /// Fixed-point: E8s
    /// -------------------------

    #[test]
    fn e8s_math() {
        // 1.0 and 2.0 in E8s
        let one = E8sN::from(100_000_000u64);
        let two = E8sN::from(200_000_000u64);

        // addition is raw
        assert_add(one, two, E8sN::from(300_000_000u64));

        // subtraction is raw
        assert_sub(two, one, E8sN::from(100_000_000u64));

        // multiplication rescales
        // 1.0 * 2.0 = 2.0
        assert_mul(one, two, E8sN::from(200_000_000u64));

        // sum should be raw add
        assert_sum(&[one, two], E8sN::from(300_000_000u64));
    }

    /// -------------------------
    /// Fixed-point: E18s
    /// -------------------------

    #[test]
    fn e18s_math() {
        let one = E18sN::from(1_000_000_000_000_000_000u128);
        let two = E18sN::from(2_000_000_000_000_000_000u128);

        assert_add(one, two, E18sN::from(3_000_000_000_000_000_000u128));
        assert_sub(two, one, E18sN::from(1_000_000_000_000_000_000u128));

        // scaled multiplication
        assert_mul(one, two, E18sN::from(2_000_000_000_000_000_000u128));

        assert_sum(&[one, two], E18sN::from(3_000_000_000_000_000_000u128));
    }

    /// -------------------------
    /// Decimal
    /// -------------------------

    #[test]
    fn decimal_math() {
        let a = DecimalN::from(10);
        let b = DecimalN::from(3);

        assert_add(a, b, DecimalN::from(13));
        assert_sub(a, b, DecimalN::from(7));
        assert_mul(a, b, DecimalN::from(30));
        assert_rem(a, b, DecimalN::from(1));
        assert_sum(&[a, b], DecimalN::from(13));
    }

    // Float wrappers intentionally do not implement arithmetic traits.
}
