//!
//! Behavioral tests for numeric newtypes.
//!
//! These tests assert algebraic correctness of the math traits
//! generated by `#[newtype]` codegen or handwritten impls.
//!
//! This file intentionally:
//! - does NOT test serialization
//! - does NOT test Value / ORM plumbing
//! - does NOT care how traits are implemented
//!
//! It only cares that they behave correctly.
//!

/// -------------------------
/// Integer types
/// -------------------------

#[cfg(test)]
mod test {
    use crate::test::newtype::*;
    use icydb::types::Decimal;
    use std::{
        fmt::Debug,
        iter::Sum,
        ops::{Add, AddAssign, Mul, MulAssign, Rem, Sub, SubAssign},
        str::FromStr,
    };

    /// -------------------------
    /// Shared helpers
    /// -------------------------

    fn assert_add<T>(a: T, b: T, expected: T)
    where
        T: Copy + Add<Output = T> + PartialEq + Debug,
    {
        assert_eq!(a + b, expected);
    }

    fn assert_add_assign<T>(mut a: T, b: T, expected: T)
    where
        T: Copy + AddAssign + PartialEq + Debug,
    {
        a += b;
        assert_eq!(a, expected);
    }

    fn assert_sub<T>(a: T, b: T, expected: T)
    where
        T: Copy + Sub<Output = T> + PartialEq + Debug,
    {
        assert_eq!(a - b, expected);
    }

    fn assert_sub_assign<T>(mut a: T, b: T, expected: T)
    where
        T: Copy + SubAssign + PartialEq + Debug,
    {
        a -= b;
        assert_eq!(a, expected);
    }

    fn assert_mul<T>(a: T, b: T, expected: T)
    where
        T: Copy + Mul<Output = T> + PartialEq + Debug,
    {
        assert_eq!(a * b, expected);
    }

    fn assert_mul_assign<T>(mut a: T, b: T, expected: T)
    where
        T: Copy + MulAssign + PartialEq + Debug,
    {
        a *= b;
        assert_eq!(a, expected);
    }

    fn assert_rem<T>(a: T, b: T, expected: T)
    where
        T: Copy + Rem<Output = T> + PartialEq + Debug,
    {
        assert_eq!(a % b, expected);
    }

    fn assert_sum<T>(values: &[T], expected: T)
    where
        T: Copy + Sum + PartialEq + Debug,
    {
        let s: T = values.iter().copied().sum();
        assert_eq!(s, expected);
    }

    fn dec(value: &str) -> Decimal {
        Decimal::from_str(value).expect("valid decimal literal")
    }

    #[test]
    fn int32_math() {
        let a = Int32N::from(10);
        let b = Int32N::from(3);

        assert_add(a, b, Int32N::from(13));
        assert_add_assign(a, b, Int32N::from(13));

        assert_sub(a, b, Int32N::from(7));
        assert_sub_assign(a, b, Int32N::from(7));

        assert_mul(a, b, Int32N::from(30));
        assert_mul_assign(a, b, Int32N::from(30));

        assert_rem(a, b, Int32N::from(1));

        assert_sum(&[a, b], Int32N::from(13));
    }

    #[test]
    fn int128_math() {
        let a = Int128N::from(100);
        let b = Int128N::from(7);

        assert_add(a, b, Int128N::from(107));
        assert_sub(a, b, Int128N::from(93));
        assert_mul(a, b, Int128N::from(700));
        assert_rem(a, b, Int128N::from(2));
        assert_sum(&[a, b], Int128N::from(107));
    }

    /// -------------------------
    /// Natural numbers
    /// -------------------------

    #[test]
    fn nat64_math() {
        let a = Nat64N::from(20u64);
        let b = Nat64N::from(6u64);

        assert_add(a, b, Nat64N::from(26u64));
        assert_sub(a, b, Nat64N::from(14u64));
        assert_mul(a, b, Nat64N::from(120u64));
        assert_rem(a, b, Nat64N::from(2u64));
        assert_sum(&[a, b], Nat64N::from(26u64));
    }

    #[test]
    fn nat128_math() {
        let a = Nat128N::from(50u128);
        let b = Nat128N::from(7u128);

        assert_add(a, b, Nat128N::from(57u128));
        assert_sub(a, b, Nat128N::from(43u128));
        assert_mul(a, b, Nat128N::from(350u128));
        assert_rem(a, b, Nat128N::from(1u128));
        assert_sum(&[a, b], Nat128N::from(57u128));
    }

    /// -------------------------
    /// Fixed-point compatibility: scale 8 decimal values
    /// -------------------------

    #[test]
    fn decimal_scale_8_math() {
        let one = DecimalN::from(dec("1.00000000"));
        let two = DecimalN::from(dec("2.00000000"));

        assert_add(one, two, DecimalN::from(dec("3.00000000")));
        assert_sub(two, one, DecimalN::from(dec("1.00000000")));
        assert_mul(one, two, DecimalN::from(dec("2.00000000")));
        assert_sum(&[one, two], DecimalN::from(dec("3.00000000")));
    }

    /// -------------------------
    /// Fixed-point compatibility: scale 18 decimal values
    /// -------------------------

    #[test]
    fn decimal_scale_18_math() {
        let one = DecimalN::from(dec("1.000000000000000000"));
        let two = DecimalN::from(dec("2.000000000000000000"));

        assert_add(one, two, DecimalN::from(dec("3.000000000000000000")));
        assert_sub(two, one, DecimalN::from(dec("1.000000000000000000")));
        assert_mul(one, two, DecimalN::from(dec("2.000000000000000000")));
        assert_sum(&[one, two], DecimalN::from(dec("3.000000000000000000")));
    }

    /// -------------------------
    /// Decimal
    /// -------------------------

    #[test]
    fn decimal_math() {
        let a = DecimalN::from(10);
        let b = DecimalN::from(3);

        assert_add(a, b, DecimalN::from(13));
        assert_sub(a, b, DecimalN::from(7));
        assert_mul(a, b, DecimalN::from(30));
        assert_rem(a, b, DecimalN::from(1));
        assert_sum(&[a, b], DecimalN::from(13));
    }

    // Float wrappers intentionally do not implement arithmetic traits.
}
