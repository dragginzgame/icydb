//! Runtime-only entity schema surface generated by macros.
//!
//! This model intentionally includes only:
//! - entity metadata (path + stable external name)
//! - ordered fields
//! - primary key field
//! - index definitions
//!
//! It intentionally excludes:
//! - validators/sanitizers/defaults
//! - relations or full schema graphs
//! - JSON schema ingestion or global registries
//!
//! Stability: this is the authoritative runtime contract for planning and
//! execution. Additive changes are expected; breaking changes require a
//! coordinated version bump across the engine.
//!
//! Field names are entity-scoped. Callers that combine entities must
//! namespace by entity at the call site.

use crate::model::{field::FieldModel, index::IndexModel};

///
/// EntityModel
///
/// Macro-generated runtime schema snapshot for a single entity.
/// The planner and predicate validator consume this model directly.
///

#[derive(Debug)]
pub struct EntityModel {
    /// Fully-qualified Rust type path (for diagnostics).
    pub path: &'static str,

    /// Stable external name used in keys and routing.
    pub entity_name: &'static str,

    /// Primary key field (points at an entry in `fields`).
    pub primary_key: &'static FieldModel,

    /// Ordered field list (authoritative for runtime planning).
    pub fields: &'static [FieldModel],

    /// Index definitions (field order is significant).
    pub indexes: &'static [&'static IndexModel],
}

/// Resolve one schema field name into its stable slot index.
#[must_use]
pub(crate) fn resolve_field_slot(model: &EntityModel, field_name: &str) -> Option<usize> {
    model
        .fields
        .iter()
        .position(|field| field.name == field_name)
}

/// Resolve the primary-key field into its stable slot index.
#[must_use]
pub(crate) fn resolve_primary_key_slot(model: &EntityModel) -> Option<usize> {
    model
        .fields
        .iter()
        .position(|field| std::ptr::eq(field, model.primary_key))
}
