# IcyDB 0.29

This document aggregates detailed release notes for the `0.29.x` minor line.

---

## 0.29.7 - 2026-02-25 - Optimise Key Stream

* Reduced ordered-key stream clone churn by narrowing dedup and monotonicity witnesses to `(EntityName, StorageKey)` and updating them only at consume/discard points.
* Preserved stream correctness contracts by enforcing per-side entity stability during monotonicity checks while keeping ordered merge/intersect behavior unchanged.
* Added regression coverage for discard-path monotonicity and equal-key merge discard behavior, and kept budgeted exact-count hint behavior pinned to `min(inner_total, budget)`.

---

## 0.29.6 - 2026-02-25 - Optimise Fast Path

* Removed the fast-path `materialize -> Vec -> restream` path so fast-path execution now uses the routed stream directly, reducing allocation churn without changing results.
* Tightened key-stream scan accounting contracts: fast paths require exact total key-count hints, and `BudgetedOrderedKeyStream` now reports `min(inner_total, budget)` as a stable total hint.
* Added invariant tests for fast-path exact-count enforcement and key-stream hint contracts to prevent future regressions.

---

## 0.29.5 - 2026-02-25 - Routing Consistency Cleanup

### üìù Summary

* Made route execution mode authoritative for load and aggregate execution shape, so streaming vs materialized decisions come from one place.
* Kept aggregate execution aligned with the canonical routed stream path, reducing branch-specific behavior.
* Restored scan-budget parity for `count_distinct_by(...)` on residual-retry index-range shapes.
* Removed an unused JSON test dependency from core and trimmed JSON-only roundtrip tests.

### üîß Changed

* Enforced `route_plan.execution_mode` as a hard gate in executor dispatch: `Materialized` routes do not attempt streaming fast paths, and `Streaming` routes run through canonical stream resolution.
* Moved aggregate execution-mode override logic into route planning and removed branch-local streaming override checks from aggregate execution.
* Kept load routing behavior stable for eligible index-range pushdown shapes while preserving materialized behavior for residual secondary-order shapes.
* Updated primary-key aggregate fast-path execution to resolve keys through the shared routed key-stream boundary before folding, matching the load execution contract.
* Updated `count_distinct_by("field")` streaming execution to use the same materialization/retry boundary as `execute()`, preserving result and scan-budget parity.

### üßπ Cleanup

* Removed `serde_json` from workspace/core manifests and deleted JSON-specific type tests that depended on it.
* Switched dependency on `chrono` to the smaller `time` crate.

---

## 0.29.4 - 2026-02-25 - Audit III Follow-Through

### üìù Summary

* Split planning/lowering work from executor runtime so executor now stays byte-only.
* Switched commit marker memory from runtime auto-discovery to explicit canister configuration.

### üîß Changed

* Added `db::lowering` as the only place that turns semantic index specs into encoded key/bounds bytes.
* Removed executor-owned encoding/lowering paths and made executor consume pre-lowered byte contracts.
* Added explicit commit memory configuration via canister contract (`COMMIT_MEMORY_ID`) and derive attribute (`commit_memory_id`), and wired startup recovery to configure that ID before commit-store access.

### ‚ö†Ô∏è Breaking

* `#[canister(...)]` now requires `commit_memory_id = <u8>`.
* `test_canister!(...)` now requires `commit_memory_id`.
* Dynamic commit-memory range scanning/allocation was removed.

### üßπ Cleanup

* Deleted the legacy `executor/index_specs.rs` surface and old commit-memory anchor scanning path.

---

## 0.29.3 - 2026-02-25 - db/query : Audit III

### üìù Summary

* Continues Audit III by separating planning from execution details and tightening cursor ownership.

### üîß Changed

* Kept query planning declarative by moving executable-plan assembly, key-spec lowering, and raw-key handling to executor/index boundaries.
* Moved cursor runtime work to executor ownership, including planned cursor state, signature/direction/window validation, anchor checks, and PK-boundary decoding.
* Moved `CursorPlanError` under `query::plan::cursor` and removed plan-layer cursor capability helpers from `plan::types`.

### üßπ Cleanup

* Removed legacy `query::plan::lowering` files and related compatibility wiring.
* Removed plan/query-owned cursor runtime helper files that are now executor-owned.

---

## 0.29.2 - 2026-02-25 - db/query : Audit II

### üîß Changed

- Split query planning internals into clearer boundaries with dedicated `plan/lowering` and `plan/cursor` modules.
- Kept planner output semantic-only for index ranges, and moved encoded/index-key lowering details to the lowering stage.
- Separated intent from access choice: `LogicalPlan` now carries logical query shape, while `AccessPlannedQuery` binds logical intent to one `AccessPlan`.
- Added an explicit route contract (`ExecutionRoutePlan`) for runtime routing decisions (direction, window shape, continuation mode, and scan hints).
- Moved direction derivation out of access planning and into route planning so routing policy is isolated from access modeling.

### üßπ Cleanup

- Removed the old top-level `plan/executable.rs` and `plan/index_bounds.rs` files after the split.
- Removed transitional internal wiring tied to pre-split plan shapes and updated call sites to the new planning boundaries.

---

## 0.29.1 - 2026-02-24 - db/query : Audit I

### üîß Changed

- Put plan-shape checks behind one shared policy gate and added debug checks in load/delete/aggregate executors to catch invalid internal plans early in development.
- Replaced string-based policy error conversion at the executor boundary with explicit `PlanPolicyError` mapping.
- Moved continuation-cursor serialization out of executor runtime: executors now return a typed continuation token, and query/session code performs the final token-to-bytes step.
- Split predicate evaluation into clearer internal modules (`resolve`, `runtime`, `index_compile`) so each stage has one job.
- Moved runtime row-processing steps (filtering, sorting, cursor handling, paging, delete limits, and scan-budget safety checks) from `query::plan::logical` into `executor::query_bridge`.

### ü©π Fixed

- `ORDER BY` now rejects duplicate non-primary fields (for example, `created_at` listed twice) to keep ordering stable and predictable.
- `Set` literals are now normalized consistently by normalizing members, sorting deterministically, and removing duplicates; `List` behavior is unchanged.

### üßπ Cleanup

- Removed the cursor anchor dependency on storage key types by switching to an index-layer primary-key equivalence contract.
- Removed `query/contracts` facades that only re-exported explain/fingerprint types, and updated call sites to import from their real owner modules.
- Moved shared cursor protocol types (`CursorBoundary*`, continuation token/signature, index-range anchor) into `query/contracts/cursor` and stopped exporting them through `query::plan`.

---

## 0.29.0 - 2026-02-24 - Pre-GROUP BY Hardening Kickoff

### üìù Summary

* Starts the `0.29` hardening cycle before `GROUP BY`, with no new query features.
* Focuses this milestone on consistency checks, deterministic behavior, safer cursor handling, and recovery reliability.

### üîß Changed

* Unified aggregate and ranked execution checks behind shared routing guards so internal behavior stays aligned across code paths.
* Consolidated repeated aggregate planning and field-resolution logic into shared helpers to reduce duplicate logic without changing query results.
* Standardized ranked ordering/tie-break handling across top/bottom terminals to keep results deterministic.

### üß™ Testing

* Added broader cursor and pagination validation coverage, including mismatch cases for signature, direction, and window state.
* Expanded determinism and failure-recovery tests to verify stable output and clean rollback under partial-failure scenarios.

### üìö Documentation

* Added a `0.29` design/status baseline to track hardening goals and readiness before grouped execution work.
