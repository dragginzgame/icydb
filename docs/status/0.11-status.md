# 0.11 Status (as of 2026-02-16)

## 0.11 Scope

This status tracks progress against `docs/design/0.11-range-pushdown.md` for
the `0.11.x` Secondary Range Pushdown work.

---

## Release Snapshot

- [ ] `0.11.0` not released
- [x] Phase 0 guardrails completed (explicit `AccessPath::IndexRange` shape +
  exhaustiveness wiring across explain/hash/canonical/trace/debug/metrics)
- [x] Phase 1 planner range extraction + `IndexRange` emission implemented
- [x] Executor/index-store secondary range traversal implemented
- [ ] Full parity/regression matrix not implemented yet

Overall status for 0.11 tracked work: **65% complete**.

---

## 0.11 Plan Alignment (Secondary Range Pushdown)

### 1. Planner Access-Path Extension

- Progress: **100%**
- Done:
  - Added explicit secondary range path: `AccessPath::IndexRange { index,
    prefix, lower, upper }`.
  - Added explain/hash/canonical/trace/debug/metrics handling for
    `IndexRange`.
  - Planner extracts deterministic range candidates from normalized `AND`
    groups and emits `IndexRange` for valid composite shapes.
  - Merge logic for repeated bounds is implemented (`Gt`/`Gte`/`Lt`/`Lte`)
    with stricter-bound selection and empty-interval rejection.

### 2. Eligibility Matrix Extension

- Progress: **60%**
- Done:
  - Planner enforces prefix-equality + first-range-component shape rules for
    range extraction.
  - Plan validation enforces `prefix.len() < index.fields.len()`, range-bound
    field compatibility, and lower/upper order validity.
- Remaining:
  - Extend ORDER BY pushdown eligibility matrix to explicitly model
    `IndexRange` applicability.

### 3. Bound Construction Correctness

- Progress: **75%**
- Done:
  - Canonical bound discriminant ordering is defined and tested for
    `Unbounded`, `Included`, `Excluded`.
  - Hash encoding uses explicit bound discriminants + canonical value bytes.
  - Canonical-vs-hash alignment tests added for bound and index identity cases.
  - Index-key helpers now build bounded lexicographic ranges for
    prefix+component traversal and handle inclusive/exclusive bounds.
  - Store lookup maps `Bound<Value>` to encoded component bounds and traverses
    with bounded range iterators.
- Remaining:
  - Add explicit `BETWEEN` lowering coverage in planner-facing tests/docs
    (current behavior is via normalized conjunctions).
  - Expand edge-value coverage for bound construction.

### 4. Executor Traversal + Fallback Equivalence

- Progress: **65%**
- Done:
  - Executor validates and executes `IndexRange` through index-store bounded
    traversal.
  - Index-store resolves candidate data keys within encoded bounds and returns
    canonical candidate sets for load path processing.
- Remaining:
  - Pushdown-vs-fallback parity suite for range predicates.
  - Explicit ordering/pagination parity assertions under range traversal.

### 5. Pagination and Cursor Invariants

- Progress: **30%**
- Done:
  - Existing post-access ordering/cursor/pagination pipeline is reused for
    `IndexRange` execution paths.
- Remaining:
  - Add dedicated range-pagination tests for no-duplicate/no-skip continuation
    guarantees.
  - Add cursor resume tests at lower/upper boundaries.

### 6. Required Test Matrix

- Progress: **45%**
- Done:
  - Determinism/alignment tests for canonical ordering vs fingerprint hashing
    on `IndexRange` bounds and index identity.
  - Planner tests for valid/invalid range extraction shapes, merged bounds, and
    mixed-numeric rejection.
  - Index-key tests for exclusive lower/upper group-boundary behavior.
- Remaining:
  - Execution parity tests vs fallback for supported range shapes.
  - Pagination/cursor tests under range traversal.
  - Additional edge-value matrix and `BETWEEN` coverage.

### 7. Explicit Non-Goals (Locked)

- No multi-index intersection
- No cost-based planning
- No OR-range decomposition
- No multi-interval pushdown

---

## Range-Pushdown Design Readout

- Design direction is solid and additive: it leverages 0.10 canonical ordering
  without changing storage or cursor format.
- Phase 0 and Phase 1 foundations are now in place in planner, validation,
  index-key bounds, and executor traversal.
- Highest remaining risk is behavioral drift between pushdown and fallback
  execution without a full parity test matrix.
- Next implementation step should prioritize table-driven parity + pagination
  suites before broadening supported range sugar.

---

## Next Checkpoint

1. Add pushdown-vs-fallback parity tests for single-field and composite
   prefix+range predicates.
2. Add pagination/cursor continuation tests under range traversal boundaries.
3. Extend ORDER BY pushdown eligibility surface to include `IndexRange`
   applicability explicitly.
4. Add explicit `BETWEEN` lowering coverage (or document canonical
   `>= && <=` lowering as the supported form).
