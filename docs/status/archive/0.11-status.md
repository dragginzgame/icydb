# 0.11 Status (as of 2026-02-16)

## 0.11 Scope

This status tracks progress against `docs/design/0.11-range-pushdown.md` for
the `0.11.x` Secondary Range Pushdown work.

---

## Release Snapshot

- [ ] `0.11.0` not released
- [x] Phase 0 guardrails completed (explicit `AccessPath::IndexRange` shape +
  exhaustiveness wiring across explain/hash/canonical/trace/debug/metrics)
- [x] Phase 1 planner range extraction + `IndexRange` emission implemented
- [x] Executor/index-store secondary range traversal implemented
- [x] Full parity/regression matrix implemented

Overall status for 0.11 tracked work: **100% complete**.

---

## 0.11 Plan Alignment (Secondary Range Pushdown)

### 1. Planner Access-Path Extension

- Progress: **100%**
- Done:
  - Added explicit secondary range path: `AccessPath::IndexRange { index,
    prefix, lower, upper }`.
  - Added explain/hash/canonical/trace/debug/metrics handling for
    `IndexRange`.
  - Planner extracts deterministic range candidates from normalized `AND`
    groups and emits `IndexRange` for valid composite shapes.
  - Merge logic for repeated bounds is implemented (`Gt`/`Gte`/`Lt`/`Lte`)
    with stricter-bound selection and empty-interval rejection.

### 2. Eligibility Matrix Extension

- Progress: **100%**
- Done:
  - Planner enforces prefix-equality + first-range-component shape rules for
    range extraction.
  - Plan validation enforces `prefix.len() < index.fields.len()`, range-bound
    field compatibility, and lower/upper order validity.
  - ORDER BY pushdown applicability now classifies `IndexRange` explicitly as
    applicable-but-rejected (surface-visible), instead of collapsing to generic
    non-applicable filtering.
  - Composite `Union`/`Intersection` access trees now emit explicit
    `AccessPathIndexRangeUnsupported` applicability outcomes when they contain
    an `IndexRange` child, and surface that reason consistently in explain and
    trace.

### 3. Bound Construction Correctness

- Progress: **100%**
- Done:
  - Canonical bound discriminant ordering is defined and tested for
    `Unbounded`, `Included`, `Excluded`.
  - Hash encoding uses explicit bound discriminants + canonical value bytes.
  - Canonical-vs-hash alignment tests added for bound and index identity cases.
  - Index-key helpers now build bounded lexicographic ranges for
    prefix+component traversal and handle inclusive/exclusive bounds.
  - Store lookup maps `Bound<Value>` to encoded component bounds and traverses
    with bounded range iterators.
  - Added min/max edge-value tests for encoded component bounds
    (`0`/`u32::MAX`) covering inclusive and exclusive boundary behavior.

### 4. Executor Traversal + Fallback Equivalence

- Progress: **100%**
- Done:
  - Executor validates and executes `IndexRange` through index-store bounded
    traversal.
  - Index-store resolves candidate data keys within encoded bounds and returns
    canonical candidate sets for load path processing.
  - Added parity tests comparing range pushdown output against by-ids fallback
    for single-field and composite prefix+range shapes.
  - Added edge traversal parity coverage for single-field and composite ranges
    at `0` and `u32::MAX` boundaries.
  - Added table-driven parity matrices covering `>`, `>=`, `<`, `<=`, and
    `BETWEEN`-equivalent predicate forms across single-field and composite
    prefix+range paths, including descending-order parity checks and
    no-match/all-match windows.

### 5. Pagination and Cursor Invariants

- Progress: **100%**
- Done:
  - Existing post-access ordering/cursor/pagination pipeline is reused for
    `IndexRange` execution paths.
  - Added range-pagination tests for cross-page parity and duplicate-free
    continuation behavior.
  - Added lower/upper boundary cursor-resume tests for single-field range
    windows.
  - Added composite boundary/resume coverage for duplicate lower/upper edge
    groups and explicit mid-range resume behavior.

### 6. Required Test Matrix

- Progress: **100%**
- Done:
  - Determinism/alignment tests for canonical ordering vs fingerprint hashing
    on `IndexRange` bounds and index identity.
  - Planner tests for valid/invalid range extraction shapes, merged bounds, and
    mixed-numeric rejection.
  - Index-key tests for exclusive lower/upper group-boundary behavior.
  - Pushdown-vs-fallback parity tests for single-field and composite
    prefix+range execution.
  - Explicit `BETWEEN`-equivalent coverage (`>= && <=`) for planner IndexRange
    emission and executor pushdown-vs-fallback parity.
  - Range pagination/cursor tests for continuation parity and boundary resume.
  - Added edge-value matrix coverage for min/max bound construction and
    pushdown-vs-fallback traversal parity.
  - Added planner tests for single-field one-sided range extraction (`>` and
    `<=`) to ensure direct range predicates emit `IndexRange` without requiring
    synthetic `AND` wrappers.

### 7. Explicit Non-Goals (Locked)

- No multi-index intersection
- No cost-based planning
- No OR-range decomposition
- No multi-interval pushdown

---

## Range-Pushdown Design Readout

- Design direction is solid and additive: it leverages 0.10 canonical ordering
  without changing storage or cursor format.
- Phase 0 and Phase 1 foundations are now in place in planner, validation,
  index-key bounds, and executor traversal.
- Main implementation risk (pushdown/fallback drift) is now materially reduced
  by table-driven parity and expanded cursor-boundary coverage.
- Remaining work is release hardening (`fmt`/`clippy`/full test pass) and
  release-candidate validation for `0.11.0`.

---

## Next Checkpoint

1. Run full pre-release gate: `make fmt-check && make clippy && make check && make test`.
2. Cut `0.11.0` once release checks pass and changelog notes are finalized.
