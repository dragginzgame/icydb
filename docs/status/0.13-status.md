# 0.13 Status (as of 2026-02-17)

## 0.13 Scope

This status tracks progress against `docs/design/0.13-limit-pushdown.md` for
the `0.13.x` LIMIT-pushdown work for `AccessPath::IndexRange` (single-path).

`0.13` is scoped to execution optimization only. Binary cursor work is
explicitly out of scope for this milestone.

---

## Release Snapshot

- [ ] `0.13.0` not released
- [x] 0.12 prerequisites are in place (`RawIndexKey` continuation anchor +
  strict `Bound::Excluded(last_raw_key)` resume semantics)
- [x] Store-level limited resolver implemented for `IndexRange`
- [x] Executor path selection wired to call limited resolver when eligible
- [x] Full parity and edge-case matrix completed for limited traversal

Overall status for 0.13 tracked work: **95% complete**.

---

## 0.13 Plan Alignment (LIMIT Pushdown for IndexRange)

### 1. Scope & Execution Boundary

- Progress: **100%**
- Done:
  - `AccessPath::IndexRange` single-path continuation semantics are already
    established from 0.12.
  - Out-of-scope boundaries are explicit (`Union`/`Intersection`, DESC,
    cost-based planning).
  - Added 0.13 implementation guardrails so LIMIT pushdown only activates for
    intended eligible plan shapes.
- Remaining:
  - No open scope-boundary gaps for 0.13.

### 2. Store API (`resolve_data_values_in_range_limited`)

- Progress: **100%**
- Done:
  - Added `resolve_data_values_in_range_limited(...)` for `IndexRange`.
  - Existing range resolver now delegates to limited traversal with
    `usize::MAX`, preserving current behavior for non-limited callers.
  - Limited traversal preserves canonical bound construction and continuation
    lower-bound rewrite semantics.
  - `limit == 0` returns immediately with an empty result.
- Remaining:
  - No major store-API gaps identified for 0.13 scope.

### 3. Executor Integration

- Progress: **100%**
- Done:
  - Executor already carries planned cursor anchor state through to store
    traversal.
  - Added a dedicated index-range limit-pushdown fast path that calls the
    limited resolver when plan shape is semantically safe.
  - Added conservative eligibility guards (no residual predicate, compatible
    ordering shape, explicit page limit) to avoid semantic drift.
  - Added `limit=0` short-circuit behavior for eligible `IndexRange` plans so
    the fast path performs zero access traversal.
  - Added trace coverage that proves eligible plans report limited
    access-phase scan rows.
- Remaining:
  - Optionally relax eligibility in a test-driven way without changing
    canonical output semantics.

### 4. Pagination Invariants Compatibility (0.12 Contract)

- Progress: **100%**
- Done:
  - Strict continuation and anchor validation invariants already exist from 0.12.
  - Added limit-matrix pagination tests that confirm unbounded parity for
    single-field and composite `IndexRange` paths across multiple limits.
  - Added explicit exact-size and terminal-page assertions that confirm correct
    cursor suppression behavior under limited traversal.
- Remaining:
  - No known invariant gaps in current 0.13 scope.

### 5. Test Matrix & Success Criteria

- Progress: **100%**
- Done:
  - Baseline parity/boundary suite from 0.12 is available as a regression base.
  - Existing 0.12 parity tests continue to pass with the new limited path
    wiring for eligible plans.
  - Added functional limit-matrix coverage including `limit=0`, `1`, small
    bounded pages, and larger-than-result windows for both single-field and
    composite range plans.
  - Added exact-size-limit assertions (single-page completion without
    continuation cursor).
  - Added continuation-boundary and terminal-page edge checks for limited
    traversal.
  - Added explicit trace-backed `limit=0` coverage to prove zero scanned access
    rows on the eligible pushdown path.
  - Added explicit `limit=0` with non-zero offset coverage to prove the same
    zero-scan short-circuit behavior.
- Remaining:
  - Run full release gate (`fmt`/`clippy`/`check`/workspace tests) before cut.

### 6. Binary Cursor Scope Separation

- Progress: **100%**
- Done:
  - Binary cursor representation is explicitly excluded from `0.13` scope.
- Remaining:
  - Keep `0.13` implementation and docs aligned to limit-pushdown only.
  - Defer binary cursor-envelope work to the designated future milestone.

---

## Readout

- 0.13 starts from a solid 0.12 continuation baseline, so correctness risk is
  concentrated in limited traversal wiring and parity validation.
- The main delivery focus is implementing early-stop range traversal without
  changing result or cursor semantics.
- Binary cursor work is intentionally decoupled to keep 0.13 constrained and
  shippable.

---

## Next Checkpoint

1. Run release gate (`fmt`/`clippy`/`check`/tests) and capture any final fixes.
2. Resolve local `clippy` environment issue (`Invalid cross-device link`) so
   warning-free verification can complete on this machine.
3. Keep changelog draft synced with final merged behavior for `0.13.0` and cut
   release when gate is green.
