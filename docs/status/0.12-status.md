# 0.12 Status (as of 2026-02-16)

## 0.12 Scope

This status tracks progress against `docs/design/0.12-cursor-pagination.md` for
the `0.12.x` cursor-pagination hardening work for `AccessPath::IndexRange`.

---

## Release Snapshot

- [ ] `0.12.0` not released
- [x] Existing continuation token/signature validation is implemented
- [x] Range pagination parity and boundary tests exist for single-field and
  composite `IndexRange` plans
- [ ] `IndexRange` continuation anchor switched to `RawIndexKey`
- [ ] Store-level continuation by rewriting only the `IndexRange` start bound
  (`Bound::Excluded(last_raw_key)`)
- [ ] `IndexRange` cursor validation enforces raw-key identity + original range
  envelope checks

Overall status for 0.12 tracked work: **55% complete**.

---

## 0.12 Plan Alignment (Cursor Pagination)

### 1. Scope & Execution Boundary

- Progress: **60%**
- Done:
  - Cursor pagination is available for load plans with ordering.
  - `IndexRange` plans already participate in cursor pagination semantics in
    executor tests.
- Remaining:
  - 0.12 scope calls for store-level continuation in raw index-key space;
    current execution still applies continuation at post-access row filtering.

### 2. Cursor Model (`RawIndexKey` Anchor)

- Progress: **20%**
- Done:
  - Cursor payload is opaque to callers and bound to plan signatures.
- Remaining:
  - `IndexRange` cursor anchor is still value-slot boundary data derived from
    entities, not `RawIndexKey`.
  - No dedicated `IndexRangeCursor { last_raw_key }` model is wired through
    continuation planning/execution.

### 3. First-Page and Continuation Execution

- Progress: **35%**
- Done:
  - Continuation uses strict resume semantics (exclude boundary row) at the
    logical row-order layer.
  - Cursor emission already suppresses cursors when traversal is exhausted
    (`rows_after_cursor <= page_end`).
- Remaining:
  - 0.12 requires continuation to rewrite only the lower raw bound in index
    traversal; this path is not implemented yet.
  - Index-range continuation is not yet performed by
    `entry_map.range((start_raw, end_raw))` with `start=Excluded(last_raw_key)`.

### 4. Critical Invariants

- Progress: **65%**
- Done:
  - No-duplicate/no-skip behavior is covered by cursor pagination parity tests.
  - Boundary-edge behavior (lower/upper, mid-group resume) is covered for
    single and composite range windows.
- Remaining:
  - Invariants are currently proven at logical row boundary level, not explicitly
    in raw key traversal space.
  - Monotonic raw-key progression is not yet enforced/verified directly.

### 5. Cursor Validation

- Progress: **50%**
- Done:
  - Continuation signature mismatch, token version mismatch, boundary arity, and
    boundary type checks are implemented.
  - Primary-key slot decoding guardrails are implemented.
- Remaining:
  - For 0.12 `IndexRange`, validation must also enforce:
    - raw key decodes to `IndexKey`
    - key identity (index id / namespace / arity)
    - key remains inside original range envelope (`prefix + lower + upper`)

### 6. Encoding & Stability Policy

- Progress: **80%**
- Done:
  - Cursor remains opaque at API level and bound to canonical plan identity.
  - Safety checks already reject incompatible continuation payloads.
- Remaining:
  - 0.12 policy centers `RawIndexKey` as the internal continuation anchor for
    `IndexRange`; current boundary representation is still value-slot based.

### 7. Edge-Case Matrix and Success Criteria

- Progress: **70%**
- Done:
  - Covered: lower/upper boundaries, group-boundary resume, exhaustion, and
    cross-page parity for range queries.
  - Added table-driven parity matrices for `>`, `>=`, `<`, `<=`, and
    `BETWEEN`-equivalent range shapes.
- Remaining:
  - Add explicit unique-index `IndexRange` cursor case from design Case F.
  - Add trace assertion that confirms lower-bound strict advancement in the
    raw-bound continuation path once implemented.

---

## Cursor-Pagination Design Readout

- Current behavior is semantically strong at the logical row-order layer and is
  heavily tested.
- Main 0.12 gap is architectural: continuation is not yet anchored/resumed in
  raw index-key traversal space.
- Highest remaining risk is divergence between logical-boundary semantics and
  raw-index continuation semantics once store-level continuation is introduced.

---

## Next Checkpoint

1. Implement dedicated `IndexRange` raw-key continuation anchor
   (`last_raw_key`) and executor bound rewrite path.
2. Add raw-key identity/envelope validation for continuation requests.
3. Add remaining unique-index cursor edge coverage and strict advancement trace
   assertions for the new raw-bound path.
