# 0.12 Status (as of 2026-02-17)

## 0.12 Scope

This status tracks progress against `docs/design/0.12-cursor-pagination.md` for
the `0.12.x` cursor-pagination hardening work for `AccessPath::IndexRange`.

---

## Release Snapshot

- [ ] `0.12.0` not released
- [x] Existing continuation token/signature validation is implemented
- [x] Range pagination parity and boundary tests exist for single-field and
  composite `IndexRange` plans
- [x] `IndexRange` continuation anchor switched to `RawIndexKey`
- [x] Store-level continuation by rewriting only the `IndexRange` start bound
  (`Bound::Excluded(last_raw_key)`)
- [x] `IndexRange` cursor validation enforces raw-key identity + original range
  envelope checks

Overall status for 0.12 tracked work: **100% complete**.

---

## 0.12 Plan Alignment (Cursor Pagination)

### 1. Scope & Execution Boundary

- Progress: **100%**
- Done:
  - Cursor pagination is available for load plans with ordering.
  - `IndexRange` plans already participate in cursor pagination semantics in
    executor tests.
  - Cursor payload now carries an `IndexRange` raw-key anchor and planning
    validates it before execution.
  - Session/DB execution now passes planned cursor anchor state into the load
    executor so index-range continuation can run in store key space.
  - Store traversal now enforces strict continuation advancement by rejecting
    any continuation scan that yields a key at-or-before the provided anchor.
- Remaining:
  - No major scope gaps identified for 0.12.

### 2. Cursor Model (`RawIndexKey` Anchor)

- Progress: **100%**
- Done:
  - Cursor payload is opaque to callers and bound to plan signatures.
  - `ContinuationToken` now carries an optional
    `IndexRangeCursorAnchor { last_raw_key: RawIndexKey }`.
  - Index-range cursor emission writes this anchor from the last emitted
    rowâ€™s index key.
  - Backward-compatible decode still accepts older tokens without the anchor.
- Remaining:
  - No model-level gaps identified for 0.12 scope.

### 3. First-Page and Continuation Execution

- Progress: **100%**
- Done:
  - Continuation uses strict resume semantics (exclude boundary row) at the
    logical row-order layer.
  - Cursor emission already suppresses cursors when traversal is exhausted
    (`rows_after_cursor <= page_end`).
  - Cursor anchors now carry the exact raw index key needed for store-level
    continuation.
  - Store traversal now rewrites only the lower index bound to
    `Bound::Excluded(last_raw_key)` and preserves the original upper bound.
  - `IndexStore` continuation uses `entry_map.range((start_raw, end_raw))` with
    the rewritten `start_raw`.
  - Added explicit unique-index `IndexRange` continuation coverage (design
    Case F).
- Remaining:
  - No first-page/continuation gaps identified for 0.12.

### 4. Critical Invariants

- Progress: **100%**
- Done:
  - No-duplicate/no-skip behavior is covered by cursor pagination parity tests.
  - Boundary-edge behavior (lower/upper, mid-group resume) is covered for
    single and composite range windows.
  - Added multi-page regression test:
    - unbounded result set vs concatenated paged result set (byte-for-byte row parity)
    - strict monotonic progression of `index_range_anchor.last_raw_key` across pages
  - Added unique-index continuation parity coverage to ensure strict
    progression and no-duplicate/no-skip behavior for one-PK-per-entry indexes.
- Remaining:
  - No major invariant gaps identified for 0.12.

### 5. Cursor Validation

- Progress: **100%**
- Done:
  - Continuation signature mismatch, token version mismatch, boundary arity, and
    boundary type checks are implemented.
  - Primary-key slot decoding guardrails are implemented.
  - For `IndexRange`, validation now enforces:
    - raw key decodes to `IndexKey`
    - key identity (index id / namespace / arity)
    - key remains inside original range envelope (`prefix + lower + upper`)
  - Validation and execution now share the same raw-bound construction path to
    avoid semantic drift.
- Remaining:
  - No major validation gaps identified for 0.12 scope.

### 6. Encoding & Stability Policy

- Progress: **100%**
- Done:
  - Cursor remains opaque at API level and bound to canonical plan identity.
  - Safety checks already reject incompatible continuation payloads.
  - 0.12 `RawIndexKey` anchor is now encoded in continuation tokens for
    index-range paths.
- Remaining:
  - No major encoding-policy gaps identified for 0.12 scope.

### 7. Edge-Case Matrix and Success Criteria

- Progress: **100%**
- Done:
  - Covered: lower/upper boundaries, group-boundary resume, exhaustion, and
    cross-page parity for range queries.
  - Added table-driven parity matrices for `>`, `>=`, `<`, `<=`, and
    `BETWEEN`-equivalent range shapes.
  - Added multi-page parity + monotonic-anchor regression for composite
    `IndexRange` cursor pagination.
  - Added unique-index `IndexRange` continuation parity coverage (Case F).
  - Added traversal-entry strict-advancement enforcement for continuation scans
    rewritten to `Bound::Excluded(last_raw_key)`.
- Remaining:
  - No edge-case matrix gaps identified for 0.12.

---

## Cursor-Pagination Design Readout

- Current behavior is semantically strong at the logical row-order layer and is
  heavily tested.
- `IndexRange` cursor payload/validation now has a concrete raw-key anchor and
  shared bound-construction semantics with store range planning.
- Main 0.12 work is now wired through planning, validation, and store traversal,
  with the next milestone focused on 0.13 `IndexRange` limit pushdown.

---

## Next Checkpoint

1. Freeze the 0.12 behavior and tests as baseline.
2. Begin 0.13 `IndexRange` limit-pushdown implementation and parity testing.
3. Keep binary cursor-envelope work deferred to the designated future milestone.
