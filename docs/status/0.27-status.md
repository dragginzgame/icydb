# 0.27 Status (as of 2026-02-23)

## 0.27 Scope

This status tracks index-only predicate evaluation from:

- `docs/design/0.27-index-only-predicate-evaluation.md`

In scope for `0.27`:

- expose predicate-required slot indices from compiled predicates
- compare required predicate slots against active index model fields
- evaluate eligible predicates directly from `RawIndexKey` on index-backed paths
- skip row reads for rejected keys and only deserialize surviving rows
- wire index-only predicate filtering into load fast-path routing

Out of scope for `0.27`:

- predicate DSL expansion
- planner cost-model redesign
- cursor envelope redesign
- mandatory index-only behavior for all predicate shapes

---

## Release Snapshot

- [ ] `0.27.0` released (`Cargo.toml` version is currently `0.26.3`)
- [x] Milestone tracker created
- [x] Design doc created (`docs/design/0.27-index-only-predicate-evaluation.md`)
- [x] Prerequisite audit completed
- [x] `PredicateFieldSlots::required_slots()` landed
- [x] Predicate-vs-index coverage gate scaffold landed (route helper + tests)
- [x] Compiled index-component predicate program scaffold landed (strict subset)
- [x] Raw index-key predicate evaluation helper landed
- [x] Load key-stream integration landed for index-backed access paths (fast-path + fallback wiring)
- [x] `0.27.1` hardening matrix landed (parity/invariants, operator-coercion matrix, continuation+`DISTINCT`, trace observability)

Overall status: **`0.27.0` core and `0.27.1` hardening are implemented.**

---

## Current Baseline

- Runtime predicate evaluation is slot-based and uses `get_value_by_index`.
- Executable plans already carry compiled predicate slots into load execution.
- `PredicateFieldSlots` now exposes deterministic required field slots (`required_slots()`).
- Route now has an index-slot coverage helper for compiled predicates on single-path index access shapes.
- Predicate module now includes a strict-subset index predicate compiler and raw-key evaluator.
- Load execution now compiles optional index-only predicate programs for covered index paths.
- Index-backed traversal paths now support raw-key predicate filtering before key materialization when eligible.

---

## Prerequisite Readout

| Prerequisite | Status |
| --- | --- |
| Slot-based runtime predicate evaluation | Done |
| Compiled predicate slots threaded into execution | Done |
| Raw index key decode available | Done |
| Required-slot exposure API | Done |
| Predicate/index coverage gate | Done |
| Raw index predicate evaluator | Done |
| Route integration for index-only filtering | Done (initial strict-subset wiring) |

---

## `0.27.1` Hardening (Completed)

Completed in this patch:

1. Parity and row-read reduction invariants for eligible/ineligible shapes.
2. Operator/coercion matrix coverage for compile eligibility and fallback behavior.
3. Continuation and `DISTINCT` interaction coverage on index-only-enabled shapes.
4. Explain/trace observability for index-only predicate activation.

---

## Verification Run (this pass)

- `cargo check -p icydb-core` (pass)
- `cargo test -p icydb-core db::executor::tests::aggregate:: -- --nocapture` (pass)
- `cargo test -p icydb-core route_matrix_load_index_range_residual_predicate -- --nocapture` (pass)
- `cargo test -p icydb-core load_index_range_limit_pushdown_with_residual_predicate_reduces_access_rows -- --nocapture` (pass)
- `cargo test -p icydb-core load_index_range_limit_pushdown_residual_underfill_retries_without_pushdown -- --nocapture` (pass)

---

## 0.27.7 Pushdown Maturity Snapshot

### Quick Summary

- Core query correctness is integrated end-to-end.
- Optimization coverage is intentionally conservative and still uneven by shape.
- The highest-value next work is pushdown breadth, not semantic rework.

### Integration Matrix

| Subsystem | Status | Notes |
| --- | --- | --- |
| Intent + policy guards | Fully integrated | Mode/order/pagination/cursor readiness is centralized and enforced. |
| Predicate validation + runtime evaluation | Fully integrated | Supported operators are validated and run on compiled slot paths. |
| Access planning | Integrated with fallback | PK + index prefix/range are covered for safe strict shapes; unsupported forms fall back. |
| Cursor/continuation spine | Fully integrated | Signature/version/boundary/anchor checks are strict and layered. |
| Load fast paths | Integrated with strict gates | PK/secondary/index-range-limit exist but are shape-gated. |
| Index-only predicate filtering | Integrated with fallback | Strict subset is supported, including safe `AND` subset retention and strict `IN`. |
| DISTINCT + pagination parity | Fully integrated | Comparator-based distinct and continuation parity are heavily tested. |
| Aggregate terminals | Integrated with targeted streaming | `first`/`last` and field extrema now attempt streaming on compatible strict shapes; unsupported or uncertain shapes still fail closed to materialized fallback. |
| Aggregate fast paths | Integrated with strict prefilter | Aggregate stream paths now pass strict index predicate hints and fail closed to materialized fallback when compilation is uncertain. |
| Delete execution | Fully integrated (correctness-first) | Atomic and validated; optimization is intentionally secondary. |

### Conservative Boundaries (Current)

1. Secondary-order pushdown applies to index-prefix shapes only.
2. Index-range-limit pushdown now allows residual predicates only for bounded-small windows, with automatic retry to canonical fallback when bounded residual filtering may under-fill a page.
3. Index-only predicate compilation is strict-coercion-first and fail-closed for unsupported nodes.
4. Field aggregate terminals still materialize for unsupported targets and complex shapes (`DISTINCT`, incompatible order, or uncertain predicate coverage).
5. Aggregate fast paths now use strict all-or-none index predicate compilation, so non-strict coercion and unsupported predicate nodes intentionally fall back to materialized execution.

### Ranked 0.27.7 Integration Targets (Remaining)

1. Expand planner sargability for additional safe composite shapes.

### 0.27.7 Target #1 (Completed)

Leverage: Very high  
Risk: Low-medium  
Surface area: Localized (route + aggregate fast-path entrypoints)

Delivered:

- Thread `index_predicate_execution` into aggregate fast-path stream creation.
- Apply index-only prefilter before aggregate fold with strict all-or-none compile policy.
- Keep fail-closed behavior for unsupported shapes and non-strict coercions by forcing materialized fallback.

Validation:

- No API changes.
- Aggregate parity unchanged vs canonical/materialized fallback.
- Reduction tests show fewer scanned keys for eligible aggregate shapes.
- No `MissingOk` behavior drift in stale-leading-key scenarios.

### 0.27.7 Target #2 (Completed)

Leverage: High  
Risk: Medium  
Surface area: Localized (load route + paged execution fallback)

Delivered:

- Relaxed route gating so index-range `LIMIT` pushdown can run on residual-filter shapes when the bounded fetch window is small and safe.
- Added bounded residual-fetch safety cap checks in route planning for both probe-hint and page-window paths.
- Added automatic retry without index-range `LIMIT` pushdown when bounded residual filtering may under-fill the requested page window, preserving row/order/cursor parity.

Validation:

- No API changes.
- Parity is preserved against canonical fallback paths for rows and continuation behavior.
- Eligible residual-filter windows show reduced scanned rows when bounded candidates satisfy the requested page.

### 0.27.7 Target #3 (Completed)

Leverage: Medium-high  
Risk: Low  
Surface area: Localized (aggregate terminal dispatch + field-extrema route gates)

Delivered:

- Normalized extrema terminal dispatch so `first`, `last`, `min_by`, and `max_by` all attempt streaming on compatible non-`DISTINCT` shapes.
- Kept strict safety boundaries: uncertain predicate coverage still forces canonical materialized fallback.
- Updated field-extrema route gating so index-covered predicate shapes remain eligible for streaming attempts.

Validation:

- No API changes.
- Added parity + scan-reduction tests for strict-vs-uncertain `first`/`last` and `min_by`/`max_by`.
- Added route coverage for index-covered field-extrema eligibility under predicates.
