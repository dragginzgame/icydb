# 0.18 Status (as of 2026-02-19)

## 0.18 Scope

This status tracks progress against `docs/design/0.18-composite-limit-pushdown.md`
for the `0.18.x` execution scan budgeting milestone.

In scope for `0.18`:

- Add guarded internal scan budgeting (`derive_scan_budget(plan, cursor) -> Option<usize>`)
- Add enforceable safety guards for access-order and residual-filter/reorder drift
- Apply budgeting only at the executor stream-consumption boundary
- Preserve ordering, pagination, continuation, and error taxonomy semantics
- Keep public API, cursor format, storage, and index encoding unchanged

Out of scope for `0.18`:

- Planner redesign
- Cost-based heuristics or branch reordering
- Mandatory lazy access-path producer rewrite
- Cursor token format changes

---

## Release Snapshot

- [ ] `0.18.0` not released
- [x] 0.17 composite streaming baseline is complete (`Union` + `Intersection` stream-native)
- [x] Integration boundary is identified (`LoadExecutor::materialize_key_stream_into_page`)
- [x] `derive_scan_budget(plan, cursor)` exists in load execution
- [x] `BudgetedOrderedKeyStream` exists with no-poll-after-exhaustion behavior
- [x] Residual-filter/post-sort/access-order checks are exposed via `LogicalPlan` budget metadata
- [x] Guarded budget application is wired at stream-consumption boundary only
- [x] 0.18 regression matrix core cases are implemented and green

Overall status for tracked 0.18 work: **100% complete (implementation scope complete, release pending)**.

---

## 0.18 Plan Alignment (Execution Scan Budgeting)

### 1. Preconditions and Baseline

- Progress: **100%**
- Current state:
- 0.17 stream-native composite execution is complete and validated.
- Current load execution boundary is explicit:
  `LoadExecutor::materialize_key_stream_into_page` ->
  `Context::rows_from_ordered_key_stream(...)`.

### 2. Safety Metadata and Guards

- Progress: **100%**
- Current state:
- Guard ownership moved from executor-local helpers to plan-surface metadata:
  `LogicalPlan::budget_safety_metadata::<E>()`.
- Residual-filter gating is explicit via `BudgetSafetyMetadata.has_residual_filter`.
- Post-access sort gating is explicit via `BudgetSafetyMetadata.requires_post_access_sort`.
- Access-order proof is explicit via `BudgetSafetyMetadata.access_order_satisfied_by_path`.
- Cursor safety is explicit through `cursor_narrowing_is_budget_safe(cursor)`.
- Remaining:
- Expand guard coverage for additional safe cursor forms if/when provable.

### 3. Budget Primitive

- Progress: **100%**
- Current state:
- `BudgetedOrderedKeyStream<S>` is implemented and tested.
- `derive_scan_budget(plan, cursor)` is implemented with `offset + limit + 1` under safe shapes.
- Budget wrapper is only applied when the safe-shape guard passes.

### 4. Integration

- Progress: **100%**
- Current state:
- Budget wrapping is integrated at:
  `LoadExecutor::materialize_key_stream_into_page`.
- Boundary call remains:
  `Context::rows_from_ordered_key_stream(...)`.
- No budget wrapping was added to access-path producers, composite stream constructors, or post-access phases.

### 5. Regression Coverage

- Progress: **100%**
- Added and passing:
- `load_composite_pk_budget_trace_limits_access_rows_for_safe_shape`
- `load_composite_pk_budget_disabled_when_cursor_boundary_present`
- `load_composite_budget_disabled_when_post_access_sort_is_required`
- `load_composite_budget_disabled_for_offset_with_residual_filter`
- `load_composite_pk_budget_trace_limits_access_rows_for_safe_desc_shape`
- `load_nested_composite_pk_budget_trace_limits_access_rows_for_safe_shape`
- `load_composite_budgeted_and_fallback_paths_emit_equivalent_continuation_boundary`
- `budgeted_stream_stops_after_budget_without_polling_inner`
- `budgeted_stream_with_zero_budget_is_immediately_exhausted`
- `budget_safety_metadata_marks_pk_order_plan_as_access_order_satisfied`
- `budget_safety_metadata_marks_residual_filter_plan_as_unsafe`
- Remaining:
- No required 0.18 matrix gaps remain; only optional cursor-shape expansion work remains.

---

## 0.18 Completion Criteria Check

- [x] `derive_scan_budget(plan, cursor) -> Option<usize>` implemented
- [x] safe-shape guard function implemented and conservative
- [x] budget wrapper integrated only behind guard
- [x] fallback path is unchanged when budget is `None`
- [x] no continuation semantic drift on covered shapes
- [x] required 0.18 test matrix core cases pass
- [x] full existing test suite passes after implementation
- [x] plan-surface metadata contract tests are in place

---

## Verification Run (this status pass)

- Static audit:
  - `rg -n "BudgetSafetyMetadata|budget_safety_metadata|is_access_order_satisfied_by_path" crates/icydb-core/src/db/query/plan/logical.rs`
    - Result: plan-surface budget metadata is present in `LogicalPlan`
  - `rg -n "derive_scan_budget|is_budget_safe_shape|cursor_narrowing_is_budget_safe" crates/icydb-core/src/db/executor/load/mod.rs`
    - Result: load executor uses plan metadata for guarded budget decisions
  - `rg -n "BudgetedOrderedKeyStream" crates/icydb-core/src/db/executor`
    - Result: wrapper present and wired in `ordered_key_stream.rs`, `executor/mod.rs`, and `load/mod.rs`
  - `rg -n "materialize_key_stream_into_page|rows_from_ordered_key_stream" crates/icydb-core/src/db/executor/load/mod.rs crates/icydb-core/src/db/executor/context.rs`
    - Result: budget application remains at the intended consumption boundary
- Build/tests:
  - `cargo check -p icydb-core --locked`
    - Result: pass
  - `cargo test -p icydb-core --locked`
    - Result: `594 passed; 0 failed` (+ compile-fail suite `1 passed`)

---

## Readout

- 0.18 now has an implemented core with conservative safety guards and boundary-only integration.
- Safety guard ownership is now formalized at the plan layer via `LogicalPlan` budget metadata.
- Composite PK-ordered shapes can now stop key consumption at `offset + limit + 1` under safe conditions.
- Existing semantics and full suite behavior remain stable.
- 0.18 implementation scope is complete; remaining work is release cut/publish and optional cursor-safety expansion.

---

## Next Checkpoint

1. Cut and publish `0.18.0`.
2. Keep cursor guard conservative (`cursor_boundary.is_none()`) for 0.18 unless additional cursor-safe proofs are added in a follow-up.
3. Track optional cursor-shape expansion as a post-0.18 item.
