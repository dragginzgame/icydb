# 0.24 - Composite Aggregate Direct Path

## 1) Decision

`0.24.0` ships one primary feature:

- direct aggregate routing for composite access shapes (`Union` / `Intersection`)

This is a feature release, not a patch-hardening release.

---

## 2) Why This Feature

Composite aggregates are currently correct but pay generic execution routing costs.

`0.24` targets a focused improvement:

- keep exact aggregate semantics
- reduce overhead for composite aggregate terminals
- preserve one canonical composition model

This keeps the release user-visible while staying architecturally safe.

---

## 3) Scope

### In Scope (`0.24.0`)

- add `try_execute_composite_aggregate(...)` aggregate fast-path branch
- support composite `AccessPlan` shapes (`Union` / `Intersection`)
- preserve one shared aggregate fold engine (`count`, `exists`, `min`, `max`)
- keep DISTINCT and window semantics (`offset` / `limit`) parity-safe
- add explicit eligibility/fallback rules and invariant checks

### Out of Scope (`0.24.0`)

- new aggregate APIs (`sum`, `avg`, field-value aggregates)
- planner cost-model redesign
- direction-aware index encoding redesign
- semantic execution of index traversal (`Value` in executor index paths)

---

## 4) Architectural Constraints (Non-Negotiable)

1. No duplicated composition engine.
Use existing canonical ordered-key stream composition for union/intersection.

2. Planner/executor boundary stays intact.
Execution remains spec-driven and byte-oriented for index traversal.

3. Unsupported composite shape must fallback, not hard-fail.
Return `Ok(None)` for ineligible shapes; use invariant errors only for impossible internal states.

4. DISTINCT/window behavior must remain centralized.
No alternate windowing semantics in composite fast path.

---

## 5) Execution Model

Add one aggregate fast-path branch in aggregate routing order:

1. primary key point/batch
2. secondary prefix
3. primary full/range
4. index-range
5. composite aggregate direct path
6. canonical fallback resolver

Routing pseudocode (normative order):

```rust
if let Some(pk) = try_pk_aggregate(...) { return pk; }
if let Some(prefix) = try_index_prefix_aggregate(...) { return prefix; }
if let Some(scan) = try_primary_scan_aggregate(...) { return scan; }
if let Some(range) = try_index_range_aggregate(...) { return range; }
if let Some(composite) = try_composite_aggregate(...) { return composite; }
return fallback_stream_fold(...);
```

Composite fast path must:

- consume lowered prefix/range specs through existing spec boundaries
- reuse canonical stream production for child composition
- fold through existing aggregate fold path
- keep scan accounting and optimization trace behavior aligned with load execution

---

## 6) Eligibility and Fallback

Composite aggregate fast path is eligible only when:

- access shape is composite (`Union`/`Intersection`)
- plan has no residual predicate requiring post-access filtering
- plan does not require post-access reordering outside canonical stream guarantees
- required lowered specs are present and aligned

Otherwise:

- return `Ok(None)` and use existing canonical aggregate fallback

Invariant violations (error):

- spec/index mismatch
- impossible spec cursor state
- internal routing contract breach

---

## 7) COUNT Mode Decision

For `0.24.0`, composite aggregate direct path does **not** enable composite COUNT pushdown.

Decision:

- composite branch always uses `ExistingRows` fold mode, including `count`

Rationale:

- existing COUNT key-only pushdown safety is currently scoped to non-composite path shapes
- composite composition can include children with stale-key / missing-row behavior where key-only fold can under- or over-count
- this preserves row-existence semantics until composite COUNT key-only safety is formally proven

Future reconsideration gate:

- composite COUNT key-only mode may be enabled only with an explicit proof + parity matrix showing strict equivalence to row-aware fold

---

## 8) Semantics Contract

For composite shapes:

- `count == execute().count()`
- `exists == !execute().is_empty()`
- `min == execute().ids().min()`
- `max == execute().ids().max()`

Must also preserve:

- `Strict` vs `MissingOk`
- DISTINCT behavior
- `ASC`/`DESC` parity
- `offset`/`limit` window semantics
- continuation boundary stability where relevant

---

## 9) Acceptance Matrix

Required regression coverage:

1. Composite aggregate parity matrix:
   - union/intersection
   - asc/desc
   - distinct on/off
   - window permutations
2. Consistency behavior:
   - strict missing-row classification
   - missing-ok stale-key handling
3. Invariant coverage:
   - spec consumption/mismatch checks
   - fallback path for ineligible composite shapes
4. Scan-budget sanity:
   - composite direct path must not exceed canonical fallback `rows_scanned` for equivalent shape
   - composite direct path must not exceed canonical fallback key-stream steps for equivalent shape
   - if exact parity cannot be observed in one case, allow at most `+1` step and require an explicit test comment explaining why

---

## 10) Risk Surface

Primary composite-direct-path risks to guard:

1. Spec misalignment.
Risk: composite branch consumes prefix/range specs in the wrong order.
Guard: strict spec-cursor consumption checks, per-path index alignment checks, and no unused-spec tolerance.

2. Over-scan regressions.
Risk: composite direct path scans materially more keys/rows than canonical fallback for equivalent shapes.
Guard: scan-budget parity assertions against fallback across representative union/intersection matrices.

3. COUNT pushdown misclassification.
Risk: composite branch is accidentally routed to key-only COUNT fold.
Guard: hard route contract that composite always uses `ExistingRows` fold mode in `0.24.0`.

4. Window-before-dedup drift.
Risk: offset/limit are applied before DISTINCT in composite path.
Guard: keep DISTINCT/window boundaries centralized in shared fold path; no branch-local windowing rewrite.

---

## 11) Rollout Plan

Phase 1:

- implement composite aggregate direct-path routing with strict eligibility gates

Phase 2:

- land parity/invariant/scan-budget regressions

Phase 3:

- finalize docs, roadmap/status sync, and changelog framing for `0.24.0`

---

## 12) Non-Goals for `0.24.x`

Patch releases in `0.24.x` are reserved for:

- parity fixes
- invariant hardening
- narrow performance tuning

They do not expand aggregate API surface or rewrite composition architecture.
