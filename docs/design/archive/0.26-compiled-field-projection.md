# 0.26 - Compiled Field Projection

## Purpose

Remove dynamic string-based field lookup from runtime entity read paths and replace it with slot-based field projection.

This aligns:

- aggregate terminal setup validation
- route eligibility checks
- executor inner loops
- aggregate field extraction/comparison logic
- predicate/order/index/save/relation runtime field reads

No user-visible query semantics are intended to change.

---

## Motivation

As of `0.25.x`:

- field targets are resolved by name (`field_model_by_name(...)`-style lookup)
- per-row field access uses `get_value(&str)`
- aggregate loops repeatedly pass field names and branch through string matching

This keeps a dynamic seam in otherwise strongly validated execution.

`0.26` removes string lookup from runtime field reads.

---

## Goals

1. Resolve aggregate target fields once per terminal setup.
2. Eliminate per-row string field lookup in aggregate execution.
3. Introduce slot-based field projection in aggregate executor internals.
4. Preserve existing aggregate semantics and error taxonomy.
5. Keep route/eligibility behavior unchanged.

---

## Non-Goals

- no new aggregate terminals
- no `GROUP BY`
- no planner cost-model redesign
- no cursor redesign
- no change to aggregate eligibility matrix
- no fast-path expansion in `0.26`

---

## Current Model (`0.25.x`)

Setup:

```text
field name
  -> field model lookup
  -> field kind validation
```

Execution loop:

```text
entity.get_value(field_name)
  -> string match
  -> owned Value
```

---

## Target Model (`0.26`)

Setup (aggregate terminal boundary and runtime entity-read boundaries):

```text
field name
  -> (field_index, field_kind)
  -> FieldSlot { index, kind }
```

Execution loop:

```text
entity.get_value_by_index(slot.index)
```

No field-name string lookup in runtime entity-read loops.

Important scope clarification:

- In `0.26`, slot resolution occurs at aggregate terminal setup/executor entry and runtime schema-driven field-read boundaries.
- This does not require embedding aggregate target fields into `Query::plan()` yet.
- String-based lookup remains at setup/validation boundaries where user field names are first resolved.
- Runtime entity reads are index/slot-based.

---

## Core Design

### 1. Introduce `FieldSlot`

Internal type:

```rust
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub(crate) struct FieldSlot {
    pub index: usize,
    pub kind: FieldKind,
}
```

Notes:

- use `usize` for direct indexing and to avoid artificial field-count constraints
- this replaces passing `&str` through aggregate hot paths

### 2. Extend `FieldProjection`

`FieldProjection` in `0.26`:

```rust
fn get_value_by_index(&self, index: usize) -> Option<Value>;
```

Why `Option<Value>` (owned) in `0.26`:

- current entities store typed fields (`u32`, `String`, `Vec<T>`, `Option<T>`), not stored `Value`
- derive currently constructs `Value` on demand
- `Option<&Value>` would require a larger storage-model redesign

Contract:

- runtime entity reads use index-based access
- name-based field references are resolved to indices before runtime entity reads

### 3. Update derive macro output

Derive generates index-based getter.

Shape:

```rust
fn get_value_by_index(&self, index: usize) -> Option<Value> {
    match index {
        0 => Some(self.a.to_value()),
        1 => Some(self.b.to_value()),
        _ => None,
    }
}
```

No intended query semantic change.

### 4. Replace field-name lookup helpers with indexed resolution

Current helper shape:

```rust
fn field_model_by_name(model, field: &str) -> Option<&FieldModel>
```

Target helper shape:

```rust
fn field_model_with_index(model, field: &str) -> Option<(usize, &FieldModel)>
```

This produces `FieldSlot` during setup.

### Field Order Invariant

`FieldSlot.index` corresponds to the stable ordering of fields in `EntityModel.fields`.

The derive macro must emit `get_value_by_index` match arms in the same order as the entity's declared field order, and that order must match `EntityModel.fields`.

A regression test must assert this invariant for representative entities.

Why this is a hard invariant:

- slot-based projection is only correct when field ordering is deterministic
- schema/model field-order drift would otherwise cause silent wrong-field reads

### 5. Refactor aggregate executor field paths

Aggregate field terminals store `FieldSlot` and project per-row values by index.

The following terminal families are in scope:

- extrema field terminals (`min_by`, `max_by`, `min_max_by`, `median_by`, `nth_by`)
- numeric field terminals (`sum_by`, `avg_by`)
- distinct-count field terminal (`count_distinct_by`)

No route-order or fast-path eligibility changes are introduced.

### String-Free Runtime Field-Read Contract

Runtime modules must not call `FieldProjection::get_value(&str)`.

All runtime entity field access goes through `get_value_by_index`.

This is a structural boundary, not a best-effort guideline.

Enforcement options:

- trait surface removal of `get_value(&str)` from `FieldProjection`
- CI guard that forbids `.get_value(` usage in runtime modules
- focused regression test coverage that fails if string-based runtime projection is reintroduced

---

## Secondary Index Compatibility

Design should remain open to future projection sources:

```rust
enum FieldProjection {
    RowSlot(FieldSlot),
    IndexComponent(u8),
}
```

`0.26` may implement only `RowSlot`.

---

## Taxonomy Preservation

No intended change to:

- `Unsupported` classification boundaries
- `Corruption` detection behavior
- `InvariantViolation` contracts
- fail-fast ordering

Existing aggregate error-classification matrix should remain valid.

---

## Performance Expectations

Expected improvements:

- remove per-row string comparisons from aggregate loops
- reduce branch depth in aggregate field projection
- keep schema/model lookup out of inner execution loops

Out of scope in `0.26`:

- eliminating all `Value` construction/allocation
- borrowed projection model (`&Value`) redesign

---

## Testing Requirements

Existing aggregate parity suite should pass unchanged.

Add focused coverage:

1. String-path elimination lock
- assert runtime entity-read modules do not use name-based `get_value(&str)` path.

2. Slot correctness
- slot index matches runtime schema field order.
- out-of-range index behavior is explicit (`None`).

3. Taxonomy stability
- existing field-terminal classification matrix remains stable.

4. Derive/index mapping coverage
- generated `get_value_by_index` behavior matches field declaration order across scalar/optional/list fields.

---

## Migration Plan

Recommended sequence:

1. Extend `FieldProjection` with `get_value_by_index`.
2. Update derive macro to implement it.
3. Update any manual `FieldProjection` impls (test-only or internal).
4. Introduce slot-resolution helper (`field_model_with_index`).
5. Refactor aggregate field executors to use `FieldSlot` + index getter.
6. Refactor runtime schema-driven modules (index/save/relation/order/predicate) to index projection.
7. Remove `get_value(&str)` from `FieldProjection`.
8. Run full workspace gates and aggregate/predicate suites.
9. Tag `0.26.0`.

---

## Pre-Implementation Checklist

Before coding starts:

1. Confirm `Option<Value>` is the `0.26` projection return contract.
2. Confirm slot resolution boundary is terminal setup (not plan embedding) for this milestone.
3. Confirm semver communication for `FieldProjection` trait removal of `get_value(&str)` (manual impl impact).
4. Capture before/after benchmark baselines for aggregate field terminals.

This is a source-breaking change for external manual `FieldProjection` implementations and requires a minor version bump.

---

## Risk Assessment

- engineering effort: moderate
- semantic risk: low
- blast radius: medium (`traits`, derive macro, aggregate executor)

Risk mitigation:

- no route/eligibility expansion in same milestone
- parity + taxonomy regression suite already strong from `0.25.x`
- migration sequence avoids runtime panics
- incorrect index/schema alignment can manifest as logical data corruption rather than type errors, so index-order regression tests are mandatory

---

## Why `0.26` (Not `0.25.x`)

This is a structural change touching:

- trait surface
- derive output
- aggregate executor internals

Even with stable semantics, this belongs in a minor milestone.

---

## Post-`0.26` Position

After completion:

- aggregate field access becomes slot-based and string-free in hot loops
- planner/executor alignment improves
- future optimizations (index projection, borrowed projection, reduced `Value` construction) become easier and safer to stage

`0.26` is the foundation step, not the final projection-performance ceiling.

## `0.26.1+` Follow-Up Focus

`0.26.1+` can focus on performance follow-ups (for example borrowed projection and reduced `Value` construction) now that runtime name-based field reads are removed.

Priority follow-up areas:

- borrowed projection (`&Value`) model design
- reduced projection allocation in hot loops
- pre-resolved projection sources for index-component reads
