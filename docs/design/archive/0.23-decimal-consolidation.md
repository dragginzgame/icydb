# 0.23 ‚Äî Decimal Consolidation & Internal Decimal Engine

## 1Ô∏è‚É£ Purpose

Consolidate numeric decimal behavior behind a single owned `Decimal` implementation and remove fixed-point primitive duplication.

Hard requirements for `0.23`:

* no runtime reliance on `rust_decimal`
* `E8s` and `E18s` are deleted (not retained as runtime/schema aliases)
* schema-level compatibility wrappers exist for `E8s` and `E18s` semantics

Target outcomes:

* one decimal representation across schema, value, and executor paths
* deterministic arithmetic and ordering semantics owned by icyDB
* removal of `rust_decimal`, `E8s`, and `E18s` as independent runtime primitives
* schema-level scale enforcement at write boundaries

---

## 2Ô∏è‚É£ Problem Today

Current numeric surface is fragmented:

* `Decimal` delegates behavior to `rust_decimal`
* `E8s` and `E18s` duplicate fixed-point semantics
* conversion and rounding rules are spread across multiple types
* executor/query logic carries extra branching for equivalent numeric intent

This increases maintenance cost and creates drift risk between numeric paths.

---

## 3Ô∏è‚É£ Scope

### In Scope (0.23)

* Introduce an owned core decimal engine (`raw: i128`, `scale: u32`).
* Route decimal semantics through one runtime type.
* Collapse `Value` fixed-point variants into `Value::Decimal`.
* Remove `Primitive::E8s` and `Primitive::E18s` from schema/runtime surfaces.
* Provide schema newtype wrappers for fixed-scale decimal ergonomics (`E8s`, `E18s`).
* Enforce declared decimal scale at schema boundaries.
* Keep planner architecture and query model unchanged.

### Out of Scope (0.23)

* Arbitrary-precision decimal arithmetic.
* Scientific notation parsing.
* Multi-mode rounding policy matrix.
* Financial/IEEE special values (`NaN`, `Infinity`).
* Planner cost-model redesign.

---

## 4Ô∏è‚É£ Target Decimal Model

```rust
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Decimal {
    raw: i128,
    scale: u32,
}
```

Design intent:

* `raw` stores scaled integer value
* `scale` stores fractional digit count
* behavior remains deterministic and bounded

---

## 5Ô∏è‚É£ Core Invariants

1. `scale <= MAX_SCALE` (single constant, globally enforced).
2. Arithmetic is overflow-checked and fallible at boundaries.
3. Numeric ordering is value ordering (requires explicit scale alignment when needed).
4. Wire encoding is deterministic and order-safe for key/comparison paths.
5. No `NaN`, no `Infinity`, no undefined arithmetic states.

---

## 6Ô∏è‚É£ Required Operations

Only operations required by current database semantics are implemented.

1. Scale alignment:

```rust
fn align(lhs: Decimal, rhs: Decimal) -> Result<(i128, i128, u32), DecimalError>
```

2. Addition and subtraction:

* align operands
* operate on aligned `raw`
* result scale is `max(lhs.scale, rhs.scale)`

3. Multiplication:

* `raw * raw`
* result scale is `lhs.scale + rhs.scale`
* optional explicit rescale at schema boundary

4. Division:

* deterministic pre-rescale + divide path
* one documented rounding rule for 0.23

5. Rescaling:

```rust
fn rescale(self, target_scale: u32) -> Result<Self, DecimalError>
```

6. Parsing/formatting:

* optional sign
* digits
* optional decimal point
* no exponent support

---

## 7Ô∏è‚É£ Schema Enforcement

Decimal fields carry declared scale metadata and writes must respect it.

Target model shape:

```rust
FieldKind::Decimal { scale: u32 }
```

Write-time behavior:

* parse input into `Decimal`
* validate scale compatibility with schema declaration
* rescale or reject based on deterministic rule

### Current pre-work already completed

* Schema macros accept `item(prim = "Decimal", scale = N)`.
* Scale metadata is preserved into runtime model as `FieldKind::Decimal { scale: N }` (required-scale shape).
* `scale` is rejected for non-decimal primitives.

### Compatibility wrappers required for 0.23

`E8s`/`E18s` primitive kinds are removed, but schema ergonomics remain via wrapper newtypes built on decimal scale:

```rust
#[newtype(primitive = "Decimal", item(prim = "Decimal", scale = 8))]
pub struct E8s;

#[newtype(primitive = "Decimal", item(prim = "Decimal", scale = 18))]
pub struct E18s;
```

These wrappers are schema-layer aliases over `Decimal`, not independent runtime primitives.

---

## 8Ô∏è‚É£ Runtime Surface Consolidation

Current `Value` shape includes multiple fixed-point variants.

Target `Value` shape:

```rust
Value::Int
Value::Float
Value::Decimal
```

Implications:

* `E8s`/`E18s` stop being distinct execution-time numeric branches
* aggregate and comparison paths operate through one decimal route
* fewer coercion/normalization permutations

---

## 9Ô∏è‚É£ Compatibility and Migration Strategy

Migration should remain compile-stable through incremental phases.

Phase 1:

* land owned `Decimal` core + tests
* keep legacy fixed-point types as adapters

Phase 2:

* route `E8s`/`E18s` internals through new `Decimal`
* remove duplicate arithmetic logic

Phase 3:

* swap parsing/formatting off `rust_decimal`
* remove dependency

Phase 4:

* collapse `Value` and schema primitive surfaces
* delete fixed-point variants

Phase 5:

* finalize schema boundary enforcement and cleanup transitional `Option` scale shape

---

## üîü Test Plan

Minimum required matrix:

1. Arithmetic correctness:
   * align/add/sub/mul/div/rescale invariants
   * overflow and boundary cases
2. Ordering correctness:
   * cross-scale comparisons
   * index/predicate ordering parity
3. Parsing/formatting round-trip:
   * valid forms
   * invalid forms
4. Schema enforcement:
   * scale accepted/rejected exactly as declared
5. Compatibility checks:
   * legacy `E8s`/`E18s` conversion parity during transition
6. Executor/query parity:
   * identical predicate and aggregate results before/after consolidation

---

## 1Ô∏è‚É£1Ô∏è‚É£ Risks and Mitigations

Primary risks:

* rounding drift during transition
* overflow behavior mismatches
* comparison alignment bugs

Mitigations:

* single operation entry points (no duplicated arithmetic logic)
* parity tests against current behavior where semantics are intended to remain stable
* explicit error variants for overflow/invalid-scale paths

---

## 1Ô∏è‚É£2Ô∏è‚É£ Completion Criteria

0.23 is complete when all of the following hold:

* `rust_decimal` is removed from workspace runtime dependencies (no runtime reliance remains)
* `E8s` and `E18s` are deleted from schema/runtime surfaces
* schema newtype wrappers exist for `E8s`/`E18s` fixed-scale compatibility
* all decimal semantics route through owned `Decimal`
* schema scale enforcement is active and tested
* executor/query behavior remains stable for supported numeric operations
