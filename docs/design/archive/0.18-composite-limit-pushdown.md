# 0.18 Design: Execution Scan Budgeting + Composite Pagination Correctness

## Overview

Version 0.18 introduces a safer form of execution-level scan budgeting:

- budget-aware
- shape-aware
- semantics-aware

Goal:

> Reduce unnecessary key production while preserving deterministic ordering,
> continuation correctness, and existing error semantics.

No changes to:

- Public API
- Cursor token format
- Storage format
- Index encoding
- Error taxonomy

This is an internal execution optimization, not a planner redesign.

Positioning:

- Primary target: composite execution (`Union`, `Intersection`)
- Non-exclusive: any plan shape is eligible when safety guards prove correctness
- 0.18 also freezes composite pagination correctness invariants (folded in from
  former 0.19 planning scope)

---

# 1. Problem Statement

Current behavior (0.17):

- Composite execution (`Union`, `Intersection`) is stream-native.
- Pagination (`offset`, `limit`) is still enforced in post-access phases.
- Composite streams are not explicitly bounded by a derived scan budget.

This means execution may do extra work before post-access pagination
trims rows.

Important constraint:

> A blanket wrapper with `remaining = limit` is not semantics-safe for all plan
> shapes because offset, cursor, filtering, and post-access ordering can require
> reading beyond `limit` rows.

---

# 2. Design Goals

## G1 - Preserve Semantics

- Identical result ordering (ASC/DESC)
- Identical continuation behavior
- Identical duplicate suppression
- Identical error classification

## G2 - Guarded Optimization

- Apply only when a safe plan shape is proven
- Return `None` (no optimization) when safety is unclear
- Keep fallback path exactly as 0.17

## G3 - Deterministic Budgeting

- Compute an internal scan budget as `offset + limit + 1` when safe
- Stop polling once the budget is consumed
- Never pull additional keys after budget exhaustion

---

# 3. Revised 0.18 Scope

## 3.1 Introduce Internal Scan Budget

Add an internal helper at the logical-planning boundary:

```rust
fn derive_scan_budget(
    plan: &LogicalPlan<...>,
    cursor: Option<&CursorBoundary>,
) -> Option<usize>
```

Contract:

- Returns `None` when budgeted execution is unsafe.
- Returns `Some(offset + limit + 1)` when safe.

Why `+1`:

- Needed for stable continuation detection (same rationale as bounded ordering).

## 3.2 Guarded Application

Apply budget only to safe shapes where post-access phases cannot invalidate
budget assumptions.

If any safety precondition fails, do not apply budgeting.

## 3.3 Explicit Invariant Tests

Must add tests that prove correctness at boundaries, especially when budgeting
is intentionally disabled.

---

# 4. Safety Model

Budgeting is allowed only when all required conditions hold.

## Required Conditions (v1)

1. `plan.mode` is load.
2. `plan.page.limit` is present.
3. Access path already satisfies final ordering.
4. No residual filter phase remains after access.
5. No post-access reordering requirement (`!plan.requires_post_access_sort`).

Pragmatic v1 rule:

- Start conservative.
- If any condition cannot be proven from plan metadata, return `None`.

This keeps 0.18 correct first, then expandable.

## 4.1 Formal Safety Invariant

Budgeting is safe only if:

- access stream is a final, stable, monotonic ordering of all rows that may
  appear in the final page.
- no post-access phase can remove earlier rows.
- no post-access phase can insert earlier rows.
- no post-access phase can reorder rows.

If these conditions are not provable from `LogicalPlan` metadata, budgeting must
not be applied.

## 4.2 Formal Guard Definitions (Required)

Two guards must be concrete booleans on the executable plan surface.

### A) Access-order satisfaction

Conceptual text is not sufficient. Define an enforceable helper:

```rust
fn is_access_order_satisfied_by_path(plan: &LogicalPlan<...>) -> bool
```

This returns `true` only when the executor can assert that the access-path stream
already emits rows in the exact canonical order used by post-access ordering
comparison logic.

If this cannot be proven, return `false`.

### B) Residual filter drift

Define explicit residual-filter metadata; do not infer ad hoc at call sites.

Minimum contract:

```rust
// Example shape; exact naming can vary.
plan.has_residual_filter: bool
```

Semantics:

- `false`: predicate is fully satisfied by access (no post-access row filtering needed).
- `true`: post-access filtering is still required.

Budgeting must require:

```rust
!plan.has_residual_filter
```

Without this metadata, safe budgeting is not implementable.

### C) Post-access reorder requirement

Define explicit reordering metadata; do not infer this from comments or call-site
conventions.

Minimum contract:

```rust
// Example shape; exact naming can vary.
plan.requires_post_access_sort: bool
```

Budgeting must require:

```rust
!plan.requires_post_access_sort
```

## 4.3 Derived Rule

Budgeting is valid if and only if both statements are true:

1. Access-phase stream order is already the final canonical order used by post-access comparison.
2. Access-phase filtering is complete (no residual row-elimination phase remains).

Under this invariant, pagination is pure windowing (`offset`, `limit`) over a
stable ordered stream, so early termination is semantics-preserving.

Offset rule (explicit):

- `offset` is applied strictly as windowing over that stable ordered stream.
- if offset is ever applied earlier in the pipeline, this budget math is invalid.

## 4.4 Cursor-Narrowing Rule

Cursor handling must be explicit in the safety model.

- cursor anchor narrows the candidate set before pagination windowing.
- cursor narrowing cannot introduce rows.
- cursor narrowing cannot reorder rows.

Budget must be interpreted against the post-cursor stream:

`offset + limit + 1` after cursor narrowing.

Therefore, cursor must be either:

1. included in access-phase equivalence proof, or
2. treated as residual narrowing (disable budgeting).

If this is not provable from plan/cursor metadata, budgeting must not be applied.

---

# 5. Internal API Shape

## 5.1 Budget Derivation

```rust
fn derive_scan_budget(
    plan: &LogicalPlan<...>,
    cursor: Option<&CursorBoundary>,
) -> Option<usize> {
    let page = plan.page.as_ref()?;
    let limit = page.limit?;

    if !is_budget_safe_shape(plan, cursor) {
        return None;
    }

    let offset = usize::try_from(page.offset).unwrap_or(usize::MAX);
    let limit = usize::try_from(limit).unwrap_or(usize::MAX);
    Some(offset.saturating_add(limit).saturating_add(1))
}
```

`is_budget_safe_shape(plan, cursor)` must be defined from concrete booleans, including:

- `is_access_order_satisfied_by_path(plan)`
- `!plan.has_residual_filter`
- `!plan.requires_post_access_sort`
- `cursor_narrowing_is_budget_safe(plan, cursor)`

## 5.2 Stream Wrapper (Internal)

```rust
pub(crate) struct BudgetedOrderedKeyStream<S> {
    inner: S,
    remaining: usize,
}
```

Behavior:

- `remaining == 0` -> `Ok(None)` without polling inner
- on `Some(key)` -> decrement remaining and return key
- on `None` -> return `None`

This wrapper is only applied when `derive_scan_budget(...)` returns `Some`.

---

# 6. Integration Plan

Integrate at executor stream-consumption boundary, not as a blanket change.

Concrete integration point (required):

- Function: `LoadExecutor::materialize_key_stream_into_page`
  (`crates/icydb-core/src/db/executor/load/mod.rs`)
- Boundary call: `Context::rows_from_ordered_key_stream(key_stream, ...)`

Budget wrapping must happen on `OrderedKeyStream` immediately before this
boundary call.

Do not apply budgeting:

- inside access-path producers (`AccessPath::produce_key_stream`)
- during composite stream construction (`produce_union_key_stream` /
  `produce_intersection_key_stream`)
- inside logical post-access phases (`apply_post_access_with_cursor`)

High-level flow:

1. Build existing ordered key stream as in 0.17.
2. Ask `derive_scan_budget(plan, cursor_boundary)`.
3. If `Some(budget)`, wrap stream with `BudgetedOrderedKeyStream` in
   `materialize_key_stream_into_page`, before calling
   `rows_from_ordered_key_stream`.
4. Continue existing row materialization and post-access phases unchanged.
5. If `None`, run unchanged 0.17 path.

Critical:

- No change to cursor encoding.
- No change to post-access phase order.
- No double-limit enforcement semantics drift.

---

# 7. Plan-Shape Semantics

## Composite (Primary Target)

Budgeting can reduce composite merge work after enough rows for
`offset + limit + 1` have been produced.

Intersection behavior follows the same rule:

Budgeting can reduce intersection comparisons once enough matched rows have been
produced for page construction and continuation determination.

In composite cases:

- ordering guarantees remain owned by stream operators
- limit semantics remain owned by logical post-access pagination

## Single-Path (Allowed When Safe)

If a single-path shape satisfies the same safety guards, it is eligible for the
same budgeting mechanism. Composite paths remain the primary optimization target,
but not the exclusive target.

---

# 8. Continuation Semantics

Must remain unchanged.

- continuation anchor is still derived from last emitted row after canonical post-access phases
- token format is unchanged
- boundary ordering semantics are unchanged
- cursor narrowing is treated as pre-window candidate reduction for budgeting
  safety, or budgeting is disabled

Budgeting is an upstream optimization only.

Budgeting may suppress errors from rows beyond the pagination window; this is
consistent with existing LIMIT semantics.

---

# 9. Performance Expectations

## Short-Term (0.18)

- Reduced composite stream polling/comparison work on eligible shapes.
- Limited wins on paths that still pre-materialize access-path keys.

## Longer-Term

Largest IO wins require lazy access-path producers (instead of pre-collecting
vectors before stream composition).

That is a follow-on milestone, not required to ship guarded 0.18 safely.

---

# 10. Required Test Matrix

Must include:

1. `offset + filter`
2. `offset + cursor`
3. filter removing early rows
4. composite + offset
5. DESC + offset + limit
6. nested composite + pagination

Plus:

7. budget-safe shape uses budget path
8. unsafe shape (`has_residual_filter = true`) returns `None` and falls back
9. limit=0 behavior remains unchanged
10. unsafe shape (`is_access_order_satisfied_by_path = false`) returns `None` and falls back
11. unsafe shape (`requires_post_access_sort = true`) returns `None` and falls back
12. cursor present but not budget-safe falls back
13. continuation token parity vs baseline for eligible shapes

Regression suites must pass unchanged.

---

# 11. Out of Scope

Not included in 0.18:

- branch reordering heuristics
- cardinality estimation
- cost-based pruning
- broad planner redesign
- mandatory lazy access-path production

---

# 12. Risks

Primary risks:

1. wrong safe-shape classification
2. accidental early truncation under filter/cursor/offset interaction
3. continuation boundary drift due to incorrect budget assumptions

Mitigation:

- conservative guard rules
- strict fallback to current behavior
- invariant-heavy regression tests

---

# 13. Milestone Completion Criteria

- [x] `derive_scan_budget(plan, cursor) -> Option<usize>` implemented
- [x] safe-shape guard function implemented and conservative
- [x] budget wrapper integrated only behind guard
- [x] fallback path is unchanged when budget is `None`
- [x] no continuation semantic drift
- [x] required edge-case matrix passes
- [x] full existing test suite passes

---

# 14. Expected Outcome

After 0.18:

- execution can be budget-bounded on safe shapes (composite-first, non-exclusive)
- pagination semantics remain unchanged
- continuation semantics remain unchanged
- optimization remains internal and non-breaking

This delivers a correct foundation for future IO-focused improvements.

---

# 15. Composite Pagination Contract (Folded from Former 0.19 Plan)

This section is now part of 0.18 and defines deterministic pagination behavior
for composite plans.

## 15.1 Global Ordering Contract

Composite plans must emit keys in strict monotonic order under the selected
direction, independent of child-plan ordering.

- `Union`: ordered merge with dedupe
- `Intersection`: ordered alignment across child streams

## 15.2 Canonical Pagination Phase Order

A page is defined over one phase order:

1. Build globally ordered composite stream.
2. Apply cursor anchor narrowing (`strictly past anchor`).
3. Apply offset.
4. Apply limit and derive continuation from the last emitted key.

Budgeting may reduce polling work but may not change this semantic phase order.

## 15.3 Continuation Anchor Rule

Composite continuation uses one anchor only:

- Anchor = last emitted key from previous page.
- Resume uses excluded-bound semantics in comparator space (ASC or DESC).
- Per-stream anchors are out of scope and prohibited.

## 15.4 Invariants

Composite pagination correctness requires:

1. No duplicates across adjacent pages.
2. No omissions across full pagination traversal under fixed data.
3. Stable strict monotonic ordering under ASC and DESC.
4. Subplan permutation invariance (child order does not alter output sequence or
   continuation boundaries).

## 15.5 Interaction with 0.18 Budgeting

Budgeting cannot alter composite stream semantics.

- It must not change which key becomes continuation anchor.
- It must not break union dedupe (`advance all equal heads`).
- It must not break intersection alignment semantics.
- Budget wrapping remains allowed only at
  `LoadExecutor::materialize_key_stream_into_page` before
  `Context::rows_from_ordered_key_stream(...)`.

## 15.6 Test Matrix Additions (Folded Into 0.18)

Required composite pagination coverage:

- Union: disjoint, overlap, empty child, boundary overlap at anchor, nested
  composite.
- Intersection: full overlap, partial overlap, empty child, zig-zag alignment,
  boundary alignment.
- For each in ASC and DESC:
  - page sizes `1`, `2`, and `>2`
  - resume across every page boundary
  - assert no-dup/no-omission/stable order
- At least one explicit subplan permutation-invariance suite.

---

# 16. Combined 0.18 Completion Criteria

0.18 is complete when all budgeting and composite pagination criteria are true:

- [x] `derive_scan_budget(plan, cursor) -> Option<usize>` implemented
- [x] conservative budget-safe shape classification implemented
- [x] budget wrapper integrated only at stream-consumption boundary
- [x] fallback behavior unchanged when budget is not applied
- [x] continuation boundary parity holds for budgeted vs non-budgeted paths
- [x] composite cursor continuation follows single-anchor semantics
- [x] explicit composite subplan permutation-invariance suite is present
- [x] existing regression suite remains green

---

# 17. Combined Expected Outcome

After 0.18:

- guarded scan budgeting is live for provably safe shapes
- composite pagination semantics are frozen in one milestone contract
- continuation behavior stays deterministic across ASC/DESC and resume paths
- no separate 0.19 execution-pagination milestone is required
