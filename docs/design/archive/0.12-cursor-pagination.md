# Cursor Pagination Design

## 1. Purpose

Define deterministic, duplication-free, omission-free pagination semantics for `AccessPath::IndexRange` (single-path only).

This document specifies:

* Continuation semantics
* Cursor structure
* Boundary handling
* Correctness invariants
* Explicit non-goals

This phase does **not** introduce:

* Binary cursor encoding
* Composite access tree pagination
* Descending order support (unless already supported)

---

# 2. Scope

### In Scope

* `AccessPath::IndexRange`
* Forward pagination only
* Single-path execution plans
* Store-level continuation via raw key bounds

### Out of Scope (Deferred)

* Composite `Union` / `Intersection`
* DESC traversal
* Pushdown order optimization
* Binary/opaque cursor encoding
* Cross-query cursor reuse

---

# 3. Correctness Guarantees

Pagination must guarantee:

1. **No duplication**

   * An item returned on page N must never appear on page N+1.

2. **No omission**

   * All items within the original IndexRange bounds must eventually be returned.

3. **Stable ordering**

   * Results follow strict index key lexicographic ordering.

4. **Bound preservation**

   * Continuation must never escape original `(prefix, lower, upper)` bounds.

5. **Deterministic resume**

   * Cursor must resume exactly after the last returned raw key.

---

# 4. IndexRange Recap

Given:

```
IndexRange {
    index,
    prefix: [a₀ … aₖ₋₁],
    lower: Bound<Value>,   // applies to component k
    upper: Bound<Value>,
}
```

Execution currently:

1. Construct composite bounds:

   ```
   start = composite(prefix, lower, suffix strategy)
   end   = composite(prefix, upper, suffix strategy)
   ```

2. Execute:

   ```
   entry_map.range((start_raw, end_raw))
   ```

In forward (ASC) traversal, pagination must modify only the `start` bound for continuation.

---

# 5. Cursor Model (Phase 3 – Transparent)

Cursor is a logical structure:

```rust
struct IndexRangeCursor {
    last_raw_key: RawIndexKey,
}
```

Properties:

* Raw key must be the exact composite key of the last emitted index entry.
* No partial encoding.
* No transformation.

Cursor is **opaque to the caller** but internally transparent.

---

# 6. First Page Execution

Initial bounds:

```
start = original lower bound
end   = original upper bound
```

Execute:

```
range((start_raw, end_raw))
```

Collect up to `limit` entries.

If fewer than `limit` entries:

* No cursor returned.
* Pagination complete.

If exactly `limit` entries and bounded traversal is not exhausted:

* Cursor = last entry’s raw key.

If exactly `limit` entries and bounded traversal is exhausted at that boundary:

* No cursor returned.

---

# 7. Continuation Execution

Given:

```
cursor.last_raw_key = K
```

New bounds:

```
start = Bound::Excluded(K)
end   = original upper bound
```

Then:

```
range((start_raw, end_raw))
```

Important:

* The upper bound is unchanged.
* The prefix constraint is implicitly enforced by original bound construction.

---

# 8. Critical Invariants

### Invariant 1 — Prefix Isolation

All raw keys scanned must satisfy:

```
key.components[0..k] == prefix
```

This is already guaranteed by composite bound construction.

---

### Invariant 2 — Strict Advancement

Continuation always uses:

```
Bound::Excluded(last_raw_key)
```

Never Included.

This guarantees no duplication.

---

### Invariant 3 — Bound Respect

If `last_raw_key == effective_composite_upper_raw_key`, continuation must return zero results.

This comparison is done in raw-key space, not value-space.

---

### Invariant 4 — Monotonic Raw Key Ordering

For any page, emitted `RawIndexKey` values must form a strictly increasing sequence.

Continuation must preserve this monotonic progression across pages.

---

# 9. Edge Cases to Test

## Case A — Lower Inclusive

```
>= 10
```

First key exactly equal to 10.

Page split must not re-emit 10 on next page.

---

## Case B — Lower Exclusive

```
> 10
```

Keys with component = 10 must never appear.

---

## Case C — Upper Inclusive

```
<= 20
```

If last key equals 20 group, continuation must stop correctly.

---

## Case D — Upper Exclusive

```
< 20
```

Group 20 must never appear.

---

## Case E — Page Boundary Inside Component Group

If page ends in middle of same component group:

```
(7, 10, pk=1)
(7, 10, pk=2)
(7, 10, pk=3)
```

Continuation must resume at:

```
(7, 10, pk=3) excluded
```

Not at component-level boundary.

---

## Case F — Unique Index

Ensure continuation works when only one PK per index entry.

---

## Case G — Exhaustion

When continuation start exceeds upper bound, return empty.

---

# 10. API Changes Required

Executor must:

1. Track raw key per emitted result.
2. Stop after `limit`.
3. Store last raw key.
4. On continuation, replace lower bound with `Excluded(last_raw_key)`.

Store API does not need modification if raw bound iteration already exists.

---

# 11. Cursor Validation

Architectural decision (locked for Phase 3):

* `IndexRange` continuation anchor is `RawIndexKey`.
* `DataKey` must not be used as the continuation anchor.

Validation is required on every continuation request.

Required checks:

1. Decode cursor envelope/version.
2. Verify continuation signature matches the current canonical plan shape.
   * This binds continuation to entity path + mode + access path + predicate + order.
3. Decode `last_raw_key` as `RawIndexKey` / `IndexKey`.
4. Verify key identity matches the current index path:
   * same index id
   * same key namespace
   * same fixed component arity for the target index
5. Verify key remains inside original IndexRange envelope (prefix + lower/upper constraints).

If any check fails, reject the cursor.

---

# 12. Cursor Encoding & Stability Policy (Pre-0.13)

## 12.1 Scope of This Phase

This defines **cursor semantics and internal continuation mechanics only**.

It does **not** define:

* Stable binary encoding
* Wire-format guarantees
* Cross-version compatibility
* Cursor persistence guarantees
* Long-lived cursor contracts

Cursor representation in this phase is considered:

> Internal execution state, not a protocol-level artifact.

---

## 12.2 Internal Representation (Phase 3)

The cursor model for `IndexRange` is:

```rust
struct IndexRangeCursor {
    last_raw_key: RawIndexKey,
}
```

Properties:

* `RawIndexKey` is treated as a physical traversal anchor.
* It reflects exact BTree ordering position.
* It must not be exposed directly in public APIs.
* It is not considered a stable serialization format.

The executor may retain this value internally for continuation,
but higher layers must treat it as opaque.

---

## 12.3 Stability Guarantees (Current Phase)

In Phase 3, the following is guaranteed:

* Pagination continuation is deterministic within a single deployment.
* Continuation correctness holds within a consistent storage layout and index
  encoding implementation.
* Cursor resumes are valid only against the identical canonical plan shape.

The following is **not guaranteed**:

* Cursor validity across engine upgrades.
* Cursor validity after index definition changes.
* Cursor validity after schema migrations.
* Cursor portability between deployments.
* Cursor persistence across long time horizons.

Any of these behaviors are explicitly outside the contract until 0.13.

---

## 12.4 Contract Boundary

The architectural boundary in this phase is:

> Cursor = physical traversal position within a specific execution context.

It is not:

> Cursor = durable, versioned, portable continuation contract.

This distinction is intentional to avoid prematurely freezing storage or encoding policy.

---

## 12.5 Transition to 0.13 (Binary Cursors)

Version 0.13 will introduce:

* Versioned binary cursor encoding
* Explicit cursor envelope structure
* Cursor format stability guarantees
* Compatibility validation rules
* Defined cursor lifetime semantics

At that point, cursor encoding becomes part of the public contract and must:

1. Be versioned.
2. Include plan identity binding.
3. Fail safely if incompatible.
4. Avoid leaking physical storage layout.
5. Define compatibility across minor/major releases.

Phase 3 intentionally avoids making any of these commitments.

---

## 12.6 Architectural Principle

The guiding principle for Phase 3 is:

> Establish semantic correctness before freezing representation.

Binary cursor encoding (0.13) will freeze representation.
Phase 3 ensures the underlying continuation semantics are correct before that commitment is made.


---

# 13. Success Criteria

All of the following must hold:

* Repeated pagination yields identical result set as single unbounded query.
* No duplicates across pages.
* No missing keys.
* All edge-case tests pass.
* Trace confirms strict advancement of lower bound.

---

# 14. Future Extensions

* DESC pagination
* Composite access trees
* Pushdown order integration
* Binary cursor format
* Versioned cursor encoding
