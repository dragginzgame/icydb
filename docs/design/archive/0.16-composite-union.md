# 0.16 Composite Access Execution — `Union`

## 1. Purpose

Introduce deterministic composite access-path execution via `AccessPath::Union`.

0.16 expands execution capability while preserving:

* Strict ordering invariants
* Duplicate-free guarantees
* Continuation and limit semantics
* Existing error classification boundaries

This milestone builds directly on the 0.15 ordered-key stream abstraction.

---

## 2. Scope

### In Scope

* `AccessPath::Union(Vec<AccessPath>)`
* Planner emission of `Union` for eligible `OR` predicate shapes
* Executor support for N-way ordered merge using stream abstraction
* Stable duplicate suppression across child paths
* ASC and DESC parity
* LIMIT + continuation compatibility (no semantic relocation)

### Out of Scope

* `Intersection` execution
* Cross-entity union
* Cost-based plan selection
* Pushdown limit across children
* Cursor ownership relocation
* Public streaming API
* Async execution

---

## 3. Architectural Preconditions (from 0.15)

0.15 guarantees:

* All access paths produce `OrderedKeyStream`
* Executor consumes streams
* No direct `Vec<DataKey>` surfaces remain

0.16 assumes this as invariant baseline.

---

## 4. AccessPath Extension

Add:

```rust
AccessPath::Union {
    children: Vec<AccessPath>,
}
```

Constraints:

* `children.len() >= 2`
* All children must:

  * Target same entity
  * Share identical ordering spec
  * Be individually valid access paths
* Planner must flatten nested unions:

  * `Union([A, Union([B, C])]) → Union([A, B, C])`

Executor does not perform recursive flattening.

---

## 5. Planner Rules

### 5.1 Emission Conditions

Planner may emit `Union` when:

* Predicate is `OR`
* Each branch independently indexable
* No cross-branch dependency
* Same ordering spec applies to all branches

Planner must not emit `Union` if:

* Branches require conflicting order specs
* Branches target different entities
* Branch requires post-filter that violates ordering

---

## 6. Executor Model

### 6.1 Execution Overview

For `AccessPath::Union`:

1. For each child:

   * Build `OrderedKeyStream`
2. Merge streams into one canonical ordered stream
3. Feed merged stream into existing executor pipeline

No change to post-access row materialization phases.

---

## 7. Merge Strategy

### 7.1 N-Way Merge

Use recursive binary merge built on existing `MergeOrderedKeyStream`.

Pseudo-structure:

```rust
fn merge_all(streams: Vec<OrderedKeyStreamBox>) -> OrderedKeyStreamBox
```

Implementation:

* While `streams.len() > 1`:

  * Merge pairwise into new vector
* Return single stream

No heap-based k-way merge in 0.16.

---

## 8. Ordering Semantics

### 8.1 Direction Ownership

Planner must supply explicit ordering:

```rust
ExecutionOrdering {
    direction: Asc | Desc
}
```

Executor must:

* Construct merge with explicit direction
* Reject direction mismatch as `InvariantViolation`

Runtime direction inference is not allowed in composite context.

---

### 8.2 Deduplication

Duplicate suppression rules:

* Equality based on raw `DataKey`
* Global across all children
* Stable (first occurrence wins)

No semantic-layer dedup.

---

## 9. Continuation and LIMIT Compatibility

0.16 does not relocate continuation or limit ownership.

Requirements:

* LIMIT must behave identically to single-path case
* No duplication across pages
* No omission across pages
* Stable DESC continuation

Pushdown of LIMIT across children is deferred.

---

## 10. Error Classification Rules

Executor must preserve error origin and class.

| Condition                | Classification      |
| ------------------------ | ------------------- |
| Child stream error       | Propagate unchanged |
| Direction mismatch       | InvariantViolation  |
| Invalid child path shape | InvariantViolation  |
| Storage decode failure   | Corruption          |

No downgrading or remapping across layers.

---

## 11. Invariants

Composite execution must guarantee:

1. Strict monotonic ordering
2. No duplicate keys emitted
3. No omission across children
4. Stable comparator semantics
5. Error origin fidelity preserved

---

## 12. Test Matrix

### 12.1 Basic Execution

* Two disjoint ranges (ASC)
* Two disjoint ranges (DESC)
* Three children
* One empty child
* All children empty

### 12.2 Overlap Cases

* Single-key overlap
* Partial overlap
* Full overlap
* Identical children

### 12.3 LIMIT Matrix

* LIMIT within first child
* LIMIT crossing child boundary
* LIMIT equal to boundary
* LIMIT with DESC
* LIMIT across overlapping children

### 12.4 Error Cases

* Child stream error
* Direction mismatch
* Nested union flattening correctness

---

## 13. Completion Criteria

0.16 is complete when:

* Planner can emit `Union`
* Executor supports N-way ordered merge
* Direction enforced at merge construction
* Full regression suite green
* No behavioral regressions in:

  * Continuation
  * DESC
  * LIMIT pushdown
  * Explain surface
  * Metrics surface

---

## 14. Strategic Impact

After 0.16:

IcyDB transitions from:

> Deterministic single-path executor

to:

> Deterministic composite-path executor

This unlocks:

* OR predicate execution via multiple indexes
* Multi-index plans
* Foundation for future `Intersection`
* Foundation for cost-based optimization

---

## 15. Next Milestones (Preview)

* 0.17 — `Intersection` stream execution
* 0.18 — Stream-level LIMIT ownership
* 0.19 — Cost-based planner heuristics
