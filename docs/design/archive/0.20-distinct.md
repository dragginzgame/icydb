# 0.20 — DISTINCT (Design Proposal)

## 1️⃣ Scope Definition

### In Scope

* DISTINCT over full entity rows
* Applies after predicate filtering
* Works with:

  * ByKey
  * KeyRange
  * IndexPrefix
  * IndexRange
  * Union
  * Intersection
* Compatible with pagination
* Compatible with ASC / DESC

### Out of Scope (0.20)

* DISTINCT over projections (partial field distinct)
* COUNT DISTINCT
* DISTINCT ON (Postgres-style)
* Hash-based distinct

This is ordered DISTINCT only.

---

# 2️⃣ Semantics

Because all execution is driven by ordered streams:

DISTINCT means:

> Suppress consecutive equal primary keys in final key stream.

Important:

You already suppress duplicates in:

* MergeOrderedKeyStream
* IntersectOrderedKeyStream

So duplicates only arise when:

* Union child streams overlap non-identically
* Planner emits overlapping access paths
* User query duplicates keys logically

DISTINCT must guarantee:

* No key appears more than once in final page
* Pagination must remain correct
* Continuation must remain monotonic

---

# 3️⃣ Where DISTINCT Lives

There are three architectural placement options:

### Option A — LogicalPlan flag

Add:

```rust
pub struct LogicalPlan<K> {
    ...
    distinct: bool,
}
```

Planner sets it.
Executor reads it.

This is the cleanest.

---

### Option B — AccessPlan variant

Add:

```rust
AccessPlan::Distinct(Box<AccessPlan>)
```

This pollutes plan shape unnecessarily.

Reject.

---

### Option C — Executor wrapper only

Executor always wraps stream if query requests distinct.

This is correct but planner should still own the flag.

So we choose:

> LogicalPlan-level flag.

---

# 4️⃣ Execution Strategy

You already have:

```rust
OrderedKeyStream
```

So introduce:

```rust
DistinctOrderedKeyStream<S>
```

Implementation:

```rust
pub(crate) struct DistinctOrderedKeyStream<S> {
    inner: S,
    last_emitted: Option<DataKey>,
}
```

Behavior:

* Pull from inner
* If equal to last_emitted → skip
* Otherwise emit

Because stream is ordered, this is correct.

No hashing.
No buffering.
O(1) memory.

---

# 5️⃣ Where to Insert Wrapper

Inside LoadExecutor:

In both:

* Fast path
* Fallback path

Immediately after key stream construction, before materialization:

```rust
let mut key_stream = ...;

if plan.distinct {
    key_stream = Box::new(DistinctOrderedKeyStream::new(key_stream));
}
```

This ensures:

* Dedup before pagination window is applied
* Continuation cursor sees correct boundary

Important:
DISTINCT must operate before pagination limit/offset windowing.

Otherwise page size semantics break.

---

# 6️⃣ Pagination Correctness

Pagination logic currently:

* Collect keys
* Apply page window
* Emit continuation boundary

Because DISTINCT preserves monotonic order and does not reorder:

* Cursor spine remains valid.
* Anchor advancement remains valid.

No cursor format change needed.

---

# 7️⃣ Fast-Path Interaction

Fast paths return:

```rust
FastPathKeyResult {
    ordered_key_stream,
    rows_scanned,
    optimization
}
```

Distinct wrapping must occur before materialize_key_stream_into_page.

Therefore:

Modify finalize_fast_path_page:

Before calling materialize_key_stream_into_page:

Wrap stream if distinct.

Do not alter optimization classification.

DISTINCT is a logical property, not an optimization.

---

# 8️⃣ Planner Surface

Expose API:

```rust
Query::distinct()
```

Planner sets:

```rust
logical_plan.distinct = true;
```

No access-path rewrite required.

---

# 9️⃣ Execution Trace

Extend:

```rust
pub struct ExecutionTrace {
    ...
    distinct_applied: bool,
}
```

Optional but useful.

---

# 10️⃣ Tests Required

## Unit Tests

* ByKey distinct no-op
* Union overlapping streams
* Intersection redundant duplicates
* IndexRange overlapping prefix
* ASC distinct
* DESC distinct
* Pagination:

  * Page size smaller than unique set
  * Page size smaller than duplicates cluster

## Continuation Tests

* Resume after duplicate cluster
* Resume across page boundary where duplicate straddles pages

This ensures correct interaction with cursor spine.

---

# 11️⃣ Complexity Impact

Very low.

New code:

* ~40 lines for wrapper
* ~20 lines planner flag
* Minor executor hook
* Tests

No new invariants.

---

# 12️⃣ Why This Is a Good 0.20

It validates your architecture:

* Ordered stream abstraction is strong
* Cursor spine handles continuation correctly
* Fast-path separation remains intact

If DISTINCT is easy to add, your design is healthy.

If it’s painful, architecture is wrong.

In your case — it will be clean.

---

# 0.20 Summary

| Dimension              | Impact               |
| ---------------------- | -------------------- |
| Storage                | None                 |
| Planner                | Small flag addition  |
| Executor               | Small stream wrapper |
| Cursor                 | No change            |
| Fast paths             | No rewrite           |
| Risk                   | Low                  |
| Architectural pressure | Healthy              |
