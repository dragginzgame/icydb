# 0.15 Ordered Iterator Abstraction

## 1. Purpose

Introduce a unified **ordered traversal abstraction** for query execution.

This abstraction replaces ad-hoc `Vec<DataKey>` and `Vec<DataRow>` materialization flows with a composable, streaming-capable execution model.

The goal is to:

* Eliminate unnecessary materialization
* Centralize traversal semantics
* Enable pushdown-friendly execution
* Support ASC and DESC uniformly
* Provide a foundation for composite access trees

This phase does **not** introduce:

* Streaming APIs at the public boundary
* Aggregations
* Join operators
* Cross-query cursor reuse
* Query optimizer rewrite

---

# 2. Motivation

Current execution model:

```
AccessPath
→ collect candidate keys (Vec<DataKey>)
→ load rows (Vec<DataRow>)
→ sort
→ filter
→ truncate (limit)
```

Problems:

1. Early materialization prevents pushdown efficiency.
2. Logical and physical order semantics are duplicated.
3. DESC support duplicates traversal logic.
4. Union/Intersection materialize intermediate sets.
5. Continuation semantics are layered around a Vec model.

Ordered iteration solves this by:

> Making traversal itself the primitive, not materialized collections.

---

# 3. Design Principles

### 3.1 Ordered Traversal is First-Class

Traversal must preserve strict order invariants:

* ASC: strictly increasing raw key
* DESC: strictly decreasing raw key
* No duplicates
* Envelope-respecting bounds

### 3.2 Continuation Anchors Are Traversal-Level

The iterator must:

* Accept a continuation anchor
* Enforce strict advancement
* Never emit anchor row

### 3.3 Limit Is Traversal Concern

Limit truncation should:

* Occur inside traversal loop
* Not require full materialization

### 3.4 Materialization Is Optional

The executor may collect into Vec for API compatibility,
but traversal must not require Vec.

---

# 4. Core Abstraction

Introduce:

```rust
pub(crate) trait OrderedIterator {
    type Item;

    fn next(&mut self) -> Result<Option<Self::Item>, InternalError>;
}
```

Properties:

* Fallible
* Ordered
* Pull-based
* Stateful

This is intentionally minimal.

---

# 5. Iterator Types

## 5.1 IndexRangeIterator

Primary 0.15 implementation.

Backed by:

```
entry_map.range((start_raw, end_raw))
```

Supports:

* ASC
* DESC
* Continuation anchor
* Limit pushdown

Internal state:

```rust
struct IndexRangeIterator<'a> {
    inner: BTreeRangeIterator<'a>,
    direction: OrderDirection,
    limit_remaining: Option<usize>,
}
```

Responsibilities:

* Rewrite bounds for continuation
* Enforce strict advancement invariant
* Track limit
* Yield DataKey (or DataRow depending on layer)

---

## 5.2 KeyRangeIterator

Wraps:

```
DataStore.range((start_raw, end_raw))
```

Used for primary-key range scans.

---

## 5.3 FullScanIterator

Specialization of KeyRangeIterator with full bounds.

---

# 6. Iterator Layering

Execution pipeline becomes:

```
AccessPlan
→ OrderedKeyIterator
→ RowLoaderIterator
→ PredicateFilterIterator (if needed)
→ ProjectionIterator (future)
→ LimitIterator (if not pushdown)
```

Each stage is a small OrderedIterator wrapper.

Example:

```rust
struct RowLoader<I> {
    inner: I,
    context: Context,
}
```

---

# 7. Continuation Integration

Continuation handling moves into iterator initialization.

Example:

```
IndexRangeIterator::new(
    index,
    prefix,
    lower,
    upper,
    continuation_anchor,
    direction,
    limit,
)
```

Strict rules:

* ASC: rewrite lower bound
* DESC: rewrite upper bound
* Anchor excluded
* Envelope preserved

No executor-level boundary filtering remains.

---

# 8. Limit Pushdown Integration

Iterator accepts:

```
limit: Option<usize>
```

Implementation:

```
if let Some(ref mut remaining) = self.limit_remaining {
    if *remaining == 0 {
        return Ok(None);
    }
    *remaining -= 1;
}
```

This removes outer-loop truncation logic.

---

# 9. DESC Symmetry

For DESC:

* Reverse underlying BTree traversal
* Rewrite opposite bound
* Invert monotonicity invariant

Invariant:

```
ASC: next_key > previous_key
DESC: next_key < previous_key
```

Enforced at iterator level.

---

# 10. AccessPlan Integration

Replace:

```
rows_from_access(...)
```

with:

```
iterator_from_access(...)
```

AccessPlan now produces:

```
Box<dyn OrderedIterator<Item = DataKey>>
```

Composite plans (future) can return merge iterators.

---

# 11. Execution Refactor Scope

This phase will:

* Remove key Vec materialization in index paths
* Remove executor-level early-break loops
* Remove logical continuation boundary filtering
* Centralize traversal invariants

This phase will not:

* Remove final Vec materialization for public APIs
* Introduce async streaming
* Refactor query planning

---

# 12. Invariants

Iterator must guarantee:

1. Stable order
2. No duplicates
3. Envelope adherence
4. Strict advancement across continuation
5. Directional correctness
6. Deterministic exhaustion

---

# 13. Testing Requirements

Add tests:

### A. Iterator-Level Monotonicity

Verify raw-key progression strictly increasing/decreasing.

### B. Limit Enforcement

Verify early exhaustion when limit reached.

### C. Continuation Resume

Verify anchor exclusion works inside iterator.

### D. Parity

Unbounded iteration == concatenated limited iteration.

### E. DESC Parity

Reverse iterator produces reversed unbounded result.

---

# 14. Non-Goals

* Aggregations
* Joins
* Parallel execution
* Query optimizer rewrite
* Public streaming API

---

# 15. Architectural Impact

After 0.15:

* Traversal is unified.
* Continuation is traversal-native.
* Limit pushdown is trivial.
* DESC is symmetrical.
* Composite access trees become feasible.

This sets the stage for:

* Streaming execution (0.16)
* Merge-based union/intersection (0.17)
* Predicate pushdown expansion (0.18)

---

# 16. Migration Strategy

1. Implement IndexRangeIterator first.
2. Refactor executor to use it.
3. Remove logical boundary filtering.
4. Remove outer-loop limit truncation.
5. Replace Vec key flows with iterator wrappers.
6. Preserve public API behavior.

---

# 17. Success Criteria

All must hold:

* No behavior regression
* All 0.12 continuation tests pass unchanged
* All limit pushdown tests pass
* DESC tests pass
* Parity tests pass
* No duplicate key emission
* No missing rows
* Strict advancement invariant enforced

---

# 18. Architectural Principle

> Traversal is the primitive. Materialization is a consumer concern.

This shifts IcyDB from a collection-based executor to a traversal-based executor.
