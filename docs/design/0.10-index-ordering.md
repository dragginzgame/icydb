# Index Key Encoding Release Roadmap (0.10.x)

`0.10.x` is the **Index Keys release**.

The 0.10 series focuses on replacing fixed-slot secondary index key encoding
with canonical variable-length ordered keys.

This release exists to make ordered secondary traversal, range scans, and
ordering semantics mechanically correct at the storage-key layer.

0.10 performs this as an in-place replacement of the current index-key
encoding. There is no `V1`/`V2` dual format, no compatibility mode, and no
backward-compatibility requirement for old index-key bytes.

0.10 is intentionally breaking: we replace `v1` behavior in situ, move fast,
and do not preserve backward compatibility for prior index-key/storage
contracts.

This file is the canonical 0.10 planning + protocol document.
Legacy 0.10 plan files were consolidated here to avoid dual maintenance and
drift.

---

## 0.10 Coherent Arc

`0.10.x` follows one coherent execution arc:

* Canonical ordered secondary indexes
* ORDER BY pushdown
* Range scan correctness
* Index traversal semantics

---

## Ordering Contract (Merged)

The ordering protocol contract for `0.10` is defined in this file. The key
requirements are:

* Semantic ordering equivalence and byte-level lexicographic equivalence
* Stable framed key structure `(kind, index_id, components..., pk)`
* Deterministic planner behavior and cursor continuation semantics
* Canonical prefix/range behavior with strict no-skip/no-duplicate paging
* Frozen float, enum, and component-tag ordering policy
* Explicit migration/rebuild safety and fail-closed corruption handling
* Drift protection via deterministic parity/golden/fuzz-style tests

Protocol freeze note: the `IndexKey v0.10` encoding layout, ordering semantics,
and continuation-token contract are treated as protocol-level behavior.
Post-`0.10.0` changes to these surfaces MUST be accompanied by an explicit
migration plan and matching docs/tests/changelog updates.

For implementation details, see section `# 1. RawIndexKey Variable-Length
Redesign` and section `# 6. Verification and Safety Gates`.

---

## Progress Snapshot (as of 2026-02-16)

Current 0.10 completion tracking lives in `docs/status/0.10-status.md`.
As of this snapshot, the 0.10 index-ordering contract is marked
**100% complete** with only optional post-ship maintenance follow-ups.

---

# 1. RawIndexKey Variable-Length Redesign

IcyDB 0.10 will replace fixed-slot index keys with variable-length canonical
keys.

## Goals

* Replace fixed-slot `RawIndexKey` layout with variable-length storage
* Bake an explicit key-kind discriminator into encoded keys (for example, user vs system/reverse)
* Remove layout dependency on `MAX_INDEX_FIELDS`
* Keep keys bounded with explicit maximum size computation
* Keep primary key as final key component in composite index keys

## Outcomes

* Index keys are no longer constrained by fixed 16-byte field slots
* Key kind is encoded directly in key bytes rather than inferred from index-name namespace
* Storage layout no longer includes slot padding
* Composite key boundaries are unambiguous and deterministic

## Non-Goals

* Compression-focused key packing
* Relaxing bounded-size requirements

## Normative Byte Layout - IndexKey v0.10

### Overview

An `IndexKey` is a lexicographically ordered, stable-memory key with the following properties:

* Total ordering via byte-wise comparison
* Namespace isolation via explicit `key_kind`
* Component boundary safety via explicit length prefixes
* Primary key as terminal tie-break component
* Canonical ordered encoding for each value component
* Fully bounded, no unframed concatenation

Byte comparison of the full encoded key MUST produce the same ordering as tuple-wise semantic
comparison of:

`(key_kind, index_id, component_0, ..., component_n, primary_key)`

### Encoded Form (v0.10)

```text
IndexKey :=
    [ key_kind : u8 ]
    [ index_id : fixed IndexName::STORED_SIZE bytes ]
    [ component_count : u8 ]

    For each index component i in 0..component_count:
        [ component_len_i : u16 BE ]
        [ component_bytes_i : component_len_i bytes ]

    [ pk_len : u16 BE ]
    [ pk_bytes : pk_len bytes ]
```

### Field Semantics

`key_kind` (`u8`)

* `0x00 = User`
* `0x01 = System`
* All other values are invalid and MUST be rejected
* Participates in ordering as the first comparison field

`index_id`

* Fixed-width canonical encoding of `IndexName`
* MUST be stable and versioned independently
* Participates in ordering directly after `key_kind`

`component_count` (`u8`)

* Number of indexed value components
* MUST equal schema-defined index arity
* MUST be `<= MAX_INDEX_FIELDS`
* Decode MUST reject mismatches
* Participates in ordering before components

`component_len_i` (`u16 BE`)

* Big-endian length of component payload
* MUST be `> 0`
* MUST be `<= MAX_COMPONENT_SIZE` (explicit constant)
* Decoder MUST reject overflow or truncated segments
* Length participates lexicographically before component payload bytes

`component_bytes_i`

* Output of:

  * `encode_canonical_index_component(value)`

* Canonical component encoding MUST:

  * Be deterministic
  * Preserve total ordering via lexicographic byte comparison
  * Include value tag + normalized payload
  * Reject unsupported types

* Canonicalization MUST freeze:

  * Decimal normalization
  * BigInt/BigUint sign and width normalization
  * Float ordering policy (including NaN policy)
  * `-0.0` handling

`pk_len` / `pk_bytes` (Primary Key Terminal Component)

* Primary key MUST be appended as the final component
* Purpose:

  * Ensure uniqueness without secondary lookup
  * Provide stable tie-breaking for equal indexed values
  * Preserve deterministic ordering for duplicates

* PK encoding MUST:

  * Be canonical and stable
  * Use the same length-prefixed framing
  * Be lexicographically ordered by identity semantics

### Ordering Guarantee

Byte-wise lexicographic comparison MUST equal semantic comparison of:

```text
(key_kind,
 index_id,
 component_0,
 component_1,
 ...
 component_n,
 primary_key)
```

No secondary comparison logic is permitted.

### Rejection Rules (Mandatory)

Decoder MUST reject:

* Unknown `key_kind`
* `component_count > MAX_INDEX_FIELDS`
* `component_count` mismatch with actual segment count
* Segment length overflow
* Segment exceeding bounded max
* Trailing bytes
* Truncated segments
* Unsupported canonical component types

### Bounded Size

Total key size MUST satisfy:

`<= MAX_INDEX_KEY_BYTES`

Where:

```text
MAX_INDEX_KEY_BYTES =
1 + INDEX_ID_SIZE + 1 +
(MAX_INDEX_FIELDS * (2 + MAX_COMPONENT_SIZE)) +
(2 + MAX_PK_SIZE)
```

This MUST be enforced via `Storable::BOUND`.

### Versioning

This layout is `IndexKey` format version `0.10`.

Future format changes MUST:

* Introduce a new version discriminator
* Not silently reinterpret existing keys
* Not modify canonical encoding semantics in place

### Critical Freezing Decisions

The following decisions MUST be explicitly frozen and documented:

* Float NaN policy (reject or canonicalize to a single encoding)
* Decimal normalization strategy
* Big integer normalization rules (no leading zeros)
* Endianness (must remain big-endian for lexicographic stability)
* Whether `component_len` participates lexicographically (it does)

### Why This Layout Is Correct

* Namespace separation via first byte
* No ambiguous concatenation
* No fixed-width assumptions
* Fully bounded
* Compatible with BTree lexicographic ordering
* Stable against schema evolution (arity fixed per index)
* Safe for range scans and prefix bounds

### Recommendation Before Wiring

Before replacing fingerprint slots:

* Add golden test vectors (hard-coded byte outputs)
* Add explicit float edge-case tests (`-0.0`, `+0.0`, `NaN`)
* Add multi-field ordering tests with different segment lengths
* Add prefix-bound scan tests

---

# 2. Canonical Primitive Encoding for Ordered Keys

IcyDB 0.10 will define and enforce canonical encoding for all indexable
primitive types.

## Goals

* Guarantee `a < b` iff `encode(a) < encode(b)` (lexicographic bytes)
* Guarantee equal values always encode identically
* Enforce per-type canonicalization (for example, normalized decimal encoding)
* Disallow unsupported/non-orderable edge payloads where required

## Outcomes

* Ordered scans over encoded keys reflect logical ordering
* Equality consistency holds between semantic and byte-level comparisons
* Canonical encoding is testable and deterministic across upgrades

## Non-Goals

* Cost-based query optimization
* Cross-type coercion in index key encoding

---

# 3. Schema Constraints and Field Limit Discipline

IcyDB 0.10 keeps schema limits explicit and separate from storage layout.

## Goals

* Keep `MAX_INDEX_FIELDS = 8` enforced at schema-definition time
* Ensure field-count limits are not encoded as storage slot assumptions
* Provide clear schema errors for index definitions exceeding limits

## Outcomes

* Predictable planner and storage bounds
* Clean separation between schema constraints and key byte layout

## Non-Goals

* Increasing composite-index arity beyond current schema limits

---

# 4. In-Place Index Key Replacement (No Compatibility Layer)

IcyDB 0.10 replaces the current fixed-slot index-key encoding in situ.

This scope is limited to secondary-index key representation and deterministic
rebuild behavior from authoritative row data. It does not include row/commit
format versioning or a generic migration engine.

## Goals

* Replace the current fixed-slot index encoding directly with canonical variable-length keys
* Keep a single active encoding format in 0.10 (no `V1`/`V2` schema)
* Rebuild secondary indexes deterministically from row data during upgrade/startup gate
* Define failure behavior explicitly (fail closed with classified errors; no silent partial rebuild)
* Prohibit mixed-key modes and dual-write modes in steady-state execution

## Outcomes

* Post-upgrade index behavior uses one canonical key format only
* Fixed-slot keys are eliminated during rebuild
* Runtime/index code paths do not carry compatibility branches

## Non-Goals

* Row format versioning
* Commit marker wire-format versioning
* Generic row-op migration engine
* Backward-compatibility decode support for old fixed-slot index-key bytes
* Dual-write or mixed-encoding index modes in normal operation
* Best-effort partial conversion with mixed encoding semantics

## Execution Checklist (Step 3)

Current status: **Complete** (100%)

* [x] Remove fixed-slot index-key assumptions from `IndexKey`/`RawIndexKey` encoding and decoding
* [x] Keep one active key encoding path in runtime code (no `V1`/`V2` dual decode branches)
* [x] Enforce fail-closed structural decode at trust boundaries (`IndexKey::try_from_raw`)
* [x] Validate recovery replay determinism for index state through commit/replay tests
* [x] Freeze replay byte-stability with raw key snapshot tests across repeated recovery
* [x] Add explicit startup/upgrade full-rebuild gate for secondary indexes from authoritative row data
* [x] Add fail-closed tests for rebuild-time corruption cases in the full-rebuild gate
* [x] Add explicit operator-facing documentation for when and how full rebuild is triggered

### Operator Notes: Startup Rebuild Gate

When rebuild runs:

* Rebuild is executed inside `ensure_recovered(...)` / `ensure_recovered_for_write(...)`.
* It runs on first recovery pass (startup boundary) and on later passes when recovery is re-entered.
* If no runtime entity hooks are registered, rebuild is skipped (test-only/minimal DB wiring case).

What rebuild does:

* Replays any persisted commit marker first (if present).
* Takes a full snapshot of current index stores.
* Clears index stores.
* Rebuilds index entries from authoritative row data by reusing entity commit-planning hooks.
* Recreates secondary and relation-driven reverse index entries through the same canonical planning path.

Failure behavior (fail closed):

* Any rebuild error aborts recovery and returns a classified error.
* Pre-rebuild index snapshots are restored before returning, so partial rebuild writes are not left behind.
* Reads/writes that require recovery continue to fail until the underlying corruption/configuration issue is fixed.

Validation coverage:

* `recovery_startup_gate_rebuilds_secondary_indexes_from_authoritative_rows`
* `recovery_startup_rebuild_fail_closed_restores_previous_index_state_on_corrupt_row`

---

# 5. Ordered Traversal, Range Scans, and Pagination Parity

IcyDB 0.10 will wire canonical index keys into ordered execution paths without
semantic drift.

## Goals

* Enable ordered secondary traversal based on canonical key bytes
* Enable deterministic range scans over ordered secondary indexes
* Gate ORDER BY pushdown on strict correctness checks:
  field sequence, direction, canonical missing/null ordering, and primary-key tie-break requirements
* Fallback to existing non-pushdown execution when correctness checks fail
* Preserve continuation signature and cursor semantics
* Keep pagination behavior equivalent to existing contract

## Outcomes

* ORDER BY pushdown paths can rely on byte-order correctness
* Pagination outputs remain contract-compatible while execution cost improves

## Non-Goals

* Bidirectional cursor contracts
* Snapshot-consistent pagination across requests

## Execution Checklist (Step 1)

Current status: **Complete** (100%)

* [x] Canonical index keys provide stable lexicographic ordering for prefix and range windows
* [x] Prefix-bound builders are wired for user/system namespace isolation
* [x] Define explicit ORDER BY pushdown eligibility matrix for secondary-index traversal:
  index field sequence, direction, null/missing ordering, and PK tie-break rules
* [x] Implement executor traversal path for eligible secondary-index ORDER BY plans
* [x] Keep strict fallback to existing non-pushdown execution when eligibility fails
* [x] Prove cursor continuation parity between pushdown and fallback paths
* [x] Add deterministic parity tests for ASC/DESC and multi-field ties
* [x] Add deterministic boundary tests for range scans and prefix windows
* [x] Add diagnostics/trace markers showing when pushdown is accepted or rejected
* [x] Add doc examples for expected plan behavior (pushdown hit vs fallback)

### Plan Behavior Examples (Pushdown vs Fallback)

Example A: pushdown hit (secondary index order is eligible)

```rust
let explain = Query::<PushdownParityEntity>::new(ReadConsistency::MissingOk)
    .filter(FieldRef::new("group").eq(7u32))
    .order_by("rank")
    .explain()?;

assert!(matches!(
    explain.order_pushdown,
    ExplainOrderPushdown::EligibleSecondaryIndex { .. }
));
```

Why this hits:

* Access path is `IndexPrefix(group = 7)` over index `(group, rank)`
* Remaining ORDER fields match the index suffix (`rank`)
* PK tie-break is present and ascending

Example B: fallback (descending order forces rejection)

```rust
let explain = Query::<PushdownParityEntity>::new(ReadConsistency::MissingOk)
    .filter(FieldRef::new("group").eq(7u32))
    .order_by_desc("rank")
    .explain()?;

assert!(matches!(
    explain.order_pushdown,
    ExplainOrderPushdown::Matrix(SecondaryOrderPushdownRejection::NonAscendingDirection { .. })
));
```

Why this falls back:

* Descending component order is currently not eligible for secondary index pushdown
* Executor keeps canonical fallback semantics (post-access ordering + pagination)

### Next Implementation Slice

* [x] Add the ORDER BY pushdown eligibility matrix and explicit rejection reasons for explain + executor usage
* [x] Keep planning validation semantic-only (no pushdown diagnostics side channel in `0.10`)
* [x] Add parity tests that compare pushdown-eligible output against current fallback output for the same query shape

> TODO (0.12+): consider a real planner diagnostics channel if pushdown
> rejection reasons need to be emitted at validation time.

---

# 6. Verification and Safety Gates

IcyDB 0.10 requires heavy property and boundary testing for canonical index
encoding.

## Goals

* Property tests for per-primitive logical order vs byte order equivalence
* Composite tuple ordering parity tests
* Golden-vector encode tests per primitive to detect byte-format drift
* Decimal normalization and float edge-case tests
* In-place rebuild correctness tests from fixed-slot input state to canonical keys
* Regression tests proving no continuation/pagination semantic drift

## Outcomes

* Canonical encoding behavior is proven, not assumed
* Upgrade and replay safety are validated in tests

## Non-Goals

* Replacing runtime invariants with test-only guarantees

## Execution Checklist (Step 2)

* [x] Add deterministic primitive-family order parity tests for canonical component encoding
* [x] Add composite tuple semantic-vs-byte ordering tests over fixed cartesian fixtures
* [x] Freeze canonical component bytes with deterministic golden vectors
* [x] Lock decimal normalization and float edge behavior (`NaN`, `-0.0`, `+0.0`)
* [x] Verify recovery replay preserves canonical raw index key bytes across reloads
* [x] Add continuation and pagination parity tests to prevent semantic drift

---

## Invariants Introduced in 0.10

The following become explicit structural guarantees:

* Secondary index keys are canonical and variable-length
* Key-type discrimination is an explicit encoded key component, not a naming convention
* Lexicographic key order matches logical order for supported primitives
* Secondary index key encoding is replaced in situ with no compatibility mode
* Pagination/continuation semantics are preserved through the encoding shift

---

## Explicit Non-Goals (0.10.x)

The following remain out of scope:

* Row format versioning and backward-compatible row decode rules (0.11)
* Commit marker format versioning and replay-compatibility work (0.11)
* Generic migration engine for persisted row transformations (0.11)
* Any `V1`/`V2` index-key version negotiation or backward-compatibility layer
* Cost-based planning
* Multi-index merge/intersection planning
* Index compression pipelines
* Distributed/cross-canister transaction semantics

---

## Summary

0.10.x is the **Index Keys release**.

If 0.9 strengthens correctness boundaries,
0.10 makes ordered secondary indexing canonical and single-format by replacing
the old encoding in place.

The release arc is explicit:

* Canonical ordered secondary indexes
* ORDER BY pushdown
* Range scan correctness
* Index traversal semantics
