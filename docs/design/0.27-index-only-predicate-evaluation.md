# 0.27 - Index-Only Predicate Evaluation

## Purpose

Enable load execution to evaluate eligible predicates directly from index keys for index-backed access paths.

When an index key fully covers the predicate fields:

- evaluate predicate from `RawIndexKey`
- skip row deserialize for rejected keys
- only read rows that survive and are needed for output

This is a performance feature. User-visible query semantics must remain unchanged.

---

## Prerequisite Status

Status against the required steps:

| Prerequisite | Status | Notes |
|---|---|---|
| Runtime predicate evaluation is slot-based | Done | `PredicateFieldSlots` compiles field names to slots and runtime uses `get_value_by_index`. |
| Predicate compilation is wired into executable planning | Done | `ExecutablePlan` carries compiled predicate slots into load execution. |
| `RawIndexKey` decode exists | Done | `IndexKey::try_from_raw` exposes index components and primary key bytes. |
| `PredicateFieldSlots` exposes required slot set | Done | `required_slots()` provides deterministic slot coverage input. |
| Predicate-vs-index coverage check | Done | Route helpers resolve index field slots and enforce full coverage gating. |
| Predicate eval from raw index components | Done | `IndexPredicateProgram` evaluates supported compare subset on decoded index components. |
| Load route integration for index-only predicate filtering | Done | Load execution compiles/passes index predicate programs for eligible index-backed paths. |

Conclusion: `0.27.0` implementation path is in place; remaining hardening and parity matrix work is deferred to `0.27.1`.

---

## Motivation

`0.26.x` removed runtime string field lookup and moved predicate evaluation to slot-based row reads.

Current limitation:

- load execution still materializes/deserializes rows before predicate filtering
- for index paths, this performs avoidable row reads when predicates can be decided from indexed fields alone

`0.27` addresses that gap.

---

## Goals

1. Expose predicate-required field slots from `PredicateFieldSlots`.
2. Determine whether a selected index fully covers predicate fields.
3. Compile an index-component predicate program for eligible shapes.
4. Evaluate that program from `RawIndexKey` during index traversal.
5. Read rows only for keys that survive index-only filtering.
6. Preserve existing predicate semantics via explicit fallback on non-eligible shapes.

---

## Non-Goals

- no change to predicate language
- no change to result ordering/distinct/cursor semantics
- no change to error-class taxonomy for user-facing query validation
- no planner cost-model redesign
- no mandatory index-only behavior for all predicates

---

## Current Model (`0.26.x`)

```text
access path -> ordered keys -> row reads -> deserialize -> slot-based predicate filter
```

Even on index paths, predicate filtering happens after row materialization.

---

## Target Model (`0.27`)

Eligible index path:

```text
access path (index-backed)
  -> raw index key scan
  -> index-only predicate eval
  -> surviving keys only
  -> row reads/deserialization for survivors
  -> remaining post-access phases
```

Fallback path remains unchanged.

---

## Core Design

### 1. Extend `PredicateFieldSlots` with required-slot exposure

Add a deterministic API:

```rust
impl PredicateFieldSlots {
    pub(crate) fn required_slots(&self) -> &[usize];
}
```

Contract:

- unique slots
- stable sorted order
- includes every field referenced by the predicate AST

This supports cheap coverage checks and route decisions.

### 2. Build index coverage gate

For a candidate index path:

1. resolve index field names to entity slot indices
2. compare predicate-required slots to index slots
3. mark index-only eligibility only when predicate-required slots are fully covered

Coverage is all-or-nothing for `0.27`.

### 3. Compile index predicate program

Introduce an internal compiled form for index-evaluable predicates.

Example shape:

```rust
enum IndexPredicateProgram {
    True,
    And(Vec<Self>),
    Or(Vec<Self>),
    Not(Box<Self>),
    Compare(IndexCompareNode),
}
```

`IndexCompareNode` stores:

- index component position (not entity slot)
- operator
- pre-encoded literal bytes (or encoded literal set for `IN`)
- coercion id

Compilation must fail closed (non-eligible) when any node is not index-evaluable.

### 4. Evaluate predicate from `RawIndexKey`

At index scan time:

1. decode `RawIndexKey` with `IndexKey::try_from_raw`
2. access `components[position]`
3. evaluate compiled nodes against component bytes

`0.27` initial support is strict and conservative:

- eligible: `Eq`, `Ne`, `Lt`, `Lte`, `Gt`, `Gte`, `In`, `NotIn` with index-encodable literals and strict coercion
- ineligible (fallback): `Contains`, `StartsWith`, `EndsWith`, `TextContains`, `TextContainsCi`, `IsNull`, `IsMissing`, `IsEmpty`, `IsNotEmpty`, non-strict coercion

This keeps semantics safe while delivering major row-read reduction on common index-filter shapes.

### 5. Integrate into load fast-path routing

Add route capability and decision branch:

- detect index-backed access path + compiled predicate + full coverage
- enable index-only predicate filtering in index traversal helpers
- keep existing fast-path precedence stable

Routing remains canonical-owner for execution-shape decisions.

### 6. Row-read minimization contract

When index-only filtering is enabled:

- rejected keys must not trigger row reads
- accepted keys follow existing row read + deserialize + post-access pipeline

Post-access predicate phase behavior:

- either skip (when fully satisfied by index-only program)
- or keep as defensive recheck behind an invariant gate for phased rollout

`0.27` default: keep defensive recheck behind a debug/assert gate until parity is proven.

---

## Eligibility Contract

Index-only predicate filtering is enabled only when all are true:

1. load query mode
2. access path is index-backed traversal using raw index keys
3. compiled predicate slots exist
4. predicate required slots are fully covered by active index fields
5. predicate nodes are in index-evaluable operator/coercion subset
6. DISTINCT/cursor/order semantics remain unchanged by early key rejection

Any violation routes to existing row-based predicate evaluation.

---

## Error and Fallback Semantics

- User-facing predicate validation errors remain unchanged.
- Index-only compilation/evaluation failures are internal execution concerns.
- Corrupted index keys during raw decode remain `Corruption` from index decode boundaries.
- Non-evaluable predicate nodes are not errors; they are explicit ineligibility and fallback.

---

## Implementation Plan

1. Add `required_slots()` to `PredicateFieldSlots` with tests for uniqueness/stability.
2. Add helper to resolve `IndexModel.fields` to entity slot indices.
3. Add coverage gate (`predicate slots` subset of `index slots`).
4. Add `IndexPredicateProgram` compile step from resolved predicate.
5. Add raw-key evaluator and index-traversal hook in index store lookup path.
6. Add load route capability + execution wiring.
7. Add parity tests vs current row-based predicate evaluation (`0.27.1` hardening).
8. Expand hardening/observability matrix and keep index-only enabled by default with those invariants locked (`0.27.1`).

---

## Testing Requirements

Add focused tests:

1. Slot exposure
- `required_slots()` includes all predicate-referenced fields exactly once.

2. Coverage gating
- full-coverage predicates enable index-only candidate.
- partial/missing coverage falls back.

3. Operator/coercion matrix
- eligible subset executes index-only.
- ineligible subset falls back with parity.

4. Semantic parity
- index-only eligible queries match baseline results for ASC/DESC, pagination, DISTINCT, and cursor continuation.

5. Row-read reduction invariant
- rejected index keys do not trigger row deserialize/read in eligible path.

6. Corruption handling
- malformed `RawIndexKey` still classifies as index corruption.

---

## 0.27 Release Split

`0.27.0` ships the core index-only predicate execution path.
`0.27.1` carries the hardening matrix from this design (parity, operator/coercion matrix, continuation/`DISTINCT` interaction, and explicit observability coverage).

---

## Risks

- Incorrect index-slot mapping can cause false accepts/rejects.
- Predicate subset drift could silently widen unsupported operations.
- Over-aggressive route gating could break continuation or DISTINCT invariants.

Mitigations:

- explicit eligibility matrix tests
- parity tests against canonical row-based execution
- invariant assertions at route and index-scan boundaries

---

## 0.27.0 Release Decisions

1. `0.27` scope is load-mode only.
2. Initial operator/coercion eligibility subset is strict and conservative.
3. Post-access predicate recheck remains allowed as a defensive parity guard.
4. Observability additions for index-only activation are deferred to `0.27.1`.

---

## Post-`0.27` Follow-Ups

Potential `0.27.x+` expansions:

- extend index-only eligibility to additional predicate forms where semantics are exact
- consider typed component decode support for broader coercion families
- evaluate delete-path adoption once load parity and invariants are fully hardened
