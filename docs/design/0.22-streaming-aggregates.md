# 0.22 ‚Äî Streaming Aggregates (COUNT / MIN / MAX / EXISTS)

## 1Ô∏è‚É£ Purpose

Add aggregate terminals that run on the ordered key stream without materializing full entities.

Target outcomes:

* lower read cost for aggregate queries
* stable semantics that match existing load-query behavior
* minimal architectural change (no planner redesign, no new dispatch model)

---

## 2Ô∏è‚É£ Problem Today

Current `SessionLoadQuery::count()` is implemented as:

```rust
self.execute()?.count()
```

That means aggregate-style reads still:

* build full response rows
* decode and materialize entities
* pay the same memory cost as normal row reads

There is no dedicated terminal for `EXISTS`, `MIN`, or `MAX`.

---

## 3Ô∏è‚É£ Scope

### In Scope (0.22)

* Streaming aggregate execution for:
  * `COUNT`
  * `EXISTS`
  * `MIN`
  * `MAX`
* Reuse existing load planning and access-path routing.
* Keep fast-path/fallback behavior unchanged.
* Keep error classes and origin mapping unchanged.

### Out of Scope (0.22)

* `SUM`, `AVG`, `COUNT DISTINCT`, `GROUP BY`
* projection/value-level aggregates (for example `MIN(price)`)
* cursor-paged aggregate API
* planner cost model changes

---

## 4Ô∏è‚É£ Aggregate Semantics

Aggregates are evaluated over the same logical key stream as `execute()`.

That means they inherit:

* predicate filtering
* access-path selection
* DISTINCT (if set)
* page window (`offset` / `limit`)

Definitions:

* `COUNT`: number of keys emitted by the final key stream (saturating `u32`)
* `EXISTS`: `true` if at least one key is emitted
* `MIN`: smallest matching `Id<E>` in the emitted stream
* `MAX`: largest matching `Id<E>` in the emitted stream

`MIN`/`MAX` in 0.22 are **primary-key aggregates** (`Id<E>`), not field-value aggregates.

---

## 5Ô∏è‚É£ Public API Shape

```rust
impl<'a, C, E> SessionLoadQuery<'a, C, E>
where
    E: EntityKind + EntityValue,
{
    pub fn count(&self) -> Result<u32, QueryError>;
    pub fn exists(&self) -> Result<bool, QueryError>;
    pub fn min(&self) -> Result<Option<Id<E>>, QueryError>;
    pub fn max(&self) -> Result<Option<Id<E>>, QueryError>;
}
```

Notes:

* `count()` keeps its current signature.
* `is_empty()` can become `Ok(!self.exists()?)` (semantic alias).
* `require_some()` can consume `exists()` instead of full materialization.

---

## 6Ô∏è‚É£ Execution Design

No new query mode is introduced.

We keep:

* `QueryMode::Load`
* existing planner output (`LogicalPlan`)
* existing load executor routing

Add a small aggregate terminal in load executor:

```rust
// executor-private
enum AggregateKind {
    Count,
    Exists,
    Min,
    Max,
}
```

```rust
fn fold_keys<E: EntityKind>(
    stream: OrderedKeyStreamBox,
    kind: AggregateKind,
) -> Result<ExecutorAggregateResult<E>, InternalError>;
```

Execution flow:

1. Build and validate load plan exactly as today.
2. Resolve ordered key stream using existing fast-path/fallback routing.
3. Apply DISTINCT wrapper if plan requests it.
4. Fold keys into executor-private aggregate results without row materialization.

This is a consolidation, not a new architecture.

API methods (`count`, `exists`, `min`, `max`) return their concrete public return types directly.
No aggregate result enum is exposed outside executor internals.

### Critical Invariant

Aggregate execution must reuse the exact same key-stream resolution pipeline as normal load execution, up to (but not including) row decoding/materialization.

That shared pipeline must include, in the same order:

1. cursor/continuation boundary narrowing
2. fast-path vs fallback routing
3. DISTINCT wrapping (when requested)
4. page window application (`offset` / `limit`)

No duplicated aggregate-only resolver is allowed.

---

## 7Ô∏è‚É£ Folding Rules (Streaming)

`COUNT`:

* iterate stream
* `count = count.saturating_add(1)`

`EXISTS`:

* pull one item from stream
* return `true` on first key, else `false`

`MIN`:

* if direction is `ASC`: return first emitted key (short-circuit)
* if direction is `DESC`: scan stream and keep last emitted key

`MAX`:

* if direction is `DESC`: return first emitted key (short-circuit)
* if direction is `ASC`: scan stream and keep last emitted key

All four stay O(1) memory.

This relies on the existing ordering invariant: emitted keys are monotonic in plan direction.

---

## 8Ô∏è‚É£ Error and Invariant Rules

No new error taxonomy.

Rules:

* planning/validation errors remain `QueryError::Plan` / `QueryError::Intent`
* executor/storage failures remain `QueryError::Execute`
* corruption/internal classification remains unchanged

Aggregate terminals must use the same trusted decoding boundaries already used by load execution.

---

## 9Ô∏è‚É£ Test Plan

Minimum required parity checks:

1. `count()` equals `execute()?.count()` across access-path shapes.
2. `exists()` equals `!execute()?.is_empty()`.
3. `min()` equals min of materialized `ids()`.
4. `max()` equals max of materialized `ids()`.
5. Coverage with:
   * DISTINCT on/off
   * ASC/DESC ordering
   * offset-only, limit-only, offset+limit windows
   * PK, secondary, index-range, union, intersection
   * first-item short-circuit for `MIN(ASC)` and `MAX(DESC)`
6. Empty-result behavior:
   * `count = 0`
   * `exists = false`
   * `min = None`
   * `max = None`

---

## üîü Rollout Plan

Phase 1:

* add aggregate executor primitives (`AggregateKind`, streaming fold)
* route `count()` through aggregate execution

Phase 2:

* add `exists()`, `min()`, `max()` session terminals
* update `is_empty()` / `require_some()` internals to reuse aggregate path

Phase 3:

* add parity matrix tests and edge-case tests
* update changelog/release notes

---

## 1Ô∏è‚É£1Ô∏è‚É£ Risks

Main risk:

* subtle mismatch between aggregate stream path and materialized path.

Mitigation:

* use one shared key-stream resolution path for both aggregate and full-load execution
* enforce parity tests per access-path family and direction

---

## 1Ô∏è‚É£2Ô∏è‚É£ Complexity Impact

Expected effect:

* reduces duplicated ‚Äúmaterialize then aggregate‚Äù work
* keeps planner shape stable
* adds one small execution terminal instead of another mode axis

This is a moderate feature with low structural risk if implemented as a shared-key-stream fold.
