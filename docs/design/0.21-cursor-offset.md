# 0.21 ‚Äî Cursor Paging With Full Offset Semantics

## 1Ô∏è‚É£ Purpose

Add full `offset` support to cursor paging so teams can use:

```rust
session
    .load::<Entity>()
    .order_by("id")
    .limit(50)
    .offset(500)
    .page()?;
```

and continue safely with cursor tokens without re-applying the same offset on later pages.

---

## 2Ô∏è‚É£ Problem Today

Current behavior:

* Offset works for non-cursor load execution.
* Cursor mode explicitly rejects offset at the query policy boundary.

Why rejection exists:

* Cursor continuation currently applies boundary narrowing first, then applies plan pagination.
* If offset were allowed naively, offset would be applied again on every continuation request.
* That causes row omissions and unstable page windows.

---

## 3Ô∏è‚É£ Goals

### In Scope

* Allow `offset` in cursor paging (`.page()` and `.cursor(...)` flow).
* Apply offset exactly once across a cursor chain.
* Preserve existing continuation guarantees:
  * strict boundary exclusion
  * no duplicates
  * no omissions (for stable underlying data)
* Keep limit mutability behavior (limit may vary across continuation requests).
* Keep storage and row encoding unchanged.

### Out of Scope

* Snapshot isolation across pages.
* Cursor portability across schema/index changes.
* Planner redesign or cost-based routing changes.

---

## 4Ô∏è‚É£ Semantics

Given canonical ordered stream `S`, window `(offset = O, limit = L)`:

* First request (no cursor token):
  * skip first `O` rows
  * return next `L` rows
* Continuation request (cursor token present):
  * resume strictly after boundary row
  * apply effective offset `0`
  * return next `L` rows

Offset is therefore a **first-window displacement**, not a per-page displacement.

---

## 5Ô∏è‚É£ Cursor Token Design

## 5.1 New Version

Introduce `ContinuationToken` version `v2` with explicit page-window offset state.

Add window payload:

```rust
struct CursorWindowState {
    initial_offset: u32,
}
```

Rules:

* `initial_offset` is always the query offset from the first request.
* Presence of a continuation token implies offset has already been consumed.

## 5.2 Compatibility

* Decode `v1` tokens for backward compatibility.
* Treat `v1` token as `{ initial_offset: 0 }`.
* Reject using a `v1` token with a query whose offset is non-zero.

---

## 6Ô∏è‚É£ Validation Rules

Existing validations remain:

* signature match
* direction match
* boundary arity/type checks
* index-range anchor checks

Add:

* cursor window offset compatibility:
  * token `initial_offset` must equal plan page offset
  * else fail with a typed cursor-plan error (`ContinuationCursorWindowMismatch`)

This prevents cross-query token reuse where offset differs.

---

## 7Ô∏è‚É£ Executor Runtime Changes

Introduce runtime effective offset:

* `effective_offset = page.offset` when no cursor is applied
* `effective_offset = 0` when a continuation cursor is applied

Use `effective_offset` consistently for:

* post-access pagination
* cursor next-page decision (`rows_after_cursor` vs page window)
* fast-path fetch budgets (`offset + limit + 1` becomes `effective_offset + limit + 1`)
* fallback scan budgets (same rule)

---

## 8Ô∏è‚É£ API / Policy Changes

Update policy:

* remove cursor-mode rejection of offset (`CursorWithOffsetUnsupported`)

Update session docs:

* cursor paging no longer forbids offset
* clarify offset-once semantics

---

## 9Ô∏è‚É£ Expected Behavior Examples

Given IDs `[1,2,3,4,5,6,7,8]`, `offset=3`, `limit=2`:

* page 1: `[4,5]`, cursor at `5`
* page 2: `[6,7]`, cursor at `7`
* page 3: `[8]`, no next cursor

Changing limit between pages remains valid:

* page 1 `limit=2`, page 2 `limit=3` is allowed
* offset is still not re-applied on page 2+

Changing offset between pages is invalid:

* token from offset `3`, request with offset `0` (or `5`) fails validation

---

## üîü Test Plan

Minimum required matrix:

1. Cursor paging accepts offset at builder boundary.
2. Offset is applied exactly once across continuation chain.
3. Limit changes across pages still work with offset.
4. Offset mismatch across continuation requests is rejected.
5. `v1` token:
   * accepted when query offset is `0`
   * rejected when query offset is non-zero.
6. ASC and DESC coverage for:
   * PK fast path
   * secondary pushdown path
   * index-range path
   * fallback/composite path
7. DISTINCT + cursor + offset parity checks (no duplicates, stable boundaries).

---

## 1Ô∏è‚É£1Ô∏è‚É£ Rollout Plan

Phase 1:

* add token `v2` window payload + decode compatibility path
* add validation error for offset mismatch

Phase 2:

* wire effective offset through load execution (fast + fallback)
* remove policy rejection

Phase 3:

* add matrix tests
* update status/changelog/docs

---

## 1Ô∏è‚É£2Ô∏è‚É£ Risks

Main risk:

* missing one runtime callsite that still uses plan offset instead of effective offset.

Mitigation:

* centralize effective window derivation in one helper and use it in page/budget code paths.
* enforce via targeted parity matrices (fast vs fallback, ASC vs DESC, distinct on/off).

---

## 1Ô∏è‚É£3Ô∏è‚É£ Complexity Impact

This is a moderate-to-large change because it cuts across:

* cursor token protocol
* cursor validation
* runtime pagination windowing
* scan budget derivation
* API policy surface

But it is still a consolidation change, not a storage/planner redesign.
