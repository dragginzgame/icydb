
# `docs/design/0.11-range-pushdown.md`

# 0.11 â€“ Secondary Range Predicate Pushdown

## Overview

0.11 introduces **true secondary index range pushdown** enabled by the canonical ordered IndexKey (v2) implemented in 0.10.

Prior to 0.11:

* Secondary indexes supported equality prefix planning.
* Range-like predicates were evaluated post-access.
* Index traversal could not be bounded by non-equality comparisons.

With 0.11:

* `>`, `>=`, `<`, `<=`, and `BETWEEN` predicates may be converted into **bounded lexicographic B-tree traversals**.
* Range scans occur directly in index space.
* Sorting and pagination may be satisfied without post-access filtering.

This is the first feature release that fully exploits canonical ordered index keys.

---

## Goals

1. Enable bounded traversal of secondary indexes.
2. Avoid full-scan + post-filter for monotonic range predicates.
3. Preserve deterministic ordering and pagination semantics.
4. Maintain existing planner contract and invariant surfaces.
5. Do not introduce cost-based heuristics or multi-index strategies.

---

## Scope

### Supported Predicates

For a given indexed field `f`:

* `f > value`
* `f >= value`
* `f < value`
* `f <= value`
* `f BETWEEN low AND high`

### Composite Index Support

Given an index:

```
INDEX (a, b, c)
```

Valid range pushdown shapes:

```
WHERE a = X AND b >= Y
WHERE a = X AND b BETWEEN Y AND Z
```

Rules:

* Range operator may appear only on the **first non-equality component**.
* All preceding components must be equality-constrained.
* Only one range component per index.
* Subsequent components must not appear in the predicate.

Invalid shapes fall back to non-pushdown execution.

---

## Non-Goals

0.11 does not include:

* Cost-based index selection.
* Multi-index intersection.
* Bitmap or partial index support.
* Arbitrary OR-range rewriting.
* Multi-range (disjoint interval) pushdown.

---

## Planner Changes

### Access Path Extension

Planner may emit:

```
AccessPath::KeyRange { start, end }
```

for secondary index traversal.

Previously, `KeyRange` was primarily used for primary key access.
0.11 extends it to secondary index space.

### Eligibility Matrix Extension

Pushdown eligibility must now validate:

* Index exists for candidate fields.
* Prefix-equality rule holds.
* Range component ordering matches index ordering.
* Bound values are canonically encodable.
* Primary key tie-break remains implicit terminal component.

Range planning must not duplicate logic already validated by:

* Canonical encoding rules (0.10)
* Prefix ordering invariants (0.10)
* ORDER BY pushdown eligibility matrix

---

## Bound Construction

For index:

```
(kind, index_id, component_0, ..., component_n, pk)
```

Lower/upper bounds are constructed as:

```
(start_prefix..., range_lower, MIN_PK)
(end_prefix..., range_upper, MAX_PK)
```

Where:

* `MIN_PK` and `MAX_PK` ensure inclusive/exclusive correctness.
* Bound inclusivity depends on operator (`>`, `>=`, `<`, `<=`).

Canonical encoding guarantees lexicographic traversal correctness.

---

## Execution Semantics

Executor must:

1. Traverse index from `start` to `end`.
2. Stop once key exceeds upper bound.
3. Preserve canonical ordering.
4. Respect pagination and continuation invariants.

Post-access filtering for the range field must be unnecessary if planner eligibility is correct.

Fallback path must remain identical to pre-0.11 semantics.

---

## Pagination & Cursor Behavior

Range pushdown must preserve:

* Strict monotonic ordering.
* No-duplicate/no-skip pagination.
* Stable continuation signature validation.
* Deterministic boundary resume.

Continuation tokens remain unchanged in 0.11.

---

## Correctness Invariants

1. Byte-order == semantic-order for range component.
2. Prefix bounds do not bleed into adjacent index segments.
3. Composite ordering obeys left-to-right precedence.
4. Primary key tie-break ensures deterministic traversal.
5. Range-exclusive operators do not include boundary key.

---

## Required Test Matrix

### 1. Single-Field Range

* `>`, `>=`, `<`, `<=`
* Boundary exactly equal to stored value
* No matching rows
* All rows matching

### 2. Composite Prefix + Range

* Equality prefix + range on next component
* Ensure no bleed into different prefix values

### 3. BETWEEN

* Inclusive low/high
* Mixed inclusive/exclusive shapes

### 4. Pagination Under Range

* Page boundary exactly at lower bound
* Page boundary exactly at upper bound
* Resume mid-range
* Resume at terminal boundary

### 5. Parity Tests

For each supported predicate shape:

* Compare pushdown execution vs fallback execution.
* Assert identical row sets and order.

### 6. Edge Values

* Min/max scalar values
* Float edge cases
* Enum ordering edges
* Composite with null-rejection rules (if applicable)

---

## Backward Compatibility

0.11 does not change:

* Index encoding.
* Cursor structure.
* Continuation signature format.
* Planner contract for equality-only predicates.

All new behavior is additive.

---

## Migration & Storage Impact

None.

0.11 uses existing 0.10 canonical key encoding and traversal semantics.

No data rebuild required.

---

## Performance Impact

Expected improvements:

* O(log N + K) instead of O(N) for range queries.
* Reduced memory allocation from avoiding post-filter sort.
* Improved pagination efficiency.

Worst case remains fallback path.

---

## Risk Assessment

Primary risks:

* Incorrect bound construction (off-by-one errors).
* Inclusive/exclusive boundary mistakes.
* Composite prefix miscalculation.
* Cursor resume regression.

Mitigation:

* Exhaustive parity tests.
* Explicit inclusive/exclusive boundary tests.
* Table-driven pushdown eligibility tests.

---

## Architectural Position

0.10 established:

* Canonical ordered index keys.
* Stable lexicographic semantics.

0.11 leverages that foundation to enable:

> True secondary range traversal in index space.

This is the first feature that fully depends on canonical ordering correctness.

---

## Completion Criteria

0.11 is complete when:

* Range pushdown eligibility matrix is implemented.
* All parity tests pass.
* Fallback equivalence confirmed.
* Pagination invariants preserved.
* No new dead code or drift introduced.

