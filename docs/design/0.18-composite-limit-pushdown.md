# 0.18 Design: Composite LIMIT Pushdown

## Overview

Version 0.18 introduces **LIMIT-aware early termination** for composite execution (`Union`, `Intersection`) in the streaming executor.

This change exploits the fully stream-native composite algebra completed in 0.17.

Goal:

> Reduce unnecessary key production in composite execution while preserving deterministic ordering, continuation correctness, and existing error semantics.

No changes to:

* Public API
* Cursor token format
* Storage format
* Index encoding
* Planner structure (minimal adjustments only)

---

# 1. Problem Statement

Currently:

* `LIMIT` is enforced above composite stream execution.
* Composite operators (`MergeOrderedKeyStream`, `IntersectOrderedKeyStream`) are unaware of downstream limits.
* Children streams may continue producing keys even after the parent query has satisfied its limit.

This results in:

* Unnecessary index scans
* Unnecessary stream comparisons
* Unnecessary continuation work
* Wasted IO for high-fanout unions

Now that composite execution is streaming and pull-based, we can introduce **bounded production semantics**.

---

# 2. Design Goals

### G1 — Preserve Semantics

* Identical result ordering (ASC/DESC)
* Identical duplicate suppression behavior
* Identical continuation token behavior
* Identical error classification

### G2 — Strictly Additive Optimization

* No planner redesign required
* No new public API
* No new token fields
* No behavioral change visible to user

### G3 — Deterministic Early Termination

Once `LIMIT N` results have been emitted:

* No further keys should be pulled from child streams.
* No additional index reads should occur.
* Composite streams must become quiescent.

---

# 3. High-Level Approach

Introduce **bounded stream execution** via an internal limit-aware wrapper.

Instead of modifying every composite operator deeply, introduce:

```rust
pub(crate) struct LimitedOrderedKeyStream<S> {
    inner: S,
    remaining: usize,
}
```

This wrapper:

* Delegates to inner stream
* Decrements `remaining` on each emission
* Returns `None` once `remaining == 0`
* Never pulls from inner once exhausted

This guarantees upstream streams are not polled after limit satisfaction.

---

# 4. Execution Model Before vs After

## Current (0.17)

```
AccessPlan
    ↓
Composite stream (merge/intersect)
    ↓
Load layer
    ↓
LIMIT enforcement
```

Composite streams may over-produce.

---

## Proposed (0.18)

```
AccessPlan
    ↓
Composite stream (merge/intersect)
    ↓
LimitedOrderedKeyStream
    ↓
Load layer
```

The limit wrapper becomes the consumption boundary.

---

# 5. Detailed Design

## 5.1 LimitedOrderedKeyStream

```rust
pub(crate) struct LimitedOrderedKeyStream<S> {
    inner: S,
    remaining: usize,
}
```

### Behavior

* If `remaining == 0` → return `Ok(None)`
* Otherwise:

  * call `inner.next_key()`
  * if `Some(key)`:

    * decrement remaining
    * return key
  * if `None`:

    * return `None`

Critically:

> Once remaining hits zero, `inner.next_key()` must never be called again.

This ensures early termination.

---

## 5.2 Integration Point

LIMIT is currently enforced in executor load logic.

Replace:

```rust
while let Some(key) = stream.next_key()? {
    ...
    if collected == limit {
        break;
    }
}
```

With:

```rust
let mut stream = LimitedOrderedKeyStream::new(stream, limit);
while let Some(key) = stream.next_key()? {
    ...
}
```

This moves limit awareness down to stream boundary.

---

# 6. Composite Behavior

## 6.1 Union

Early termination is straightforward:

* Once N keys emitted → stop.
* Child streams are no longer polled.
* No further comparisons occur.

Benefit:

Large unions short-circuit early.

---

## 6.2 Intersection

Intersection also benefits:

* Once N matches found → stop.
* Remaining scan cost avoided.
* Particularly effective when overlap is small.

---

# 7. Continuation Semantics

Critical constraint:

Continuation tokens must remain unchanged.

Behavior:

* Continuation anchor is still derived from last emitted key.
* Limited stream does not alter key sequence.
* No reordering introduced.
* Pagination behavior identical.

No cursor format changes required.

---

# 8. Error Propagation

No changes:

* Underlying stream errors propagate normally.
* If error occurs before limit reached → same behavior as 0.17.
* If limit reached → no further inner polling → no late errors.

This slightly reduces potential error exposure, but only for keys that would not have been visible due to limit.

This is acceptable and consistent with SQL semantics.

---

# 9. Edge Cases

### 9.1 LIMIT 0

Immediately wrap stream with remaining=0.

First call to next_key returns None.

No child stream polling occurs.

---

### 9.2 Nested Composites

Works transparently.

Reduction tree unchanged.

Limited wrapper is outermost.

---

### 9.3 DESC + Continuation

No changes required.

Wrapper is ordering-agnostic.

---

# 10. Performance Characteristics

Before:

Worst-case work = full composite scan.

After:

Worst-case work = min(full scan, limit-satisfied early)

Memory unchanged.

CPU reduced for high fan-out union queries.

---

# 11. Testing Requirements

Add tests covering:

* Union + small LIMIT
* Intersection + small LIMIT
* Nested composite + LIMIT
* DESC + LIMIT
* LIMIT 0
* LIMIT 1 edge case
* Continuation across limited pages

Regression suite must pass unchanged.

---

# 12. Out of Scope

Not included in 0.18:

* Branch reordering heuristics
* Cardinality estimation
* LIMIT pushdown into individual index scans
* Cost-based pruning

Those belong to 0.19+.

---

# 13. Risks

Low.

Primary risks:

* Incorrect integration point (double-enforcing limit)
* Accidentally altering continuation boundary
* Polling inner stream after limit

All are easily testable.

---

# 14. Milestone Completion Criteria

* [ ] LimitedOrderedKeyStream implemented
* [ ] Integrated into load path
* [ ] No duplicate limit enforcement
* [ ] No regression in pagination semantics
* [ ] All existing tests pass
* [ ] New limit regression tests pass

---

# 15. Expected Outcome

After 0.18:

* Composite execution is fully stream-native
* LIMIT-aware
* Early-terminating
* Memory stable
* Cursor-compatible

This completes the “execution-layer streaming optimization” phase.

Future work (0.19+) can safely focus on planner intelligence.
