Yes — this is a very strong 0.23 candidate.

But it must be scoped precisely.

You are not “rewriting decimal”.
You are **consolidating numeric semantics at the storage boundary**.

If you scope it correctly, this becomes:

> 0.23 — Numeric Consolidation & Internal Decimal Engine

Clean. Architectural. Contained.

---

# 0.23 Goal

Replace:

* `E8s`
* `E18s`
* `FixedDecimal`
* `rust_decimal`

With:

> A single in-house `Decimal` type designed specifically for IcyDB.

And enforce scale at the schema level.

---

# Design Target

A minimal database-native decimal.

Not a financial math engine.

Not IEEE-compliant.

Not arbitrary precision.

Just what a database needs.

---

# Minimal Decimal Design

```rust
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Decimal {
    raw: i128,   // scaled integer
    scale: u32,  // number of fractional digits
}
```

That is the entire core.

Everything else builds on this.

---

# Core Invariants

1. `scale` <= MAX_SCALE (e.g. 18 or 28)
2. No trailing-zero normalization required for ordering
3. Ordering is numeric ordering (requires scale alignment)
4. Encoding must be deterministic and order-preserving
5. No NaN
6. No Infinity

This is not a floating type.

---

# Required Operations

Only implement what the engine needs:

### 1️⃣ Scale Alignment

```rust
fn align(lhs: Decimal, rhs: Decimal) -> (i128, i128, u32)
```

* Raise smaller-scale operand
* Check overflow
* Return aligned raws

---

### 2️⃣ Add / Sub

* Align
* raw + raw
* scale = max(lhs.scale, rhs.scale)

---

### 3️⃣ Mul

* raw * raw
* scale = lhs.scale + rhs.scale
* Optionally rescale back to schema target scale

---

### 4️⃣ Div

* Rescale numerator before division
* Define deterministic rounding rule (recommend round-half-up)

---

### 5️⃣ Rescale

```rust
fn rescale(self, target_scale: u32, rounding: RoundingMode)
```

This replaces `try_from_decimal_exact` and `from_decimal_round`.

---

### 6️⃣ Parsing / Formatting

Minimal string parser:

* Optional sign
* Digits
* Optional decimal point
* No exponent support

Keep it simple.

---

# Schema-Level Enforcement

Column definition becomes:

```rust
FieldKind::Decimal { scale: u32, precision: u32 }
```

On insert:

* Parse into Decimal
* Validate scale <= schema scale
* Rescale or reject

That replaces E8/E18 entirely.

---

# Changes in Value Enum

Current (roughly):

```
Value::Int
Value::Float
Value::Decimal
Value::E8
Value::E18
```

After 0.23:

```
Value::Int
Value::Float
Value::Decimal
```

One numeric path.

Executor simplifies.

Planner simplifies.

Aggregate specialization simplifies.

---

# Why This Is a Good 0.23

It:

* Reduces primitive surface
* Removes dependency
* Eliminates duplicate numeric code
* Simplifies aggregate logic
* Simplifies encoding logic
* Matches mature DB architecture

And it is internally contained to:

* types/
* value/
* schema validation
* aggregate numeric paths

No planner redesign needed.

---

# What To Explicitly Avoid in 0.23

Do NOT:

* Add arbitrary precision beyond i128
* Implement scientific notation
* Add multiple rounding modes
* Implement bankers rounding
* Support NaN or infinities
* Add const-generic scale types

Keep it small and deterministic.

---

# Suggested 0.23 Milestone Breakdown

### Step 1 — Introduce new Decimal (no removal yet)

* Implement minimal engine
* Add tests
* Add internal alignment utilities

### Step 2 — Replace E8/E18 internals with Decimal

* Keep aliases temporarily
* Remove their arithmetic impl blocks

### Step 3 — Remove rust_decimal dependency

* Replace parsing
* Replace formatting

### Step 4 — Collapse Value variants

* Remove E8/E18 variants
* Update planner/executor

### Step 5 — Schema enforcement update

* Enforce scale at column boundary

Each step compiles independently.

---

# Risk Assessment

Low-to-medium.

Risks are:

* Rounding mistakes
* Overflow edge cases
* Comparison alignment bugs

But these are testable and deterministic.

---

# Strategic Outcome

After 0.23:

* Numeric layer is fully owned
* No external decimal dependency
* No primitive explosion
* Cleaner executor branching
* Cleaner aggregate logic
* Cleaner encoding path

This is a mature move.

---

If you want, next I can draft:

* A concrete minimal Decimal implementation skeleton
* With alignment + add/sub/mul/div
* Designed specifically to slot into your existing Value + FieldValue system cleanly.
