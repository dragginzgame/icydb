# 0.30 — GROUP BY & Aggregation Pipeline

## Status

Draft — Architectural Design
Target: 0.30
Scope: Structural GROUP BY support with deterministic semantics and strict layering

---

# 1. Objective

Introduce `GROUP BY` support to the query engine while preserving:

* Strict layering between query, plan, executor, and storage
* Deterministic ordering guarantees
* Streaming-first execution when possible
* Conservative index pushdown
* No storage-layer semantic leakage

This document defines:

1. The logical model
2. Planner extensions
3. Execution modes
4. Pushdown eligibility rules
5. Index interaction model
6. Refactor requirements
7. Invariants and constraints

---

# 2. Non-Goals (0.30)

The following are explicitly **out of scope** for 0.30:

* HAVING clause
* Window functions
* Nested groupings
* Arbitrary expression grouping
* Multi-stage aggregation pipelines
* User-defined aggregates
* Partial distributed aggregation
* Storage-layer aggregation pushdown

0.30 introduces **structural grouping only**.

---

# 3. Logical Model

## 3.1 Query Shape

Extend `LogicalPlan` with:

```rust
pub struct GroupByPlan {
    pub group_fields: Vec<String>,
    pub aggregates: Vec<AggregateSpec>,
}
```

Use struct-based plan extension (not enum variants):

```rust
pub(crate) struct LogicalPlan<K> {
    // existing fields...
    pub(crate) group_by: Option<GroupByPlan>,
}
```

New logical stage:

```
Load
  → Filter (optional)
  → GroupBy (new)
  → Aggregate (per group)
```

Constraints:

* Group fields must be scalar fields.
* Group fields must be orderable.
* Group field list must not be empty.
* Aggregates must be deterministic.

---

## 3.2 Output Contract

Grouped queries return one row per group with a deterministic projection shape:

```rust
pub struct GroupedRow {
    pub key: Vec<Value>,           // group_fields in declared order
    pub aggregates: Vec<Value>,    // aggregate outputs in declared order
}
```

Validation rule:

All non-aggregated projected fields must appear in `group_fields`.

No implicit projection widening is allowed.

---

# 4. Aggregate Model

Use existing `AggregateSpec`, extended to support grouped context.

Allowed aggregates in 0.30:

* COUNT
* SUM
* MIN
* MAX
* FIRST
* LAST

Optional (if already implemented safely):

* AVG (derived from SUM + COUNT)

Not allowed:

* DISTINCT aggregates (unless already stable)
* Text aggregates
* Nested aggregates

`FIRST` / `LAST` semantics in 0.30:

* Evaluated against canonical input order for each group.
* Canonical input order is the executor row order after filter, then stable order contract.
* If canonical order is not guaranteed, planner must reject streaming `FIRST` / `LAST` and use deterministic materialized ordering before finalize.

---

# 5. Planner Changes

## 5.1 LogicalPlan

Add:

```rust
LogicalPlan {
  // ...
  group_by: Option<GroupByPlan>
}
```

This must remain **purely declarative**:

* No slot references
* No index component indices
* No execution flags

---

## 5.2 Validation

Validation must ensure:

* Group fields exist in schema
* Group fields are not map types
* Aggregate fields are valid
* No illegal mixing of grouped and non-grouped fields

Rule:

All non-aggregated projected fields must appear in `group_fields`.

---

## 5.3 Access Planning

Access planning must:

* Determine if a covering index exists for:

  * (group_fields + aggregate dependency fields)

If index ordering matches:

```
(group_fields..., [optional stable suffix such as primary_key])
```

Then streaming group aggregation may be possible.

Otherwise fallback to materialized grouping.

---

# 6. Execution Model

Two execution modes:

```rust
enum GroupExecutionMode {
    Streaming,
    Materialized,
}
```

---

## 6.1 Streaming Mode

Allowed when:

* AccessPath guarantees ordering by group_fields prefix.
* No residual predicate requiring post-fetch filtering.
* Aggregate functions are streaming-compatible.

Execution strategy:

```
Iterate ordered rows
→ Detect group boundary
→ Maintain per-group fold state
→ Emit group result
```

Memory:

O(1) per group (rolling window only)

---

## 6.2 Materialized Mode

Fallback when:

* No ordering guarantee
* Composite residual predicates
* Non-streamable aggregates

Execution strategy:

```
Scan rows
→ HashMap<group_key, AggregateState>
→ Finalize groups
→ Sort output deterministically
```

Memory:

O(number_of_groups)

---

# 7. Deterministic Ordering Contract

Output ordering must be deterministic.

Default rule:

* Output ordered by `group_fields` ascending in declared order.
* Tie-break (if needed for engine-internal stability) uses canonical encoded group-key bytes.
* Primary key is not a grouped-output tie-break unless explicitly part of the group key.

Even in materialized mode, final output must be sorted to maintain determinism.

No undefined ordering allowed.

---

# 8. Predicate Interaction

Predicates apply before grouping.

Pipeline:

```
Scan
→ Filter
→ Group
→ Aggregate
```

HAVING not supported in 0.30.

---

# 9. Index Interaction Model

Index pushdown for grouping is limited in 0.30.

Allowed:

* Ordered scan if index prefix matches group_fields.

Not allowed:

* Storage-level grouped aggregation.
* Index-only grouped aggregate execution in 0.30.

---

# 10. Slot Resolution

Slot resolution must:

* Resolve group_fields to slots
* Resolve aggregate field dependencies to slots

This must occur in a dedicated lowering stage:

```
GroupByPlan
  → ResolvedGroupByPlan
```

Resolved version may include:

```rust
pub struct ResolvedGroupByPlan {
    pub group_slots: Vec<usize>,
    pub aggregate_slots: Vec<usize>,
}
```

Must not leak into LogicalPlan.

---

# 11. Executor Integration

Group execution must live in:

```
db/executor/load/aggregate/group.rs
```

NOT inside:

* query
* index
* storage

Planner produces a contract.
Executor performs grouping.

---

# 12. Refactor Prerequisites

Before implementing GROUP BY, ensure:

1. `query/plan` does not construct physical key streams.
2. Routing logic is isolated from logical planning.
3. Aggregate folding logic is reusable outside single-result context.
4. Streaming fold logic is reusable for group context.
5. Predicate subsystem split (`resolve`, `runtime`, `index_compile`) is complete.

If any of these are not true, refactor first.

---

# 13. Required Module Additions

New files:

```
query/plan/group.rs
executor/load/aggregate/group.rs
```

Baseline already in place:

```
predicate/
  eval/
    resolve.rs
    runtime.rs
    index_compile.rs
```

Group by increases planner complexity; keep this split as an enforced prerequisite.

---

# 14. Invariants

Must hold true after implementation:

* Query layer does not depend on executor internals.
* Executor does not depend on logical AST.
* Index layer does not depend on group logic.
* Streaming grouping does not allocate per-row structures.
* Materialized grouping always sorts output.

---

# 15. Edge Case Handling

### Empty result set

Return empty group list.

### NULL group field

NULL must be a valid grouping key.

All NULL values collapse into same group.

### Missing field

Missing and NULL are distinct grouping keys.

* `Missing` groups together.
* `NULL` groups together.
* `Missing != NULL`.

Deterministic ordering for key comparison:

`Missing < NULL < Present(value)` using canonical value ordering for `Present(value)`.

---

# 16. Performance Expectations

Streaming mode:

* O(n) scan
* O(1) per group memory

Materialized mode:

* O(n) scan
* O(g) memory
* O(g log g) final sort

Where g = number of groups.

---

# 17. Future Extensions (Post-0.30)

* HAVING clause
* Index-level aggregate pushdown
* DISTINCT aggregates
* Composite grouping optimizations
* Parallel grouping
* Partial streaming grouping with bounded buffers

---

# 18. Success Criteria

GROUP BY is complete when:

* LogicalPlan supports grouping.
* Validation enforces group correctness.
* Streaming mode works on ordered index scans.
* Materialized mode works on full scans.
* Output ordering deterministic.
* All existing tests pass.
* No new layering violations introduced.

---

# 19. Architecture Score Target

After 0.30, the query engine should achieve:

```
Layering Integrity ≥ 9/10
```

GROUP BY must not reduce architectural clarity.
