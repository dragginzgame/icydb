# 0.29 - Hardening Before GROUP BY

## Status

- `0.29.8` scope: implementation complete
- Release state: pending release/tag
- Deferred structural work owner: `0.30` execution-kernel milestone

## 1) Decision

`0.29.0` is a structural hardening release.

Purpose:

- reduce drift risk across aggregate routing, ranking semantics, cursor contracts, and recovery behavior
- lock determinism and invariant enforcement before introducing `GROUP BY` in `0.31`

This milestone is contraction, not expansion.

## 1a) Patchline Split (`0.29.8` / `0.30`)

`0.29.8` is the focused `db/` audit patchline and is intentionally narrow:

- unify residual underfill/retry execution duplication between load and aggregate distinct execution
- restore query/index layering boundaries in cursor/query plan contracts
- normalize commit marker corruption error construction and classification boundaries
- add explicit route/execution parity tests for `ConservativeSubset` vs `StrictAllOrNone`

`0.30` carries structural work that is higher-risk or requires larger module reshaping:

- route planner and aggregate module decomposition
- pull-based streaming conversion for key-stream pipelines
- removal of `O(n^2)` projection/terminal fallback behavior
- broader aggregate/load/count-distinct flow unification beyond surgical `0.29.8` changes

This `0.30` work is tracked in:

- `docs/design/0.30-execution-kernel.md`

---

## 2) Why `0.29` Exists

`0.28.x` expanded terminal ergonomics (`top/bottom k` row/value/id-value surfaces) without changing route ownership.

`0.31` (`GROUP BY`) will increase complexity in all of these dimensions:

- state accumulation and memory behavior
- ordering/comparator semantics
- fold-mode and route eligibility surfaces
- replay and failure-boundary pressure

If hardening is deferred, the stabilization target grows and drift risk compounds.

`0.29` intentionally freezes core execution seams first.

---

## 3) Scope

### In Scope (`0.29.8`)

- residual retry-flow canonicalization across load and aggregate distinct paths
- query/index contract boundary cleanup in cursor/query modules
- commit marker corruption error construction/classification consistency
- routing precedence parity tests for `ConservativeSubset` vs `StrictAllOrNone`

### Out of Scope (`0.29.8`)

- new query terminals
- new aggregate kinds
- new routing modes or pushdown classes
- cursor feature expansion
- index-pushdown experiments
- read-side early top-k heap optimization
- `GROUP BY` implementation
- route planner/aggregate module decomposition
- pull-based streaming rewrite
- broad aggregate/load/count-distinct architecture convergence

---

## 4) Hard Constraints

- no user-visible feature expansion
- no semantic changes to existing terminal results
- no route ownership inversion
- no error-taxonomy collapse
- no continuation behavior broadening

Allowed changes are enforcement, consolidation, and test hardening only.

For `0.29.8`, this additionally means no large-scale module split or execution model rewrite.

---

## 4a) Locked Baselines Before `GROUP BY`

These are treated as locked in `0.29` unless a correctness bug is found:

- error taxonomy stability:
  - null/missing parity and fail-before-scan contracts remain unchanged
  - existing `Unsupported`/`Invariant`/`Corruption` boundaries stay explicit
- determinism baseline:
  - pk tie-break rules stay unchanged
  - ranked comparator contracts stay unchanged
  - forced access-shape + direction invariance remains required
  - remaining determinism focus is `HashMap` iteration audit
- continuation discipline:
  - ranked terminals remain non-paged terminal endpoints
  - no continuation expansion in `0.29`
  - `GROUP BY` initial target in `0.31` also starts without cursor continuation support

---

## 5) Phase Plan

Patchline note:

- phase plan below captures the full hardening direction.
- `0.29.8` executes only the narrowed scope in section 3.
- any task requiring structural module decomposition or streaming model rework is deferred to `0.30`.

## Phase 1 - Aggregate Surface Hardening

### 1. Centralize fast-path eligibility

Target:

- one canonical eligibility gate for aggregate fast paths
- all fast-path entrypoints must call it
- no alternate bypass path

Implementation intent:

- keep route authority in route-owned layer
- make eligibility callsites mechanically unavoidable from aggregate execution entrypoints
- prefer a compiler-enforced pattern where feasible:
  - eligibility gate yields a verified capability marker/token
  - fast-path execution entrypoints require that marker/token type instead of a raw boolean

Acceptance:

- add a route/aggregate gate test that asserts all eligible aggregate kinds route through one shared eligibility verifier
- add a negative test proving unsupported/new aggregate kinds cannot bypass the gate
- if capability-marker enforcement is implemented, no fast-path entrypoint is callable without verified eligibility input

### 2. Canonical ranked-row helper enforcement

Target:

- one ranked-row entrypoint per direction contract
- comparator logic private to terminal module boundary
- no mirrored comparator blocks in terminal callsites

Implementation intent:

- keep deterministic contract fixed:
  - top: `(field desc, primary_key asc)`
  - bottom: `(field asc, primary_key asc)`

Acceptance:

- ranked terminals (`*_k_by`, `*_k_by_values`, `*_k_by_with_ids`) all route through shared ranked-row helper paths
- no duplicated comparator loops remain in those terminals

### 3. Cursor signature lockdown

Target:

- terminal shape is part of continuation signature invariants
- continuation must not resume under a different terminal shape
- continuation signature coverage remains extensible for future grouped terminal shapes

Acceptance:

- add cursor signature mutation tests validating rejection on terminal-shape drift
- keep current non-paged terminal cursor-intent boundaries unchanged
- add/retain signature tests that bind ordering spec, direction, and limit/window shape for ranked/paged-compatible surfaces

### 3b. Query-shape to execution-mode boundary hardening

Target:

- execution mode ownership is explicit, centralized, and closed
- aggregate terminals explicitly select streaming vs materialized mode
- no implicit streaming fallback is hidden inside fold or terminal internals

Implementation intent:

- keep execution-mode decision in one route-owned boundary
- ensure terminal execution consumes an explicit mode contract rather than inferring mode ad hoc
- pre-`0.31`, grouped fold patterns are explicitly materialized-only by construction
- select execution mode before any fold-state allocation
- keep execution mode immutable for the full execution lifecycle

Acceptance:

- one centralized execution-mode selector is authoritative for aggregate terminals
- tests assert no aggregate terminal can silently switch mode through fold-internal fallback
- grouped aggregation readiness contract states materialized-only initial execution mode
- tests/assertions confirm execution mode is fixed pre-fold-allocation and does not mutate mid-execution

---

## Phase 2 - Determinism Audit

### 4. HashMap iteration audit

Target:

- explicitly identify all iteration points where ordering could affect semantics
- document where ordering is irrelevant
- normalize ordering where ordering is semantically relevant
- avoid introducing accidental semantic coupling by replacing order-irrelevant maps with ordered maps without explicit contract updates

Acceptance:

- deterministic ordering assumptions are documented in code or tests at each critical boundary
- no result-order dependence on `HashMap` iteration remains in semantic output paths
- order-irrelevant paths explicitly document irrelevance to prevent accidental coupling in later refactors

### 5. Comparator and ordering invariant matrix

Target:

- global invariant tests for ranked terminals across:
  - base order ASC vs DESC
  - forced `FullScan`
  - forced `IndexRange`

Acceptance:

- identical ranked ID sets for equivalent effective windows across those access/order variants
- randomized insertion-order test(s) produce identical ranked outputs for equivalent logical datasets

---

## Phase 3 - Commit and Recovery Hardening

### 6. Replay and failure-boundary hardening

Target:

- expand parity tests for normal apply vs replay apply
- inject apply-stage failures and verify no half-visible state
- include at least one mixed-state failure edge:
  - index mutation succeeds
  - row mutation fails
  - rollback path runs
  - no visible inconsistency remains
- include at least one replay-apply failure injection case with the same no-half-state expectation

Acceptance:

- no observable partial mutation state at failure boundaries
- replay equivalence remains intact for affected mutation shapes
- mixed-state failure-injection case is explicitly covered by tests
- replay-failure-injection case is explicitly covered by tests

---

## Phase 4 - Surface Simplification

### 7. Remove duplication and mirrored guards

Target:

- consolidate duplicate error-mapping branches where behavior is identical
- remove mirrored slot-resolution checks where a shared invariant gate exists
- eliminate comparator duplication outside canonical helper paths

Acceptance:

- reduced duplication without changing public behavior or taxonomy
- simplification is covered by parity tests, not just code movement

### 8. Planner and fold infrastructure readiness

Target:

- ensure aggregate planner metadata is represented by one canonical descriptor shape
- ensure aggregate spec ownership is unified and explicit at execution boundaries
- ensure fold-state boundaries can host grouped multi-state execution without redesign

Implementation intent:

- introduce internal aggregate spec unification if current dispatch remains terminal-branch heavy
- if current terminal-specific fold wiring is tightly coupled, introduce one internal fold-state container abstraction now
- the container may still host one state in `0.29`; this is a structural readiness boundary, not a feature expansion
- avoid any user-visible API or behavior change
- do not partially unify dispatch; unification is all-or-nothing
- execution layer consumes only the unified internal aggregate spec
- terminal surfaces translate to internal aggregate spec early, not via late execution-branch fanout

Acceptance:

- one internal execution-layer aggregate spec is authoritative for aggregate dispatch
- planner aggregate metadata no longer relies on mirrored terminal-specific shape definitions
- execution fold plumbing can represent multiple aggregate states through one internal container contract
- existing aggregate outputs and taxonomy remain unchanged
- no execution path branches on terminal-specific aggregate wiring after internal aggregate spec construction

Note:

- this is internal unification work only; it does not add new aggregate capabilities in `0.29`

---

## Phase 5 - Memory Pressure Contract Lock

### 9. Pre-`GROUP BY` memory boundary audit

Target:

- validate existing memory-pressure and scan-budget contracts before introducing grouped accumulation state
- confirm underfill retry behavior remains defined and stable for current terminal families
- document ranking-terminal memory semantics for grouped-readiness reasoning

Implementation intent:

- keep this phase audit-first; do not add new memory-control features in `0.29` unless a concrete invariant gap is found
- if gaps exist, patch with minimal structural hardening and tests only
- make ranking-terminal memory behavior explicit:
  - whether terminals require full materialization
  - whether growth is bounded by scan-budget or dataset size
- document fold-state retention boundaries:
  - whether fold-state lifetime is bounded by effective scan window or full dataset traversal
  - whether terminals retain row references longer than logically required

Acceptance:

- explicit documentation of current memory/scan boundaries relevant to grouped execution readiness
- scan-budget and underfill retry contracts remain parity-locked in tests
- ranking-terminal materialization and memory-growth contracts are explicitly documented
- fold-state lifetime and row-reference retention boundaries are explicitly documented

### 10. Read-side optimization deferral lock

Target:

- explicitly defer early top-k heap optimization until after grouped execution lands

Rationale:

- while attractive for performance, it changes execution characteristics and adds complexity near routing/fold boundaries
- this should not compete with `0.29` contraction goals

Acceptance:

- no new streaming/heap top-k path is introduced in `0.29`
- existing materialized ranking semantics and scan-budget behavior remain unchanged

---

## 6) Completion Criteria

`0.29.8` is complete when all are true:

1. residual retry-flow duplication across load and aggregate distinct execution is removed under one canonical boundary
2. query/index layering leak points in cursor/query contracts are removed and test-locked
3. commit marker corruption paths use one explicit construction/classification policy
4. routing precedence parity coverage for `ConservativeSubset` and `StrictAllOrNone` is explicit and green
5. no feature-scope growth occurred inside `0.29.8`

---

## 7) Verification Gates

Minimum release verification:

- `cargo fmt --all`
- `cargo check -p icydb-core`
- `cargo test -p icydb-core aggregate -- --nocapture`
- `cargo test -p icydb-core pagination -- --nocapture`
- targeted scan-budget + underfill retry invariant filters for ranking/projection terminals
- targeted recovery/replay failure-injection test filters for hardened paths

Project-level release gate remains:

- `make fmt-check && make clippy && make check && make test`

---

## 8) Post-`0.29` Transition

If `0.29.8` completion criteria are met:

- proceed to `0.30` execution-kernel consolidation for deferred work from section `1a`
- then proceed to `0.31` `GROUP BY` design and implementation

If not:

- continue hardening in `0.29.x` without adding new query features.
