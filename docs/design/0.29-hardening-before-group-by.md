# 0.29 - Hardening Before GROUP BY

## 1) Decision

`0.29.0` is a structural hardening release.

Purpose:

- reduce drift risk across aggregate routing, ranking semantics, cursor contracts, and recovery behavior
- lock determinism and invariant enforcement before introducing `GROUP BY` in `0.30`

This milestone is contraction, not expansion.

---

## 2) Why `0.29` Exists

`0.28.x` expanded terminal ergonomics (`top/bottom k` row/value/id-value surfaces) without changing route ownership.

`0.30` (`GROUP BY`) will increase complexity in all of these dimensions:

- state accumulation and memory behavior
- ordering/comparator semantics
- fold-mode and route eligibility surfaces
- replay and failure-boundary pressure

If hardening is deferred, the stabilization target grows and drift risk compounds.

`0.29` intentionally freezes core execution seams first.

---

## 3) Scope

### In Scope (`0.29.0`)

- aggregate fast-path eligibility centralization and enforcement
- ranked-row helper and comparator entrypoint hardening
- query-shape to execution-mode boundary hardening
- cursor signature hardening for terminal-shape binding
- determinism audit and explicit ordering contracts
- commit/recovery failure-boundary hardening tests
- internal simplification that removes duplicated enforcement logic
- planner/fold infrastructure readiness for grouped aggregation expansion

### Out of Scope (`0.29.0`)

- new query terminals
- new aggregate kinds
- new routing modes or pushdown classes
- cursor feature expansion
- index-pushdown experiments
- read-side early top-k heap optimization
- `GROUP BY` implementation

---

## 4) Hard Constraints

- no user-visible feature expansion
- no semantic changes to existing terminal results
- no route ownership inversion
- no error-taxonomy collapse
- no continuation behavior broadening

Allowed changes are enforcement, consolidation, and test hardening only.

---

## 4a) Locked Baselines Before `GROUP BY`

These are treated as locked in `0.29` unless a correctness bug is found:

- error taxonomy stability:
  - null/missing parity and fail-before-scan contracts remain unchanged
  - existing `Unsupported`/`Invariant`/`Corruption` boundaries stay explicit
- determinism baseline:
  - pk tie-break rules stay unchanged
  - ranked comparator contracts stay unchanged
  - forced access-shape + direction invariance remains required
  - remaining determinism focus is `HashMap` iteration audit
- continuation discipline:
  - ranked terminals remain non-paged terminal endpoints
  - no continuation expansion in `0.29`
  - `GROUP BY` initial target in `0.30` also starts without cursor continuation support

---

## 5) Phase Plan

## Phase 1 - Aggregate Surface Hardening

### 1. Centralize fast-path eligibility

Target:

- one canonical eligibility gate for aggregate fast paths
- all fast-path entrypoints must call it
- no alternate bypass path

Implementation intent:

- keep route authority in route-owned layer
- make eligibility callsites mechanically unavoidable from aggregate execution entrypoints
- prefer a compiler-enforced pattern where feasible:
  - eligibility gate yields a verified capability marker/token
  - fast-path execution entrypoints require that marker/token type instead of a raw boolean

Acceptance:

- add a route/aggregate gate test that asserts all eligible aggregate kinds route through one shared eligibility verifier
- add a negative test proving unsupported/new aggregate kinds cannot bypass the gate
- if capability-marker enforcement is implemented, no fast-path entrypoint is callable without verified eligibility input

### 2. Canonical ranked-row helper enforcement

Target:

- one ranked-row entrypoint per direction contract
- comparator logic private to terminal module boundary
- no mirrored comparator blocks in terminal callsites

Implementation intent:

- keep deterministic contract fixed:
  - top: `(field desc, primary_key asc)`
  - bottom: `(field asc, primary_key asc)`

Acceptance:

- ranked terminals (`*_k_by`, `*_k_by_values`, `*_k_by_with_ids`) all route through shared ranked-row helper paths
- no duplicated comparator loops remain in those terminals

### 3. Cursor signature lockdown

Target:

- terminal shape is part of continuation signature invariants
- continuation must not resume under a different terminal shape
- continuation signature coverage remains extensible for future grouped terminal shapes

Acceptance:

- add cursor signature mutation tests validating rejection on terminal-shape drift
- keep current non-paged terminal cursor-intent boundaries unchanged
- add/retain signature tests that bind ordering spec, direction, and limit/window shape for ranked/paged-compatible surfaces

### 3b. Query-shape to execution-mode boundary hardening

Target:

- execution mode ownership is explicit, centralized, and closed
- aggregate terminals explicitly select streaming vs materialized mode
- no implicit streaming fallback is hidden inside fold or terminal internals

Implementation intent:

- keep execution-mode decision in one route-owned boundary
- ensure terminal execution consumes an explicit mode contract rather than inferring mode ad hoc
- pre-`0.30`, grouped fold patterns are explicitly materialized-only by construction
- select execution mode before any fold-state allocation
- keep execution mode immutable for the full execution lifecycle

Acceptance:

- one centralized execution-mode selector is authoritative for aggregate terminals
- tests assert no aggregate terminal can silently switch mode through fold-internal fallback
- grouped aggregation readiness contract states materialized-only initial execution mode
- tests/assertions confirm execution mode is fixed pre-fold-allocation and does not mutate mid-execution

---

## Phase 2 - Determinism Audit

### 4. HashMap iteration audit

Target:

- explicitly identify all iteration points where ordering could affect semantics
- document where ordering is irrelevant
- normalize ordering where ordering is semantically relevant
- avoid introducing accidental semantic coupling by replacing order-irrelevant maps with ordered maps without explicit contract updates

Acceptance:

- deterministic ordering assumptions are documented in code or tests at each critical boundary
- no result-order dependence on `HashMap` iteration remains in semantic output paths
- order-irrelevant paths explicitly document irrelevance to prevent accidental coupling in later refactors

### 5. Comparator and ordering invariant matrix

Target:

- global invariant tests for ranked terminals across:
  - base order ASC vs DESC
  - forced `FullScan`
  - forced `IndexRange`

Acceptance:

- identical ranked ID sets for equivalent effective windows across those access/order variants
- randomized insertion-order test(s) produce identical ranked outputs for equivalent logical datasets

---

## Phase 3 - Commit and Recovery Hardening

### 6. Replay and failure-boundary hardening

Target:

- expand parity tests for normal apply vs replay apply
- inject apply-stage failures and verify no half-visible state
- include at least one mixed-state failure edge:
  - index mutation succeeds
  - row mutation fails
  - rollback path runs
  - no visible inconsistency remains
- include at least one replay-apply failure injection case with the same no-half-state expectation

Acceptance:

- no observable partial mutation state at failure boundaries
- replay equivalence remains intact for affected mutation shapes
- mixed-state failure-injection case is explicitly covered by tests
- replay-failure-injection case is explicitly covered by tests

---

## Phase 4 - Surface Simplification

### 7. Remove duplication and mirrored guards

Target:

- consolidate duplicate error-mapping branches where behavior is identical
- remove mirrored slot-resolution checks where a shared invariant gate exists
- eliminate comparator duplication outside canonical helper paths

Acceptance:

- reduced duplication without changing public behavior or taxonomy
- simplification is covered by parity tests, not just code movement

### 8. Planner and fold infrastructure readiness

Target:

- ensure aggregate planner metadata is represented by one canonical descriptor shape
- ensure aggregate spec ownership is unified and explicit at execution boundaries
- ensure fold-state boundaries can host grouped multi-state execution without redesign

Implementation intent:

- introduce internal aggregate spec unification if current dispatch remains terminal-branch heavy
- if current terminal-specific fold wiring is tightly coupled, introduce one internal fold-state container abstraction now
- the container may still host one state in `0.29`; this is a structural readiness boundary, not a feature expansion
- avoid any user-visible API or behavior change
- do not partially unify dispatch; unification is all-or-nothing
- execution layer consumes only the unified internal aggregate spec
- terminal surfaces translate to internal aggregate spec early, not via late execution-branch fanout

Acceptance:

- one internal execution-layer aggregate spec is authoritative for aggregate dispatch
- planner aggregate metadata no longer relies on mirrored terminal-specific shape definitions
- execution fold plumbing can represent multiple aggregate states through one internal container contract
- existing aggregate outputs and taxonomy remain unchanged
- no execution path branches on terminal-specific aggregate wiring after internal aggregate spec construction

Note:

- this is internal unification work only; it does not add new aggregate capabilities in `0.29`

---

## Phase 5 - Memory Pressure Contract Lock

### 9. Pre-`GROUP BY` memory boundary audit

Target:

- validate existing memory-pressure and scan-budget contracts before introducing grouped accumulation state
- confirm underfill retry behavior remains defined and stable for current terminal families
- document ranking-terminal memory semantics for grouped-readiness reasoning

Implementation intent:

- keep this phase audit-first; do not add new memory-control features in `0.29` unless a concrete invariant gap is found
- if gaps exist, patch with minimal structural hardening and tests only
- make ranking-terminal memory behavior explicit:
  - whether terminals require full materialization
  - whether growth is bounded by scan-budget or dataset size
- document fold-state retention boundaries:
  - whether fold-state lifetime is bounded by effective scan window or full dataset traversal
  - whether terminals retain row references longer than logically required

Acceptance:

- explicit documentation of current memory/scan boundaries relevant to grouped execution readiness
- scan-budget and underfill retry contracts remain parity-locked in tests
- ranking-terminal materialization and memory-growth contracts are explicitly documented
- fold-state lifetime and row-reference retention boundaries are explicitly documented

### 10. Read-side optimization deferral lock

Target:

- explicitly defer early top-k heap optimization until after grouped execution lands

Rationale:

- while attractive for performance, it changes execution characteristics and adds complexity near routing/fold boundaries
- this should not compete with `0.29` contraction goals

Acceptance:

- no new streaming/heap top-k path is introduced in `0.29`
- existing materialized ranking semantics and scan-budget behavior remain unchanged

---

## 6) Completion Criteria

`0.29.0` is complete when all are true:

1. one canonical aggregate fast-path eligibility gate exists and is mandatory
2. ranked-row semantics route through one shared helper family
3. cursor signature drift across terminal shape is explicitly rejected by tests
4. determinism assumptions are documented and enforced by tests
5. commit/replay failure-boundary parity tests are expanded and green
6. aggregate planner/fold infrastructure readiness boundaries are explicit and test-locked
7. memory-pressure and scan-budget/underfill contracts are explicitly audited for grouped-readiness
8. no feature-scope growth occurred inside `0.29.0`

---

## 7) Verification Gates

Minimum release verification:

- `cargo fmt --all`
- `cargo check -p icydb-core`
- `cargo test -p icydb-core aggregate -- --nocapture`
- `cargo test -p icydb-core pagination -- --nocapture`
- targeted scan-budget + underfill retry invariant filters for ranking/projection terminals
- targeted recovery/replay failure-injection test filters for hardened paths

Project-level release gate remains:

- `make fmt-check && make clippy && make check && make test`

---

## 8) Post-`0.29` Transition

If `0.29.0` completion criteria are met:

- proceed to `0.30` `GROUP BY` design and implementation

If not:

- continue hardening in `0.29.x` without adding new query features.
