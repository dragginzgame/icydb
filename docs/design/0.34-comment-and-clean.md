# 0.34 â€” DB Directory Narrative & Placement Consolidation

## Design Document

- Status: Proposed
- Scope: `crates/icydb-core/src/db/` (entire directory, production code only)
- Goal: Narrative clarity + structural placement validation
- Non-Goal: Behavioral change or feature addition

---

## 1. Objective

Perform a systematic pass over the entire `db/` directory to:

- Add minimal but precise documentation to all public and internal functions.
- Add helper comments for long or non-trivial code blocks.
- Validate structural placement of every struct and function.
- Detect consolidation opportunities (merge, relocate, split, collapse).
- Reduce architectural ambiguity.
- Strengthen semantic authority boundaries.

This pass must not introduce behavior changes.

This is a clarity and consolidation phase, not a feature phase.

---

## 2. Guiding Principles

### 2.1 Comment Philosophy

Comments must:

- Explain why, not restate the obvious.
- Clarify invariants.
- Clarify boundary contracts.
- Clarify ordering assumptions.
- Clarify atomicity guarantees.
- Clarify streaming vs materialization assumptions.
- Clarify ownership of semantic authority.
- Stay synchronized with current code behavior and naming.

Avoid:

- Redundant type restatement.
- Trivial `get/set` comments.
- Describing obvious control flow.
- Leaving stale comments that reference removed flows, old module names, or outdated invariants.

Target density:

- 2-6 lines per non-trivial function.
- Section comments for blocks > ~20 lines.
- Module-level summary explaining responsibility.

Required stale-comment check per file:

- Verify comments match the current function/module name.
- Verify comments still describe the actual control flow after refactors.
- Update or delete any comment that no longer reflects runtime behavior.

### 2.2 Structural Evaluation Criteria

For every struct or function ask:

- Does this belong in this module?
- Is this semantically owned here?
- Is it a boundary artifact or core domain?
- Is it duplicating logic elsewhere?
- Is it mixing semantic and runtime concerns?
- Does it introduce cyclic dependency pressure?
- Is it too small and should merge?
- Is it too large and should split?

---

## 3. Audit Methodology

Perform pass module-by-module in this order:

1. `commit/`
2. `data/`
3. `index/`
4. `predicate/`
5. `access/`
6. `query/`
7. `cursor/`
8. `executor/`
9. `relation/`
10. `db/mod.rs`

Why this order?

It flows from:

1. Durability authority
2. Storage primitives
3. Index layer
4. Semantic layer
5. Access layer
6. Planning layer
7. Continuation protocol
8. Runtime
9. Integrity domain
10. Root orchestration

This prevents circular reasoning during evaluation.

---

## 4. Per-Module Evaluation Template

For each module:

### 4.1 Module Header

Ensure a top-of-file module comment includes:

- What domain this module owns.
- What it explicitly does not own.
- Who is allowed to depend on it.
- Which layers it must not depend on.

Example format:

```rust
//! Module: commit
//! Responsibility: durable mutation protocol and recovery authority.
//! Does not own: query planning, index encoding, or predicate semantics.
//! Boundary: executor -> commit (one-way).
```

### 4.2 Struct-Level Review

For each struct, add a summary explaining:

- What invariant it protects.
- Whether it is semantic or runtime.
- Whether it crosses boundaries.

Evaluate:

- Should it be moved?
- Should it be merged?
- Is it leaking layer semantics?

### 4.3 Function-Level Review

For each function, add:

```rust
/// Performs X.
/// Invariant: Y.
/// Called by: Z.
/// Must not: W.
```

If body > 20-30 lines, add internal block comments:

```rust
// Phase 1: validate preconditions
// Phase 2: perform transformation
// Phase 3: enforce invariant
```

---

## 5. Structural Consolidation Checks

During review, actively look for:

### 5.1 Duplicate Spec Types

Example risk:

- `GroupAggregateSpec` in two places
- Multiple error enums representing same domain
- Multiple normalization pipelines

Resolution rule:

- There must be one semantic authority per concept.

### 5.2 Enum Reinterpretation

Search for:

- `match` on foreign enums
- Mapping functions between domain enums

If found:

- Move semantic logic to enum impl.
- Remove translation layers.

### 5.3 Canonicalization Drift

Search for:

- `normalize`
- `canonical`
- `flatten`
- `validate`
- `hash`

Verify:

- One canonical owner.
- Other modules call into it.

### 5.4 Runtime Leakage into Semantic Layer

Ensure:

- `query/` does not import executor.
- `predicate/` does not import runtime.
- `access/` does not import planner logic.
- `commit/` does not import index planning logic.

### 5.5 Root Module Overload

Review `db/mod.rs` for mixing:

- Facade
- Runtime wiring
- Payload types
- Recovery hooks
- Policy
- Re-exports

If overloaded, plan future split.

---

## 6. Documentation Targets

Add comments especially to:

- Commit boundary functions.
- Streaming vs materialized branches.
- Continuation signature computation.
- Aggregate semantic helpers.
- Route planner decision matrices.
- Preflight and mutation window logic.
- Relation integrity validation.

These are areas where invariants matter most.

---

## 7. Comment Quality Standard

Every complex function must answer:

- What invariant does this protect?
- What ordering assumptions does it rely on?
- What failure mode does it guard?
- What layer does it belong to?

If it cannot answer those clearly, placement may be wrong.

---

## 8. Deliverables

At end of pass:

- All modules have top-level responsibility comments.
- All non-trivial functions have doc comments.
- All long functions have block-level comments.

Provide a list of:

- Relocated items
- Merged items
- Removed duplicate specs
- Identified future splits

Produce a summary report:

- Total files reviewed: `X`
- Functions commented: `Y`
- Structs commented: `Z`
- Relocations performed: `N`
- Spec unifications performed: `M`
- Remaining structural risks: `[...]`

---

## 9. Risks

This pass may expose:

- Hidden semantic duplication
- Cross-layer leakage
- Implicit ordering assumptions
- Undocumented atomicity hazards
- Redundant mapping layers

Do not ignore these.
Log them explicitly.

---

## 10. Success Criteria

This pass is complete when:

- Reading any file reveals its domain responsibility immediately.
- No ambiguous spec duplication remains.
- No function exceeds ~40 lines without block commentary.
- Aggregate taxonomy authority is singular.
- Commit boundary invariant is clearly documented.
- Streaming grouping path is self-explanatory.

---

## 11. Strategic Impact

After this pass:

- `GROUP BY` expansion is safer.
- Ordered-stream specialization is easier.
- Architectural entropy decreases.
- New contributors understand domain boundaries.
- Invariant drift becomes visible.

---

## Final Guidance

- Do not rush this.
- Do 1-3 modules per session.
- Every time you move something, ask: does this increase semantic clarity?

If yes, proceed.
If no, revert.
