# 0.33 - Planner and GROUP BY Integration

## Theme
Wire grouping end-to-end using the stabilized substrate from `0.31` and `0.32`.

## Dependency Chain
- Input from `0.31`: canonical key/equality semantics and deterministic hashing.
- Input from `0.32`: unified aggregate state machine, typed error domains, and execution-shape model.
- Input from `0.32.3`: grouped-readiness scaffolding (internal handoff contracts, grouped error mapping scaffolding, observability schema lock-in, and grouped disabled-path guardrails).
- Output from `0.33`: first complete grouped planning/execution surface with explicit APIs.

## Objectives
### 1. Explicit `GroupPlan` Variant
Introduce:

```rust
pub struct GroupPlan {
    group_fields: Vec<FieldSlot>,
    aggregates: Vec<AggregateSpec>,
}
```

Planner must produce:

```rust
enum LogicalPlan {
    Scalar(...),
    Grouped(GroupPlan),
}
```

Requirements:
- No feature flags in plan shape.
- No optional grouped bits in scalar plan.
- Explicit grouped variant only.
- No executor-side promotion from scalar plans into grouped plans.
- No scalar fallback path that coerces grouped semantics.

Acceptance criteria:
- Planner emits `LogicalPlan::Grouped` for grouped intents.
- Scalar plans remain unchanged for non-grouped queries.
- No grouped execution path depends on scalar-only hidden flags.
- Planner invariant tests enforce variant exclusivity (`Scalar XOR Grouped`) with no transitional state.
- Plan serialization (if present) and explain output preserve distinct scalar vs grouped variants.

### 2. Grouped Aggregate Execution
Use:
- `GroupKey`
- `AggregateFactory`
- `ExecutionShape::Blocking`
- `ExecutionBudget` tracking

Implement:
- in-memory hash map keyed by `GroupKey`
- per-group state application
- finalization into grouped result set

Acceptance criteria:
- Grouped queries execute through explicit blocking grouped path.
- Per-group aggregate state is isolated and deterministic.
- Grouped results are stable under insertion-order variation.
- Group equality and hashing use canonical `GroupKey` semantics.
- Finalization ordering does not depend on hash-map iteration order.
- Group budget enforcement accounts for group key + aggregate state + map-overhead estimate (coarse estimate is acceptable).

### 3. Grouped Cursor Protocol
Wire:
- `GroupedContinuationToken` encode/decode
- grouped page builder
- grouped revalidate path

Acceptance criteria:
- Grouped continuation tokens round-trip with signature/direction/offset checks.
- Grouped continuation tokens include canonical `last_group_key` anchor and must not be offset-only.
- Grouped continuation resumes from group-boundary anchors (`last_group_key`) with offset compatibility checks.
- Dead grouped scaffolding is removed once real path is wired.

### 4. Response Surface Extension
Introduce grouped response type:

```rust
pub enum QueryResponse {
    Rows(Vec<Row>),
    GroupedRows(Vec<GroupedRow>),
}
```

Requirements:
- Do not overload scalar row response contracts.
- Do not provide implicit conversion from `GroupedRows` to scalar `Rows`.

Acceptance criteria:
- Grouped results are represented only by grouped response variant.
- Scalar query behavior and types remain stable.
- Response discriminants are stable across serialization boundaries; older clients fail clearly when grouped variants are unsupported.

### 5. Session API Extension
Add explicit grouped terminal API:

```rust
session.execute_grouped(...)
```

Requirements:
- Do not leak grouped behavior through scalar wrappers.

Acceptance criteria:
- Grouped execution is reachable through explicit grouped API only.
- Existing scalar aggregate wrappers keep current semantics.

## Migration Behavior for Existing Scalar APIs
- Existing scalar APIs (`execute`, scalar aggregate terminals, and row-oriented response helpers) remain supported without signature changes in `0.33`.
- Grouped behavior is additive and explicit via `execute_grouped(...)` and grouped response contracts.
- Scalar wrappers must reject grouped-only intent shapes with clear typed errors rather than silently coercing behavior.
- No implicit return-type switching is allowed for existing scalar methods.

## Optional 0.33 Additions
- storage metrics expansion
- cardinality estimation hooks
- planner warnings for high-cardinality grouping

## GROUP BY Contract Spec (Required Before Implementation)
Freeze one short contract spec before enabling grouped runtime:
- ordering guarantee (or explicit non-guarantee without `ORDER BY`)
- null and mixed-type grouping semantics
- group-key equality semantics
- memory-limit behavior and failure mode
- cursor resume semantics (`last_group_key` anchor + offset compatibility)
- grouped error taxonomy and boundary mapping

## Risk and Rollback
| Area | Risk | Rollback |
| --- | --- | --- |
| Planner variant split (`Scalar` vs `Grouped`) | High | Keep grouped planner branch gated and return explicit unsupported errors for grouped intents; do not coerce grouped into scalar fallback. |
| Grouped execution blocking path | High | Route grouped plans to explicit unsupported error while retaining planner contracts. |
| Grouped response surface | High | Keep grouped response type internal and adapt to scalar-safe faÃ§ade until downstream callers migrate. |
| Session grouped API rollout | Medium | Keep grouped API additive and disable by feature gate without changing scalar APIs. |
| Grouped cursor resume semantics | High | Keep grouped cursor behind explicit unsupported errors until `last_group_key` anchor semantics are complete and tested. |

## Additional Risk Areas
- Mixed `ORDER BY` + `GROUP BY` semantics must be explicitly documented (deterministic order vs explicitly unspecified without `ORDER BY`).
- Null and mixed-type grouping semantics must be fixed and test-covered (`NULL` grouping equality, coercion policy, unsupported field families).
- High-cardinality grouped plans must fail under configured limits before unbounded memory growth.
- Future grouped streaming/pushdown work must not proceed without explicit cardinality-aware planning policy.

## Implementation Sequence
1. Planner variant split
2. Response surface extension
3. Grouped execution path
4. Grouped cursor protocol
5. Session API extension

## Test Matrix by Phase
| Phase | Unit | Integration | Property | Upgrade |
| --- | --- | --- | --- | --- |
| Phase 1: planner variant | planner shape tests | query intent -> plan pipeline tests | grouped/scalar shape exclusivity checks | plan-serialization compatibility tests |
| Phase 2: response surface | response mapping tests | session response decoding tests | grouped/scalar response exclusivity checks | response contract compatibility tests |
| Phase 3: grouped execution | group-state reducer tests | grouped query end-to-end tests | insertion-order/group determinism tests | N/A |
| Phase 4: grouped cursor | token codec and validation tests | continuation paging tests | cursor resume invariants anchored by `last_group_key` | token compatibility fixtures |
| Phase 5: session API | API boundary tests | mixed scalar+grouped client flows | additive-surface invariants | client compatibility smoke tests |
