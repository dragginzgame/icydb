# 0.33 - Planner and GROUP BY Integration

## Theme
Wire grouping end-to-end using the stabilized substrate from `0.31` and `0.32`.

## Dependency Chain
- Input from `0.31`: canonical key/equality semantics and deterministic hashing.
- Input from `0.32`: unified aggregate state machine, typed error domains, and execution-shape model.
- Input from `0.32.3`: grouped-readiness scaffolding (internal handoff contracts, grouped error mapping scaffolding, observability schema lock-in, and grouped disabled-path guardrails).
- Output from `0.33`: first complete grouped planning/execution surface with explicit APIs.

## Objectives
### 1. Explicit `GroupPlan` Variant
Introduce:

```rust
pub struct GroupPlan {
    group_fields: Vec<FieldSlot>,
    aggregates: Vec<AggregateSpec>,
}
```

Planner must produce:

```rust
enum LogicalPlan {
    Scalar(...),
    Grouped(GroupPlan),
}
```

Requirements:
- No feature flags in plan shape.
- No optional grouped bits in scalar plan.
- Explicit grouped variant only.

Acceptance criteria:
- Planner emits `LogicalPlan::Grouped` for grouped intents.
- Scalar plans remain unchanged for non-grouped queries.
- No grouped execution path depends on scalar-only hidden flags.

### 2. Grouped Aggregate Execution
Use:
- `GroupKey`
- `AggregateFactory`
- `ExecutionShape::Blocking`
- `ExecutionBudget` tracking

Implement:
- in-memory hash map keyed by `GroupKey`
- per-group state application
- finalization into grouped result set

Acceptance criteria:
- Grouped queries execute through explicit blocking grouped path.
- Per-group aggregate state is isolated and deterministic.
- Grouped results are stable under insertion-order variation.

### 3. Grouped Cursor Protocol
Wire:
- `GroupedContinuationToken` encode/decode
- grouped page builder
- grouped revalidate path

Acceptance criteria:
- Grouped continuation tokens round-trip with signature/direction/offset checks.
- Grouped continuation resumes from correct group boundary.
- Dead grouped scaffolding is removed once real path is wired.

### 4. Response Surface Extension
Introduce grouped response type:

```rust
pub enum QueryResponse {
    Rows(Vec<Row>),
    GroupedRows(Vec<GroupedRow>),
}
```

Requirements:
- Do not overload scalar row response contracts.

Acceptance criteria:
- Grouped results are represented only by grouped response variant.
- Scalar query behavior and types remain stable.

### 5. Session API Extension
Add explicit grouped terminal API:

```rust
session.execute_grouped(...)
```

Requirements:
- Do not leak grouped behavior through scalar wrappers.

Acceptance criteria:
- Grouped execution is reachable through explicit grouped API only.
- Existing scalar aggregate wrappers keep current semantics.

## Migration Behavior for Existing Scalar APIs
- Existing scalar APIs (`execute`, scalar aggregate terminals, and row-oriented response helpers) remain supported without signature changes in `0.33`.
- Grouped behavior is additive and explicit via `execute_grouped(...)` and grouped response contracts.
- Scalar wrappers must reject grouped-only intent shapes with clear typed errors rather than silently coercing behavior.
- No implicit return-type switching is allowed for existing scalar methods.

## Optional 0.33 Additions
- storage metrics expansion
- cardinality estimation hooks
- planner warnings for high-cardinality grouping

## Risk and Rollback
| Area | Risk | Rollback |
| --- | --- | --- |
| Planner variant split (`Scalar` vs `Grouped`) | High | Keep grouped planner branch behind gated dispatch and preserve scalar planner as fallback path. |
| Grouped execution blocking path | High | Route grouped plans to explicit unsupported error while retaining planner contracts. |
| Grouped response surface | High | Keep grouped response type internal and adapt to scalar-safe faÃ§ade until downstream callers migrate. |
| Session grouped API rollout | Medium | Keep grouped API additive and disable by feature gate without changing scalar APIs. |

## Test Matrix by Phase
| Phase | Unit | Integration | Property | Upgrade |
| --- | --- | --- | --- | --- |
| Phase 1: planner variant | planner shape tests | query intent -> plan pipeline tests | grouped/scalar shape exclusivity checks | plan-serialization compatibility tests |
| Phase 2: grouped execution | group-state reducer tests | grouped query end-to-end tests | insertion-order/group determinism tests | N/A |
| Phase 3: grouped cursor | token codec and validation tests | continuation paging tests | cursor resume invariants | token compatibility fixtures |
| Phase 4: response surface | response mapping tests | session response decoding tests | grouped/scalar response exclusivity checks | response contract compatibility tests |
| Phase 5: session API | API boundary tests | mixed scalar+grouped client flows | additive-surface invariants | client compatibility smoke tests |
