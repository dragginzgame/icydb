# 0.19 — Mixed-Direction ORDER BY Support

## 1. Purpose

Introduce support for **mixed-direction ORDER BY clauses** while preserving:

* Deterministic ordering
* Strict monotonic composite key progression
* Cursor continuation correctness (single-anchor)
* No-duplicate / no-omission pagination guarantees
* Compatibility with 0.18 scan budgeting
* Streaming execution model

This milestone expands query expressiveness without:

* Changing storage formats
* Changing cursor token format
* Introducing cost-based planning
* Redesigning the execution substrate

---

## 2. Background

Currently, icyDB supports only **direction-uniform ORDER BY** clauses:

Valid:

```rust
ORDER BY tag ASC, id ASC
ORDER BY tag DESC, id DESC
```

Invalid (currently rejected or fallback-only):

```rust
ORDER BY tag ASC, id DESC
ORDER BY tag DESC, id ASC
```

The current execution model assumes a single `Direction` across all ordered fields.

0.19 generalizes ordering to allow **per-field direction** while preserving:

* Traversal-level monotonic guarantees
* Continuation anchor semantics
* Composite streaming correctness

---

## 3. Scope

### In Scope

* Mixed-direction ORDER BY for single-path access plans.
* Mixed-direction ORDER BY for composite plans (`Union`, `Intersection`).
* Correct comparator semantics for composite key comparison.
* Continuation correctness under mixed direction.
* Pagination correctness invariants preserved.
* DESC parity retained for direction-uniform cases.

### Out of Scope

* Cost-based reordering.
* Automatic index direction rewriting.
* Storage-level descending index components.
* Cursor binary format changes.
* Mixed-direction pushdown eligibility expansion (limited support only).
* Planner heuristics redesign.

---

## 4. Conceptual Model

### 4.1 Canonical Order Specification

Replace:

```rust
Direction::Asc | Direction::Desc
```

With:

```rust
struct OrderSpec {
    fields: Vec<(FieldName, OrderDirection)>
}
```

Where:

```rust
enum OrderDirection {
    Asc,
    Desc,
}
```

This already exists in planner-level representation.

0.19 ensures execution fully respects it.

---

### 4.2 Composite Key Comparator

Define comparison between two composite keys:

Given order spec:

```rust
ORDER BY f1 dir1, f2 dir2, ..., fn dirn
```

Comparison is lexicographic:

For each field `fi`:

* If values differ:

  * `Asc` → normal comparison
  * `Desc` → inverted comparison
* If equal → continue to next field

Final tie-break remains primary key field.

---

## 5. Execution Model Changes

### 5.1 OrderedKeyStream Monotonic Guarantee

Previously:

* Monotonicity enforced under single global direction.

Now:

* Monotonicity enforced under composite comparator.

Replace:

```rust
validate_stream_direction(previous, current, direction)
```

With:

```rust
validate_stream_comparator(previous, current, comparator)
```

Comparator is derived from full OrderSpec.

---

### 5.2 Continuation Anchor Semantics

Anchor remains:

> The last emitted RawDataKey.

Resume rule becomes:

* Exclude anchor under composite comparator semantics.

Instead of:

```rust
Bound::Excluded(anchor) in ASC or DESC space
```

It becomes:

> Resume where composite_compare(key, anchor) is strictly greater than 0.

Conceptually unchanged:

* Still single anchor.
* Still strict exclusion.
* Still traversal-level.

---

### 5.3 Traversal Direction Handling

Traversal layer currently takes a single `Direction`.

Under mixed ordering:

* Traversal direction is determined by the first ordered field.
* Remaining fields affect comparator logic only.

Example:

```rust
ORDER BY tag ASC, id DESC
```

Traversal direction = Asc (based on first field).

Traversal envelope logic remains unchanged.

Comparator enforces second-field descending ordering within equal tag groups.

This preserves raw-key traversal monotonicity.

---

## 6. Pushdown Semantics

### 6.1 Single-Path Pushdown

Pushdown remains eligible only if:

* ORDER BY fields align with index order.
* Index supports the same per-field direction pattern.

For 0.19:

* Mixed-direction pushdown is supported only if index field ordering matches requested direction exactly.
* Otherwise fallback execution path applies.

No automatic direction rewriting.

---

### 6.2 Composite Plans

Union and Intersection streams rely only on comparator logic.

Mixed-direction support requires:

* Replace direction-based head selection with comparator-based selection.
* Replace direction-based alignment with comparator-based alignment.

Example:

Union step becomes:

```rust
select next key with minimal composite comparator value
```

Intersection alignment uses:

```rust
advance lagging streams based on composite comparator
```

Permutation invariance must remain intact.

---

## 7. Pagination Contract (Unchanged Semantics)

Phase order remains:

1. Build globally ordered composite stream.
2. Apply anchor exclusion.
3. Apply offset.
4. Apply limit.
5. Derive continuation from last emitted key.

Budgeting (0.18) remains outer-boundary only.

Mixed direction must not change page boundaries relative to unbounded execution.

---

## 8. Correctness Invariants (Extended)

0.19 must preserve all existing invariants, plus:

### 8.1 Comparator Stability

Comparator must be:

* Total
* Deterministic
* Transitive
* Consistent with equality

### 8.2 Mixed-Direction Stability

Given:

```rust
ORDER BY f1 ASC, f2 DESC
```

Results must satisfy:

* Grouped by f1 ascending
* Within equal f1 groups, f2 descending
* Primary key tie-break remains canonical

### 8.3 Continuation Under Mixed Ordering

Across pages:

* No duplication
* No omission
* Strict forward progression under composite comparator

---

## 9. Testing Matrix

Each case tested for:

* ASC-only (baseline)
* DESC-only (baseline)
* Mixed-direction

### Single Path

* ORDER BY f1 ASC, id DESC
* ORDER BY f1 DESC, id ASC
* Three-field composite ordering

### Pagination

* Page sizes 1, 2, >2
* Resume from every boundary
* Verify no dup/no omission

### Composite Plans

Union:

* Mixed ordering with overlap
* Mixed ordering with page-boundary overlap

Intersection:

* Mixed ordering with zig-zag alignment
* Mixed ordering at boundary

### Parity

* Unbounded vs paged equivalence
* Budgeted vs fallback equivalence

---

## 10. Implementation Plan

1. Introduce comparator abstraction derived from OrderSpec.
2. Replace Direction-based comparisons in:

   * MergeOrderedKeyStream
   * IntersectOrderedKeyStream
   * PK stream
   * Secondary index stream
3. Replace direction-based monotonicity validation with comparator-based validation.
4. Adjust continuation resume checks to use comparator.
5. Expand pushdown eligibility logic for mixed-direction exact-match cases.
6. Add full test matrix.
7. Run entire 0.12–0.18 regression suite unchanged.

---

## 11. Risk Assessment

Primary risks:

* Incorrect comparator transitivity.
* Continuation exclusion bug under composite comparator.
* Budget boundary miscalculation.
* Composite alignment misstep under mixed comparator.

Mitigation:

* Strict comparator unit tests.
* Exhaustive pagination matrix.
* Explicit transitivity tests.
* Cross-validation against materialized sort baseline.

---

## 12. Success Criteria

0.19 is complete when:

* Mixed-direction ORDER BY executes correctly.
* Pagination invariants hold under mixed direction.
* Composite plans behave identically under child permutation.
* No regressions in 0.12–0.18 tests.
* Pushdown fallback remains correct when mixed pushdown unsupported.

---

## 13. Architectural Principle

> Ordering semantics belong to a comparator, not a global direction.

0.19 replaces direction-centric logic with comparator-centric logic while preserving the streaming execution substrate.

---

# Summary

0.19 expands icyDB’s ORDER BY expressiveness to support mixed-direction ordering while preserving:

* Streaming execution
* Single-anchor continuation
* Budget safety
* Composite determinism
* Strict monotonic pagination guarantees

