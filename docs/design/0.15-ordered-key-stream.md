# 0.15 – Ordered Key Stream Abstraction (Internal)

## Status

Proposed

## Purpose

Introduce a unified internal abstraction for ordered key production in load execution.

This abstraction replaces direct `Vec<DataKey>` returns from access paths with a pull-based stream model.

This phase:

* Does not change query semantics
* Does not move continuation logic
* Does not move limit logic
* Does not change public APIs
* Does not introduce streaming at the boundary

It is a structural internal abstraction only.

---

# 1. Motivation

After 0.14.2 execution phase alignment, all load paths follow:

```
AccessPath
→ produce ordered DataKeys
→ rows_from_ordered_data_keys
→ deserialize_rows
→ post-access (cursor / limit / offset)
```

However:

* Each access path still returns `Vec<DataKey>`
* Key production is materialized eagerly
* Executor must assume full collection before post-access phases
* Composite access trees (Union / Intersection) would require merging Vecs

We want traversal to be composable before materialization.

---

# 2. Design Principles

## 2.1 Minimal Disruption

0.15 does not relocate responsibility.

Continuation handling remains in:

* cursor spine
* executor post-access phase

Limit remains in:

* executor layer
* pushdown eligibility paths

Iterator layer does not own pagination semantics yet.

## 2.2 Keys Only

OrderedKeyStream produces:

```
DataKey
```

It does not:

* Fetch rows
* Deserialize entities
* Apply filters
* Enforce cursor
* Apply limit
* Emit metrics

## 2.3 Preserve Existing Invariants

All ordering invariants remain enforced at:

* Raw key ordering
* Existing monotonicity checks
* Existing continuation validation

The stream abstraction must not introduce new invariant enforcement in 0.15.

---

# 3. Core Abstraction

```rust
pub(crate) trait OrderedKeyStream {
    fn next_key(&mut self) -> Result<Option<DataKey>, InternalError>;
}
```

Properties:

* Pull-based
* Fallible
* Ordered
* Deterministic

No additional methods in 0.15.

---

# 4. Initial Implementations

Wrap existing key-producing logic:

* PK fast path
* Secondary index fast path
* IndexRange fast path
* Fallback access path

Initial implementation may internally hold:

```
Vec<DataKey>
index: usize
```

Streaming laziness is optional in 0.15.

The goal is unification, not laziness.

---

# 5. Executor Integration

Current model:

```
let keys: Vec<DataKey> = access_path.collect_keys(...);
let rows = rows_from_ordered_data_keys(keys);
```

New model:

```
let mut stream = access_path.produce_key_stream(...);

let mut keys = Vec::new();
while let Some(key) = stream.next_key()? {
    keys.push(key);
}

let rows = rows_from_ordered_data_keys(keys);
```

Note:

* Public behavior remains identical.
* Post-access logic remains unchanged.
* finalize_path_outcome remains unchanged.

---

# 6. What 0.15 Does NOT Do

This phase does NOT:

* Move continuation rewrite into stream
* Move limit truncation into stream
* Remove executor-level boundary filtering
* Change pushdown eligibility logic
* Introduce async
* Introduce public streaming
* Introduce composite plans

Those belong to later milestones.

---

# 7. Why This Is Safe

Because:

* It is an internal mechanical refactor
* It does not move semantic responsibility
* It preserves all invariant enforcement locations
* Existing tests remain valid

Risk surface is low.

---

# 8. Completion Criteria

All must hold:

* No access path returns Vec<DataKey> directly
* All load paths produce OrderedKeyStream
* Executor consumes stream
* All 0.14 continuation tests pass
* All DESC tests pass
* All limit pushdown tests pass
* No explain output changes
* No metrics changes

---

# 9. Architectural Impact

After 0.15:

* Key production is unified
* Executor logic becomes stream-friendly
* Union can be implemented as stream merge
* Intersection can be implemented as synchronized advancement
* Limit pushdown becomes stream-short-circuitable

But semantic relocation remains deferred.

---

# 10. Next Milestones (Future)

0.16 – Stream-Level Limit & Continuation
0.17 – AccessPath::Union
0.18 – Intersection
0.19 – Memory-bounded execution

---

# Architectural Principle

> 0.15 introduces a structural abstraction only.
> It does not relocate semantic responsibility.

Traversal remains a producer.
Executor remains semantic owner.
