# 0.13 — LIMIT Pushdown for IndexRange (Single-Path)

## 1. Purpose

Introduce store-level LIMIT pushdown for `AccessPath::IndexRange` (single-path only), allowing early termination of range scans once the requested limit is satisfied.

This improves:

* Execution efficiency
* Memory usage
* Pagination stability under large ranges

This phase does **not** introduce:

* Composite access tree pushdown
* DESC traversal pushdown
* Cost-based planning
* Query reordering
* Cursor format changes

---

## 2. Motivation

Current execution model:

1. Construct composite bounds.
2. Perform full BTree range traversal.
3. Collect all matching `DataKey`s.
4. Apply `LIMIT` at executor layer.

This may:

* Traverse thousands of entries unnecessarily.
* Allocate large intermediate vectors.
* Increase CPU and memory usage.

For ordered IndexRange queries:

Traversal order matches output order.

Therefore:

> The store can stop scanning once `limit` items have been collected.

This is safe for single-path access plans.

---

## 3. Scope

### In Scope

* `AccessPath::IndexRange`
* Forward traversal only
* Single-path logical plans
* Limit provided at executor layer

### Out of Scope

* `Union`
* `Intersection`
* PK `KeyRange`
* FullScan
* DESC support
* Composite pagination interactions

---

## 4. Correctness Guarantees

Pushdown must preserve:

1. Ordering correctness.
2. No duplication.
3. No omission within requested page.
4. Cursor continuation correctness (0.12 semantics).
5. Deterministic execution.

Pushdown must not:

* Change which items are returned.
* Alter canonical plan fingerprint.
* Affect pagination boundary logic.

---

## 5. High-Level Design

Instead of:

```rust
let candidates = store.resolve_data_values_in_range(...)?;
let page = candidates.into_iter().take(limit).collect();
```

We introduce:

```rust
let candidates = store.resolve_data_values_in_range_limited(..., limit)?;
```

Store traversal becomes:

```rust
for entry in entry_map.range(bounds) {
    collect entry
    if collected == limit:
        break
}
```

Traversal stops immediately when limit reached.

---

## 6. Store API Changes

Add new method:

```rust
pub(crate) fn resolve_data_values_in_range_limited<E: EntityKind>(
    &self,
    index: &IndexModel,
    prefix: &[Value],
    lower: &Bound<Value>,
    upper: &Bound<Value>,
    limit: usize,
) -> Result<Vec<IndexHit>, InternalError>
```

Where:

```rust
struct IndexHit {
    raw_key: RawIndexKey,
    data_key: DataKey,
}
```

Notes:

* RawIndexKey required for pagination continuation.
* Existing unlimited resolver may remain for internal usage.

---

## 7. Executor Changes

Executor must:

1. Detect when `LIMIT` is present.
2. Call limited resolver.
3. Stop at store layer.
4. Capture last raw key for cursor (0.12 model).

Cursor logic remains unchanged.

---

## 8. Interaction With Pagination

Pagination model (0.12) already:

* Anchors at `RawIndexKey`.
* Resumes from `Bound::Excluded(last_raw_key)`.

Limit pushdown integrates cleanly because:

* Last emitted key remains correct anchor.
* Early stop does not change ordering.
* Continuation semantics unchanged.

---

## 9. Edge Cases

### Case A — limit == 0

Return empty result immediately.

No store traversal.

---

### Case B — limit > result set size

Traversal exhausts naturally.

No cursor returned.

---

### Case C — boundary stop at group edge

If stop occurs at middle of component group:

Continuation must resume correctly from last raw key.

---

### Case D — limit = 1

Ensure no off-by-one duplication on continuation.

---

## 10. Invariants

### Invariant 1 — Strict Ordering

Store traversal order must equal BTree lexicographic order.

Pushdown must not reorder.

---

### Invariant 2 — Cursor Anchor Validity

Last raw key collected is always:

```
last_emitted_raw_key
```

Never pre-fetched key.

---

### Invariant 3 — Bound Respect

Pushdown must never expand bounds.

---

## 11. Performance Considerations

Benefits:

* Early termination.
* Reduced CPU for large scans.
* Reduced allocation pressure.
* Improved latency for large ranges.

Trade-offs:

* Slight API widening.
* Additional code path for limited vs unlimited.

---

## 12. Testing Requirements

### Functional Tests

* limit = 1
* limit = N
* limit exactly equals result size
* limit larger than result size
* boundary inclusive/exclusive cases
* continuation after limited page
* continuation after multi-page traversal

### Equivalence Test

For various queries:

```
unbounded_result == paginated_collect_all(limit = k)
```

For multiple k values.

---

## 13. Success Criteria

* Store traversal stops once limit reached.
* No semantic difference in returned items.
* Pagination continuation unchanged.
* No duplication across pages.
* No omission across pages.
* All boundary edge tests pass.

---

## 14. Future Extensions

* Pushdown for PK KeyRange
* Pushdown for DESC traversal
* Pushdown for composite access trees
* Adaptive limit selection
* Cost-based pushdown decisions

---

## 15. Architectural Principle

Limit pushdown is:

> An execution optimization that preserves semantics.

It does not:

> Change plan identity or logical query meaning.

This phase strengthens execution efficiency without increasing semantic complexity.

---

# Why This Is the Right 0.13

* Safe.
* Localized change.
* No schema contract commitment.
* Strengthens pagination infrastructure.
* Prepares engine for composite tree pagination later.

