# 0.28 - Field Value Projection Terminals

## 1) Decision

`0.28.0` introduces a small, user-visible projection feature before `group_by`:

- a load terminal that returns projected field values directly from the effective query window

Primary terminal:

- `values_by(field) -> Vec<Value>`

`0.28.0` recommendation:

- ship only `values_by(field)`
- keep `0.28.0` structural (projection mechanics), not ergonomic expansion
- stabilize projection semantics first, type ergonomics second

This is intentionally scoped to be lower risk than `group_by` while building directly on slot-based field projection work from `0.26`.

---

## 2) Why `0.28` Exists

Current queries expose:

- full-row execution (`execute`)
- aggregate terminals (`count`, `min_by`, `avg_by`, `count_distinct_by`, etc.)

But there is no direct terminal for "give me one field for all matching rows".

Today that requires:

1. loading full entities
2. manually mapping the field in app code

`0.28` adds a first-class field-projection terminal to remove that boilerplate and set up a safe bridge toward future grouped/value analytics.

---

## 3) Scope

### In Scope (`0.28.0`)

- Add one new load terminal:
  - `values_by(field)` returning projected values in query result order
- Reuse existing planning and execution route boundaries (no new query mode)
- Resolve target field once to a stable slot index at terminal setup
- Implement projection lowering behind one reusable projection core
- Preserve all existing filtering/order/distinct/window semantics
- Keep classification and fallback behavior explicit

### Out of Scope (`0.28.0`)

- `group_by`
- paged value-projection terminals and cursor continuation redesign
- planner cost-model redesign
- new aggregate operator families
- partial row decode / columnar storage redesign
- projection-aware continuation signatures (currently signature projection marker is full-row)
- ergonomic terminal expansion (`first_value_by`, `last_value_by`, `values_by_with_ids`)
- freezing typed/generic projection signatures for public API

---

## 4) API Shape (Proposed)

```rust
impl<'a, E> FluentLoadQuery<'a, E>
where
    E: EntityKind + EntityValue,
{
    pub fn values_by(&self, field: impl AsRef<str>) -> Result<Vec<Value>, QueryError>;
}
```

Notes:

- This is a non-paged terminal, same model as existing aggregate terminals.
- Cursor tokens on this terminal remain invalid (`CursorRequiresPagedExecution`).
- Return type is intentionally untyped (`Value`) for the first release.
- Naming intentionally follows terminal vocabulary (`count`, `min_by`, `count_distinct_by`) instead of adding a separate projection DSL.
- `0.28.0` must not lock a generic typed projection signature yet; typed wrappers are a follow-up once projection semantics are stable.

---

## 5) Semantics Contract

`values_by(field)` is defined as:

- run the same logical query as `execute()` (same predicate/access/order/distinct/window behavior)
- project `field` from each row in that effective window
- return projected values in the exact response row order

Execution-phase position:

- projection observes entity state only after canonical load row selection is finalized
- this includes post-access filtering, row-level DISTINCT application, and effective window application
- projection is not allowed to run on raw key streams before final row selection

Deterministic projection identity invariant:

- projection identity is defined by resolved slot index, not runtime field-name lookup
- runtime projection loops must not fall back to string-based field lookup
- projection semantics are anchored to schema slot-order invariants

Parity identity:

```text
values_by(field) == execute()?.rows().map(project(field))
```

where `project(field)` uses slot-based runtime projection, not string lookup in execution loops.

### Window, DISTINCT, and Order

- `offset`/`limit` semantics are inherited from the existing effective window.
- Query-level `distinct` is applied exactly as it is for normal load execution before terminal projection.
- Query-level `DISTINCT` remains row-level (key/row dedup), not value-level dedup.
- `load(...).distinct().values_by("field")` is not equivalent to `distinct_values_by("field")`.
- distinct rows may still yield identical projected values; duplicate values in `values_by(field)` output are valid.
- Returned values preserve row order from the effective window.

### Empty Result

- Empty effective window returns `Ok(vec![])`.

### Null / Missing / Sparse Field Semantics

- projection returns the same `Value` representation that full-row execution exposes for that field
- nullable/optional/sparse outcomes follow existing entity projection semantics
- when applicable, `Null` (or equivalent sentinel representation) is preserved exactly as exposed by full-row execution

---

## 6) Validation and Error Contract

At terminal setup:

- field name must resolve to a schema field
- unresolved field is rejected before scan work

Error behavior:

- unknown field remains a typed `Unsupported` user-facing query failure
- execution/storage/corruption/internal failures remain in existing classes
- no string-matched error assertions in tests

Implementation should reuse existing slot resolution boundaries already used by field aggregates (for example `resolve_any_aggregate_target_slot`-style helpers).

---

## 7) Execution Design

No new planner/executor mode is introduced.

Execution flow:

1. Validate non-paged terminal intent.
2. Resolve target field to stable slot index once.
3. Execute existing load plan through canonical route/fast-path/fallback pipeline.
4. Project each returned entity via `get_value_by_index(slot.index)`.
5. Return `Vec<Value>`.

Important boundary:

- Route ownership does not change in `0.28`.
- `values_by` is a terminal projection step after canonical row selection.
- `0.28.0` does not introduce partial row decode or projection pushdown; full entity materialization behavior stays unchanged.
- `values_by` must not introduce new fast-path branches or bypass canonical resolver ownership.

Internal lowering contract:

1. Introduce one projection core that accepts resolved projection specs.
   Shape target: `ProjectionSpec { slots: SmallVec<[SlotIndex; N]> }` (single-slot in `0.28.0`, multi-slot-ready by design).
2. Lower `values_by(field)` through that projection core, not through a dedicated one-off path.
3. Keep projection core output/value semantics stable (`Value`-based) for `0.28.0`.
4. Ensure the same projection core can be extended for:
   - typed projection wrappers in `0.29+`
   - multi-field projection terminals reusing the same lowering and execution phases
5. Keep projection core in executor-level shared infrastructure, not load-only helpers, so grouped/value terminals can reuse it later.

---

## 8) Testing Requirements

Minimum test matrix:

1. Parity:
- `values_by(field)` equals baseline `execute()` + field projection mapping.

2. Ordering and direction:
- ASC/DESC order parity over projected values.

3. Window behavior:
- offset-only, limit-only, and offset+limit parity.

4. DISTINCT interaction:
- parity with query-level `distinct` enabled and disabled.

5. Access-path coverage:
- full scan, key range, index prefix/range, and composite plans where applicable.

5a. Composite-plan parity:
- explicit union/intersection projection parity tests must assert stable ordering and unchanged projection output versus `execute()` baseline mapping.

6. Validation:
- unknown field fails before scan-budget consumption.

7. Cursor contract:
- cursor token on `values_by` is rejected in non-paged terminal mode.

8. Scan-budget parity:
- for the same logical query, `values_by(field)` must not alter scan-budget consumption relative to `execute()` baseline.
- parity is measured at the physical key-stream boundary (keys scanned / scan-budget accounting), not post-materialization row counts.

---

## 9) Rollout Plan

Phase 1 (`0.28.0`):

- ship `values_by(field)` with parity-first semantics
- no routing changes and no pushdown-specific optimization requirements

Phase 2 (`0.28.x` follow-up, optional):

- add ergonomic value terminals (`first_value_by`, `last_value_by`) only after `values_by` semantics are locked
- add `distinct_values_by(field)` as a value-returning counterpart to `count_distinct_by`
- add `values_by_with_ids(field) -> Vec<(Id<E>, Value)>` if users need stable id/value pairing without re-zipping app-side
- evaluate small-window projection shortcuts only after parity locks

Phase 3 (`0.29+`, future minor):

- add typed projection wrappers layered on the same projection core
- consider multi-field projection terminals that reuse the same lowering model

Phase 4 (future minor):

- evaluate grouped/value analytics (`group_by`) on top of proven value projection semantics

### Distinct Projection Release Gate

`distinct_values_by(field)` should ship in `0.28.0` only if all of the following are true:

1. DISTINCT behavior is comparator-driven and stable at the key-stream layer.
2. Distinct projection output is backed by canonical ordering contracts.
3. Pushdown/scan-budget invariants are preserved for any optimization path used by the terminal.

Current recommendation:

- defer `distinct_values_by(field)` from `0.28.0`
- keep it explicitly targeted for `0.28.x`

Rationale:

- query-level DISTINCT is already comparator-driven at the ordered-key stream boundary (`DistinctOrderedKeyStream` + `KeyOrderComparator`)
- `count_distinct_by` already proves effective-window field-distinct semantics using typed value equality
- a dedicated projection-distinct terminal still needs its own parity + ordering + scan-invariant lock before inclusion in the structural `0.28.0` cut

### Group-By Readiness Checks

`0.28` projection groundwork is considered group-by-ready only when:

1. projection core is independent of terminal classification
2. projection does not alter ordering guarantees
3. slot resolution remains deterministic and side-effect-free

---

## 10) Risks and Mitigation

Risks:

- subtle semantic drift versus `execute()` result ordering/window behavior
- field-slot resolution drift versus schema order invariants
- accidental introduction of alternate routing/projection paths

Mitigations:

- treat `execute()` parity as the primary contract
- enforce slot-resolution-at-setup only
- keep one canonical load execution path and perform projection only at terminal boundary

---

## 11) Release Gate

`0.28.0` is valid when:

1. `values_by(field)` is publicly available.
2. Parity matrix passes against `execute()` projection baseline.
3. Cursor/terminal intent boundaries are preserved.
4. No planner/routing contract regressions are introduced.
5. Scan-budget consumption remains parity-stable versus `execute()` for equivalent logical queries.
