# 0.35 — GROUP BY & Aggregation Pipeline

## Status

Draft — Architectural Design
Target: 0.35
Scope: Structural GROUP BY support with deterministic semantics and strict layering
Prerequisite: `0.30` execution-kernel consolidation is complete

---

# 1. Objective

Introduce `GROUP BY` support to the query engine while preserving:

* Strict layering between query, plan, executor, and storage
* Deterministic ordering guarantees
* Streaming-first execution when possible
* Conservative index pushdown
* No storage-layer semantic leakage

This document defines:

1. The logical model
2. Planner extensions
3. Execution modes
4. Pushdown eligibility rules
5. Index interaction model
6. Refactor requirements
7. Invariants and constraints

---

# 2. Non-Goals (0.35)

The following are explicitly **out of scope** for 0.35:

* HAVING clause
* Window functions
* Nested groupings
* Arbitrary expression grouping
* Multi-stage aggregation pipelines
* User-defined aggregates
* Partial distributed aggregation
* Storage-layer aggregation pushdown

0.35 introduces **structural grouping only**.

---

# 3. Logical Model

## 3.1 Query Shape

Extend `LogicalPlan` with:

```rust
pub struct AggregatePlan {
    pub aggregates: Vec<AggregateSpec>,
}

pub struct GroupByPlan {
    pub group_fields: Vec<String>,
}
```

Use struct-based plan extension (not enum variants):

```rust
pub(crate) struct LogicalPlan<K> {
    // existing fields...
    pub(crate) aggregate: Option<AggregatePlan>,
    pub(crate) group_by: Option<GroupByPlan>,
}
```

New logical stage:

```
Load
  → Filter (optional)
  → GroupBy (optional partitioning)
  → Aggregate (global or per group)
```

Constraints:

* Group fields must be scalar fields.
* Group fields must be orderable.
* Group field list must not be empty.
* Aggregates must be deterministic.
* Grouping and aggregation remain orthogonal contracts:
  * `group_by` defines partitioning.
  * `aggregate` defines reduction terminals.

---

## 3.2 Output Contract

Grouped queries return one row per group with a deterministic projection shape:

```rust
pub struct GroupedRow {
    pub key: Vec<Value>,           // group_fields in declared order
    pub aggregates: Vec<Value>,    // aggregate outputs in declared order
}
```

Validation rule:

All non-aggregated projected fields must appear in `group_fields`.

No implicit projection widening is allowed.

---

# 4. Aggregate Model

Use existing `AggregateSpec`, extended to support grouped context.

Ownership rule:

* `AggregatePlan` owns aggregate terminal declarations.
* `GroupByPlan` does not own aggregate declarations.

Allowed aggregates in 0.35:

* COUNT
* SUM
* MIN
* MAX
* FIRST
* LAST

Optional (if already implemented safely):

* AVG (derived from SUM + COUNT)

Not allowed:

* DISTINCT aggregates (unless already stable)
* Text aggregates
* Nested aggregates

`FIRST` / `LAST` semantics in 0.35:

* Evaluated against canonical input order for each group.
* Canonical input order is the executor row order after filter, then stable order contract.
* Planner may mark streaming eligibility, but executor must re-validate ordered-stream invariants at runtime.
* Streaming `FIRST` / `LAST` requires an explicit `ordered_by(group_fields + stable suffix)` access-path contract.
* If canonical order is not guaranteed, executor must reject streaming `FIRST` / `LAST` and force deterministic materialized ordering before finalize.

---

# 5. Planner Changes

## 5.1 LogicalPlan

Add:

```rust
LogicalPlan {
  // ...
  aggregate: Option<AggregatePlan>,
  group_by: Option<GroupByPlan>
}
```

This must remain **purely declarative**:

* No slot references
* No index component indices
* No execution flags
* No `GroupExecutionMode` or executor strategy metadata

---

## 5.2 Validation

Validation must ensure:

* Group fields exist in schema
* Group fields are not map types
* Aggregate fields are valid
* No illegal mixing of grouped and non-grouped fields

Rule:

All non-aggregated projected fields must appear in `group_fields`.

---

## 5.3 Access Planning

Access planning must:

* Determine if a covering index exists for:

  * (`group_fields` + aggregate dependency fields)

* Emit explicit ordered-stream guarantees, not inferred hints:

  * `ordered_by` field sequence
  * scan direction
  * stable suffix ownership

If index ordering matches:

```
(group_fields..., [optional stable suffix such as primary_key])
```

Then streaming group aggregation may be possible.

Otherwise fallback to materialized grouping.

---

# 6. Execution Model

Two execution modes:

```rust
enum GroupExecutionMode {
    Streaming,
    Materialized,
}
```

Boundary rule:

* `GroupExecutionMode` is executor-owned and derived from access/route contracts.
* It must not appear in logical planning structures or persisted planning contracts.

---

## 6.1 Streaming Mode

Allowed when:

* AccessPath explicitly guarantees `ordered_by(group_fields + stable suffix)`.
* No residual predicate requiring post-fetch filtering.
* Aggregate functions are streaming-compatible.
* Scan direction is `Forward` for 0.35 grouped streaming support.

Execution strategy:

```
Iterate ordered rows
→ Detect group boundary
→ Maintain per-group fold state
→ Emit group result
```

Memory:

O(1) per group (rolling window only)

Safety invariant:

* Executor performs final streaming eligibility validation.
* Planner eligibility is advisory, not authoritative.

---

## 6.2 Materialized Mode

Fallback when:

* No ordering guarantee
* Composite residual predicates
* Non-streamable aggregates

Execution strategy:

```
Scan rows
→ HashMap<encoded_group_key_bytes, AggregateState>
→ Finalize groups
→ Sort output using the same group-key comparator used by streaming boundary detection
```

Memory:

O(number_of_groups)

---

# 7. Deterministic Ordering Contract

Output ordering must be deterministic.

Default rule:

* Output ordered by `group_fields` ascending in declared order.
* Sorting must use the exact comparator used by ordered stream grouping boundary detection.
* Hash-map iteration order is never observable output order.
* Encoded-byte ordering may be used only when it is documented as equivalent to the canonical group comparator.
* Primary key is not a grouped-output tie-break unless explicitly part of the group key.

Even in materialized mode, final output must be sorted to maintain determinism.

No undefined ordering allowed.

---

# 8. Predicate Interaction

Predicates apply before grouping.

Pipeline:

```
Scan
→ Filter
→ Group
→ Aggregate
```

HAVING not supported in 0.35.

---

# 9. Index Interaction Model

Index pushdown for grouping is limited in 0.35.

Allowed:

* Ordered scan if index prefix matches group_fields.

Not allowed:

* Storage-level grouped aggregation.
* Index-only grouped aggregate execution in 0.35.

---

# 10. Slot Resolution

Slot resolution must:

* Resolve group_fields to slots
* Resolve aggregate field dependencies to slots

This must occur in a dedicated lowering stage:

```
GroupByPlan + AggregatePlan
  → ResolvedGroupByPlan
```

Ownership boundary:

* `ResolvedGroupByPlan` belongs under query planning lowering (for example `query/plan/lower`).
* Slot resolution is not executor `load` ownership.

Resolved version may include:

```rust
pub struct ResolvedGroupByPlan {
    pub group_slots: Vec<usize>,
    pub aggregate_slots: Vec<usize>,
}
```

Must not leak into LogicalPlan.

---

# 11. Executor Integration

Group execution must live in:

```
db/executor/load/aggregate/group.rs
```

NOT inside:

* query
* index
* storage

Planner produces a contract.
Executor performs grouping.

---

# 12. Refactor Prerequisites

Before implementing GROUP BY, ensure:

1. `query/plan` does not construct physical key streams.
2. Routing logic is isolated from logical planning.
3. Aggregate folding logic is reusable outside single-result context.
4. A shared aggregate fold core exists, while scalar and grouped fold drivers remain separate.
5. Predicate subsystem split (`resolve`, `runtime`, `index_compile`) is complete.

If any of these are not true, refactor first.

Current readiness snapshot (2026-02-28):

1. Achieved: `query/plan` no longer constructs physical key streams.
2. Achieved: routing logic has been isolated from logical planning contracts.
3. Achieved: aggregate folding contracts are reusable outside single-result context.
4. Partial: grouped execution remains materialized-first; scalar and grouped fold drivers are not identical.
5. Achieved: predicate subsystem split (`resolve`, `runtime`, `index_compile`) is complete.

Readiness decision for 0.35 start: proceed now with grouped implementation, keeping grouped materialized execution as the first milestone while extracting a shared aggregate fold core (not a flag-driven scalar/grouped fold driver merge) as part of 0.35 execution work.

---

# 13. Required Module Additions

New files:

```
query/plan/group.rs
executor/load/aggregate/group.rs
```

Baseline already in place:

```
predicate/
  eval/
    resolve.rs
    runtime.rs
    index_compile.rs
```

Group by increases planner complexity; keep this split as an enforced prerequisite.

---

# 14. Invariants

Must hold true after implementation:

* Query layer does not depend on executor internals.
* Executor does not depend on logical AST.
* Index layer does not depend on group logic.
* Streaming grouping does not allocate per-row structures.
* Materialized grouping always sorts output.

---

# 15. Edge Case Handling

### Empty result set

Return empty group list.

### NULL group field

NULL must be a valid grouping key.

All NULL values collapse into same group.

### Missing field

Missing and NULL are distinct grouping keys.

* `Missing` groups together.
* `NULL` groups together.
* `Missing != NULL`.

Deterministic ordering for key comparison:

`Missing < NULL < Present(value)` using canonical value ordering for `Present(value)`.

Comparator alignment rule:

* Group-key comparison semantics must be shared across:
  * ordered-stream boundary detection
  * materialized-mode final sort
  * index key ordering contracts
  * grouped fingerprint/equality ownership boundaries
* New ad-hoc group comparators are prohibited.

---

# 16. Performance Expectations

Streaming mode:

* O(n) scan
* O(1) per group memory

Materialized mode:

* O(n) scan
* O(g) memory
* O(g log g) final sort

Where g = number of groups.

---

# 17. Future Extensions (Post-0.35)

* HAVING clause
* Index-level aggregate pushdown
* DISTINCT aggregates
* Composite grouping optimizations
* Parallel grouping
* Partial streaming grouping with bounded buffers

---

# 18. Success Criteria

GROUP BY is complete when:

* LogicalPlan supports grouping.
* Validation enforces group correctness.
* Streaming mode works on ordered index scans.
* Materialized mode works on full scans.
* Output ordering deterministic.
* All existing tests pass.
* No new layering violations introduced.

---

# 19. Architecture Score Target

After 0.35, the query engine should achieve:

```
Layering Integrity ≥ 9/10
```

GROUP BY must not reduce architectural clarity.
