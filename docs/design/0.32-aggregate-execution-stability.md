# 0.32.x - Aggregate State and Execution Core Stabilization

## Theme
Unify aggregate execution mechanics, lock DISTINCT semantic boundaries, and
prepare grouped planner/executor boundaries for `0.33`.

## Scope
Still no public `GROUP BY` behavior, but add explicit SQL-like projection DISTINCT planning.

## Dependency Chain
- Input from `0.31`: deterministic key/equality substrate and stable hash semantics.
- Output to `0.33`: planner/grouped execution can rely on one aggregate state engine,
  explicit execution-shape contracts, clear row-identity vs value-equality DISTINCT semantics,
  and pre-wired grouped boundary/readiness contracts from late `0.32.x`.

## Objectives
### 1. Aggregate State Machine Unification
Introduce:

```rust
pub trait AggregateState {
    fn apply(&mut self, row: &Entity) -> Result<(), AggregateError>;
    fn finalize(self) -> Value;
}

pub trait AggregateFactory {
    fn create(&self) -> Box<dyn AggregateState>;
}
```

Requirements:
- Fold/kernel split collapses into one state pipeline.
- All scalar aggregates use the same state flow.
- `AggregateSpec` is canonical normal form.
- No executor-owned rewrites of `AggregateSpec`.

Acceptance criteria:
- Scalar aggregate terminals instantiate states through one factory boundary.
- No alternate reducer state machines remain in parallel paths.
- `AggregateSpec` translation happens once at boundary entry.

### 2. Error Domain Segmentation
Introduce explicit domains:
- `AggregateError`
- `GroupError`
- `KeyCanonicalError`

Requirements:
- Stop overloading `PlanError`/`InternalError` for aggregate-domain failures.

Acceptance criteria:
- Aggregate/group domain failures are emitted as typed domain errors.
- Boundary mapping into user-facing errors is explicit and one-way.

### 3. Execution Shape Model
Introduce:

```rust
pub enum ExecutionShape {
    Streaming,
    Blocking,
}
```

Requirements:
- Use shape model for scalar aggregate classification.
- Keep grouped blocking behavior disabled in this release.

Acceptance criteria:
- Scalar routes classify via `ExecutionShape` rather than ad-hoc branching.
- Grouped blocking path remains non-executable in production routing.

### 4. Executor Memory Budget Skeleton
Introduce:

```rust
pub struct ExecutionBudget {
    memory_bytes: u64,
    row_count: u64,
}
```

Requirements:
- Track budget signals in aggregate execution.
- No hard enforcement yet.

Acceptance criteria:
- Budget counters are emitted/updated in aggregate execution paths.
- No behavior changes are caused by budget tracking alone.

### 5. Secondary ORDER Pushdown Matrix Unification
- Keep one canonical pushdown-eligibility owner.
- Route policy consumes that owner instead of duplicating matrix logic.

Acceptance criteria:
- Only one implementation of secondary order pushdown matrix remains.
- Planner and route paths agree on pushdown outcomes for shared test corpus.

### 6. DISTINCT Domain Split (SQL-like vs Kernel)
Introduce:

```rust
pub enum LogicalPlan {
    // existing variants...
    DistinctProjection { fields: Vec<FieldSlot> },
}
```

Requirements:
- `DistinctProjection` is value DISTINCT over the projected tuple (SQL-like semantics).
- `DistinctProjection` execution materializes projected values, canonicalizes into `GroupKey`, and deduplicates via hash-set membership.
- Kernel DISTINCT remains execution-level identity dedupe on `DataKey` only.
- No code path infers equality by ordering (`Ordering::Equal`) in grouping/dedup logic.

Acceptance criteria:
- Planner can emit `DistinctProjection` without reusing kernel row DISTINCT decoration.
- Different `DataKey` values with equal projected tuples collapse under `DistinctProjection`.
- Kernel row DISTINCT invariants remain unchanged: identical `DataKey` collapses; different `DataKey` values remain distinct even if projected values match.
- DISTINCT domain ownership is explicit in docs and tests (`DataKey` identity for kernel row DISTINCT; `GroupKey` equality for value DISTINCT).

### 7. Internal Grouped Handoff Contract
Define one internal query->executor grouped handoff shape that captures:
- group fields
- grouped aggregate terminals
- grouped execution config

Requirements:
- keep this contract internal to `db`
- no public grouped API exposure
- no grouped runtime enablement in this milestone

Acceptance criteria:
- grouped planning inputs cross exactly one explicit internal boundary
- no duplicate grouped handoff structs in parallel modules

### 8. Grouped Error Mapping Scaffolding
Pre-wire grouped-domain error mapping into query/plan surfaces while grouped
execution remains gated.

Requirements:
- mapping is explicit and typed
- grouped-disabled behavior remains unchanged

Acceptance criteria:
- grouped error conversions compile and are covered by tests
- grouped-disabled paths still reject grouped runtime execution

### 9. Grouped Observability Schema Lock-In
Define grouped trace/metrics fields now, even if grouped runtime remains disabled.

Requirements:
- grouped route decision outcomes are representable
- grouped budget counters are representable
- grouped rejection reasons are representable

Acceptance criteria:
- grouped observability fields and explain/trace mapping contracts are test-covered

### 10. Grouped Compatibility and Guardrails
Add grouped wire-shape vectors and grouped-disabled boundary tests.

Requirements:
- grouped continuation/handoff vectors catch wire-shape drift
- grouped execution remains non-reachable from scalar/public runtime paths

Acceptance criteria:
- grouped compatibility vectors are frozen and test-covered
- grouped-disabled behavior is explicit and assertion-backed

## Out of Scope
- Public `GROUP BY` behavior.
- `GroupPlan` in planner.
- Grouped cursor token wiring.
- Partitioned/out-of-core blocking.
- Cardinality estimation.
- Migrating kernel row DISTINCT from `DataKey` identity to `GroupKey` value equality.

## Risk and Rollback
| Area | Risk | Rollback |
| --- | --- | --- |
| Aggregate state-machine convergence | High | Keep adapter layer that forwards into legacy reducers while preserving new interfaces. |
| Error domain split | Medium | Preserve typed errors internally and map back through temporary compatibility shims. |
| Execution shape classification | Medium | Gate shape-based dispatch behind a feature switch and fall back to prior route mode decisions. |
| Pushdown owner unification | Medium | Revert route consumer wiring only; keep canonical owner module untouched. |
| DISTINCT domain split | Medium | Gate `DistinctProjection` planner emission and route execution behind one switch; retain current kernel DISTINCT identity behavior unchanged. |
| Internal grouped handoff contract shape | Medium | Keep adapter shim at boundary and defer shape strictness to `0.33`. |
| Grouped observability schema lock-in | Medium | Keep fields additive/internal and guard external surface until grouped enablement milestone. |

## Test Matrix by Phase
| Phase | Unit | Integration | Property | Upgrade |
| --- | --- | --- | --- | --- |
| Phase 1: state machine | reducer/state tests | scalar aggregate end-to-end parity | reducer associativity/terminal invariants | N/A |
| Phase 2: error domains | error constructor/mapping tests | planner->executor error surface tests | error-class stability checks | N/A |
| Phase 3: execution shape | shape classification tests | route/execution mode parity tests | shape decision matrix fuzzing | N/A |
| Phase 4: budget skeleton | budget counter tests | aggregate execution metrics tests | monotonic counter properties | N/A |
| Phase 5: pushdown unification | pushdown eligibility matrix tests | planner/route parity tests | random plan-shape equivalence checks | N/A |
| Phase 6: DISTINCT domain split | `DistinctProjection` canonicalization/dedupe tests, kernel row DISTINCT invariant tests | projection DISTINCT parity tests over mixed-key/same-value rows | insertion-order and hash-seed invariance for projection DISTINCT | N/A |
| Phase 7: grouped readiness scaffolding | grouped handoff/error/observability/cursor-vector tests | query->executor grouped handoff and grouped-disabled route tests | grouped insertion-order/collision stability checks | grouped cursor compatibility vectors |

## Expected Result
You now have:
- one aggregate state machine
- explicit execution-shape classification
- cleaner error domains
- unified pushdown policy
- explicit DISTINCT domain split: kernel row DISTINCT (`DataKey` identity) and SQL-like projection DISTINCT (`GroupKey` value equality)
- grouped readiness scaffolding: internal handoff contract, grouped error mapping, grouped observability lock-in, grouped compatibility vectors, and grouped-disabled boundary guardrails

At this point scalar aggregates are structurally ready for grouped planner integration in `0.33`.
