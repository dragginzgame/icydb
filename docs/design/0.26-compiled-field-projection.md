# 0.26 - Compiled Field Projection

## Purpose

Remove dynamic string-based field lookup from aggregate executor hot paths and replace it with slot-based field projection compiled once per aggregate terminal setup.

This aligns:

- aggregate terminal setup validation
- route eligibility checks
- executor inner loops
- aggregate field extraction/comparison logic

No user-visible query semantics are intended to change.

---

## Motivation

As of `0.25.x`:

- field targets are resolved by name (`field_model_by_name(...)`-style lookup)
- per-row field access uses `get_value(&str)`
- aggregate loops repeatedly pass field names and branch through string matching

This keeps a dynamic seam in otherwise strongly validated execution.

`0.26` removes string lookup from aggregate hot loops.

---

## Goals

1. Resolve aggregate target fields once per terminal setup.
2. Eliminate per-row string field lookup in aggregate execution.
3. Introduce slot-based field projection in aggregate executor internals.
4. Preserve existing aggregate semantics and error taxonomy.
5. Keep route/eligibility behavior unchanged.

---

## Non-Goals

- no new aggregate terminals
- no `GROUP BY`
- no planner cost-model redesign
- no cursor redesign
- no change to aggregate eligibility matrix
- no fast-path expansion in `0.26`
- no broad cross-module removal of `get_value(&str)` outside aggregate execution

---

## Current Model (`0.25.x`)

Setup:

```text
field name
  -> field model lookup
  -> field kind validation
```

Execution loop:

```text
entity.get_value(field_name)
  -> string match
  -> owned Value
```

---

## Target Model (`0.26`)

Setup (aggregate terminal boundary):

```text
field name
  -> (field_index, field_kind)
  -> FieldSlot { index, kind }
```

Execution loop:

```text
entity.get_value_by_index(slot.index)
```

No field-name string lookup in the loop.

Important scope clarification:

- In `0.26`, slot resolution occurs at aggregate terminal setup/executor entry.
- This does not require embedding aggregate target fields into `Query::plan()` yet.
- String-based lookup remains in aggregate terminal setup for initial resolution and validation. Only inner execution loops are string-free.
- `0.26` does not attempt to migrate non-aggregate modules (predicate/order/index/save/relation) off name-based field lookup.

---

## Core Design

### 1. Introduce `FieldSlot`

Internal type:

```rust
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub(crate) struct FieldSlot {
    pub index: usize,
    pub kind: FieldKind,
}
```

Notes:

- use `usize` for direct indexing and to avoid artificial field-count constraints
- this replaces passing `&str` through aggregate hot paths

### 2. Extend `FieldValues`

Current:

```rust
fn get_value(&self, field: &str) -> Option<Value>;
```

Add:

```rust
fn get_value_by_index(&self, index: usize) -> Option<Value>;
```

Why `Option<Value>` (owned) in `0.26`:

- current entities store typed fields (`u32`, `String`, `Vec<T>`, `Option<T>`), not stored `Value`
- derive currently constructs `Value` on demand
- `Option<&Value>` would require a larger storage-model redesign

Contract:

- name-based access remains for DSL/public query surfaces
- aggregate executor internals use index-based access

### 3. Update derive macro output

Derive continues to generate string-based getter and also generates index-based getter.

Shape:

```rust
fn get_value_by_index(&self, index: usize) -> Option<Value> {
    match index {
        0 => Some(self.a.to_value()),
        1 => Some(self.b.to_value()),
        _ => None,
    }
}
```

No intended semantic change.

### 4. Replace field-name lookup helpers with indexed resolution

Current helper shape:

```rust
fn field_model_by_name(model, field: &str) -> Option<&FieldModel>
```

Target helper shape:

```rust
fn field_model_with_index(model, field: &str) -> Option<(usize, &FieldModel)>
```

This produces `FieldSlot` during setup.

### Field Order Invariant

`FieldSlot.index` corresponds to the stable ordering of fields in `EntityModel.fields`.

The derive macro must emit `get_value_by_index` match arms in the same order as the entity's declared field order, and that order must match `EntityModel.fields`.

A regression test must assert this invariant for representative entities.

Why this is a hard invariant:

- slot-based projection is only correct when field ordering is deterministic
- schema/model field-order drift would otherwise cause silent wrong-field reads

### 5. Refactor aggregate executor field paths

Aggregate field terminals store `FieldSlot` and project per-row values by index.

The following terminal families are in scope:

- extrema field terminals (`min_by`, `max_by`, `min_max_by`, `median_by`, `nth_by`)
- numeric field terminals (`sum_by`, `avg_by`)
- distinct-count field terminal (`count_distinct_by`)

No route-order or fast-path eligibility changes are introduced.

### String-Free Aggregate Execution Contract

Aggregate executor modules must not call `FieldValues::get_value(&str)`.

All aggregate field access must go through `get_value_by_index`.

This is a structural boundary, not a best-effort guideline.

Enforcement options:

- trait separation for executor-internal projection boundaries
- CI guard that forbids `get_value(` usage in aggregate executor modules
- focused regression test coverage that fails if string-based aggregate projection is reintroduced

---

## Secondary Index Compatibility

Design should remain open to future projection sources:

```rust
enum FieldProjection {
    RowSlot(FieldSlot),
    IndexComponent(u8),
}
```

`0.26` may implement only `RowSlot`.

---

## Taxonomy Preservation

No intended change to:

- `Unsupported` classification boundaries
- `Corruption` detection behavior
- `InvariantViolation` contracts
- fail-fast ordering

Existing aggregate error-classification matrix should remain valid.

---

## Performance Expectations

Expected improvements:

- remove per-row string comparisons from aggregate loops
- reduce branch depth in aggregate field projection
- keep schema/model lookup out of inner execution loops

Out of scope in `0.26`:

- eliminating all `Value` construction/allocation
- borrowed projection model (`&Value`) redesign

---

## Testing Requirements

Existing aggregate parity suite should pass unchanged.

Add focused coverage:

1. String-path elimination lock
- assert aggregate executor field terminals do not use name-based `get_value(&str)` path.

2. Slot correctness
- slot index matches runtime schema field order.
- out-of-range index behavior is explicit (`None`).

3. Taxonomy stability
- existing field-terminal classification matrix remains stable.

4. Derive/index mapping coverage
- generated `get_value_by_index` behavior matches field declaration order across scalar/optional/list fields.

---

## Migration Plan

Recommended sequence:

1. Add `get_value_by_index` to `FieldValues` (no panic defaults).
2. Update derive macro to implement it.
3. Update any manual `FieldValues` impls (test-only or internal).
4. Introduce slot-resolution helper (`field_model_with_index`).
5. Refactor aggregate field executors to use `FieldSlot` + index getter.
6. Remove aggregate hot-path string lookups.
7. Run full workspace gates and aggregate suite.
8. Tag `0.26.0`.

---

## Pre-Implementation Checklist

Before coding starts:

1. Confirm `Option<Value>` is the `0.26` projection return contract.
2. Confirm slot resolution boundary is terminal setup (not plan embedding) for this milestone.
3. Confirm semver communication for `FieldValues` trait expansion (manual impl impact).
4. Capture before/after benchmark baselines for aggregate field terminals.

This is a source-breaking change for external manual `FieldValues` implementations and requires a minor version bump.

---

## Risk Assessment

- engineering effort: moderate
- semantic risk: low
- blast radius: medium (`traits`, derive macro, aggregate executor)

Risk mitigation:

- no route/eligibility expansion in same milestone
- parity + taxonomy regression suite already strong from `0.25.x`
- migration sequence avoids runtime panics
- incorrect index/schema alignment can manifest as logical data corruption rather than type errors, so index-order regression tests are mandatory

---

## Why `0.26` (Not `0.25.x`)

This is a structural change touching:

- trait surface
- derive output
- aggregate executor internals

Even with stable semantics, this belongs in a minor milestone.

---

## Post-`0.26` Position

After completion:

- aggregate field access becomes slot-based and string-free in hot loops
- planner/executor alignment improves
- future optimizations (index projection, borrowed projection, reduced `Value` construction) become easier and safer to stage

`0.26` is the foundation step, not the final projection-performance ceiling.

## `0.26.1+` Follow-Up Focus

`0.26.1+` should focus on reducing or eliminating remaining `get_value(&str)` usage outside aggregate execution by introducing resolved slot projection where semantics are static.

Priority follow-up areas:

- query ordering/cursor slot extraction paths
- predicate evaluation paths with pre-resolved field references
- index build and unique-validation field projection
- save-time invariant/relation validation where schema field sets are known

Guidance:

- keep `0.26` branch scoped to a clean aggregate migration to `FieldSlot`
- stage non-aggregate migrations incrementally in `0.26.1+` to avoid mixing behavioral risk with the core aggregate refactor
