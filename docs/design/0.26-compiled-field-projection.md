# 0.26 — Compiled Field Projection

## Purpose

Eliminate dynamic string-based field access from execution paths and replace it with slot-based compiled field projection resolved at planning time.

This milestone strengthens architectural alignment between:

* Plan validation
* Route eligibility
* Executor hot paths
* Aggregate terminals

No user-visible behavior changes are introduced.

---

# Motivation

As of 0.25.x:

* Field resolution is performed using `field_model_by_name(...)`.
* Row access uses `get_value(&str)` via string matching.
* Aggregates dynamically access fields by name per row.

This results in:

* Per-row string comparisons
* Branch-heavy match ladders
* Allocation / owned `Value` construction in tight loops
* Execution-phase schema dependency
* Architectural misalignment with plan-time validation model

The rest of the engine is strongly plan-driven and fail-fast validated.

Field access remains the last dynamic runtime seam.

0.26 removes that seam.

---

# Goals

1. Resolve field targets once at plan time.
2. Eliminate string-based field lookup from executor hot paths.
3. Introduce slot-based row access.
4. Preserve all existing semantics and taxonomy.
5. Introduce no surface-level behavior changes.

---

# Non-Goals

* No new aggregates.
* No GROUP BY.
* No planner cost-model redesign.
* No cursor redesign.
* No change to aggregate eligibility matrix.
* No external API breakage beyond internal trait adjustments.

---

# Architectural Overview

## Current Model (0.25)

Planning:

```
field name (string)
    ↓
FieldModel lookup
    ↓
FieldKind validation
```

Execution:

```
entity.get_value(field_name)
    → string match
    → owned Value
```

---

## Target Model (0.26)

Planning:

```
field name
    ↓
(field_index, FieldKind)
    ↓
FieldSlot { index, kind }
```

Execution:

```
entity.get_value_by_index(index)
```

No string lookup in hot loop.

---

# Core Design

## 1️⃣ Introduce FieldSlot

Internal-only type:

```rust
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub(crate) struct FieldSlot {
    pub index: u16,
    pub kind: FieldKind,
}
```

Resolved during aggregate terminal setup.

This replaces passing `&str` into execution logic.

---

## 2️⃣ Extend FieldValues Trait

Current:

```rust
fn get_value(&self, field: &str) -> Option<Value>;
```

Add:

```rust
fn get_value_by_index(&self, index: usize) -> Option<&Value>;
```

### Important

* Name-based access remains for DSL and public APIs.
* Executor uses only index-based access.

---

## 3️⃣ Modify Derive Macro

Current macro emits:

```rust
match field {
    "a" => ...
    "b" => ...
}
```

New macro must also emit:

```rust
fn get_value_by_index(&self, index: usize) -> Option<&Value> {
    match index {
        0 => Some(&self.a),
        1 => Some(&self.b),
        _ => None,
    }
}
```

No behavioral change.

---

## 4️⃣ Replace field_model_by_name Usage

Current:

```rust
fn field_model_by_name(model, field: &str) -> Option<&FieldModel>
```

Replace with:

```rust
fn field_model_with_index(model, field: &str)
    -> Option<(usize, &FieldModel)>
```

This produces `FieldSlot`.

---

## 5️⃣ Executor Refactor

Aggregate executor stores:

```rust
FieldSlot
```

Per-row access:

```rust
entity.get_value_by_index(slot.index as usize)
```

No string passed beyond setup.

---

# Secondary Index Compatibility

Future-proofing for index projection:

Introduce internal abstraction:

```rust
enum FieldProjection {
    RowSlot(FieldSlot),
    IndexComponent(u8),
}
```

Not required in first pass, but design must not prevent this.

0.26 initial scope may implement only `RowSlot`.

---

# Taxonomy Preservation

No change in:

* Error classification
* Unsupported vs InvalidInput boundaries
* Corruption detection
* Fail-fast validation ordering

Existing test matrix must pass unchanged.

---

# Performance Expectations

Expected improvements:

* Eliminate per-row string comparisons.
* Reduce branch depth in aggregate loops.
* Remove schema lookup from execution.
* Improve inlining in `min_by` / `sum_by`.

No regression in canonical execution.

---

# Testing Requirements

Existing aggregate parity suite must pass without modification.

Add new tests:

### 1️⃣ Regression Lock

Assert that aggregate execution does not call `get_value(&str)`.

(Implementation detail: can temporarily instrument or mark deprecated usage in executor paths.)

### 2️⃣ Slot Correctness

Test that:

* Slot index matches schema order.
* Wrong index yields None (debug-only test acceptable).

### 3️⃣ Taxonomy Stability

Ensure error-classification tests remain unchanged.

---

# Migration Plan

Recommended sequence:

1. Introduce `get_value_by_index` with default panic/unimplemented.
2. Update derive macro to implement it.
3. Refactor aggregate executor to use slots.
4. Remove all string-based access from aggregate paths.
5. Run full workspace test suite.
6. Add slot regression tests.
7. Tag 0.26.0.

---

# Risk Assessment

Engineering effort: Moderate
Semantic risk: Low
Blast radius: Medium (derive macro + executor)

Risk mitigated by:

* No semantic changes
* Extensive parity tests already present
* Eligibility and taxonomy locks from 0.25.1

---

# Why 0.26 (Not 0.25.x)

This change:

* Alters trait surface.
* Alters macro expansion.
* Touches execution core.
* Affects all aggregates.

Even though behavior remains identical, architectural changes of this scope belong in a minor milestone.

---

# Post-0.26 Position

After this milestone:

* Field access is fully plan-compiled.
* Executor is slot-based and string-free.
* Secondary index projection becomes trivial.
* Rank-based aggregates (median, percentile) become easier.
* Distinct aggregates become cleaner to implement.

0.26 establishes the projection foundation for future analytic expansion.
