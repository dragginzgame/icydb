# 0.31 - Deterministic Key and Equality Substrate

## Theme
Freeze grouping semantics before touching execution.

This release establishes the canonical foundation for grouping, distinct semantics, and partitioned execution.

## Scope
No visible `GROUP BY` behavior ships.

## Dependency Chain
- Input from `0.30`: route/kernel/cursor boundaries are already stabilized.
- Output to `0.32`: aggregate execution and projection DISTINCT planning can rely on canonical key/equality semantics plus explicit DISTINCT domain boundaries.
- Output to `0.33`: planner/grouped execution can build on deterministic grouping keys.

## Objectives
### 1. Canonical Group Key Contract
Introduce:

```rust
pub struct GroupKey {
    raw: CanonicalValue,
    hash: StableHash,
}

pub trait CanonicalKey {
    fn canonical_key(&self) -> Result<GroupKey, KeyCanonicalError>;
}
```

Requirements:
- Canonical map ordering is guaranteed.
- `Decimal`/`BigInt` values are normalized into canonical representation.
- No comparator-based equality in grouping paths.
- `GroupKey` is opaque and only constructible via canonicalization.
- Hash and canonical raw value are coupled at construction.

Acceptance criteria:
- No direct `GroupKey` field construction outside canonicalization boundary.
- Canonicalization rejects/normalizes all supported numeric edge forms deterministically.
- Grouping paths use `GroupKey` equality, not comparator fallbacks.

### 2. Stable Hashing Layer
Introduce:

```rust
pub type StableHash = u64;
```

Under:
- `db/hash/`

Requirements:
- Fixed seed.
- No `std::hash::DefaultHasher`.
- Stable across upgrades.
- Hash equality implies canonical equality.

Acceptance criteria:
- Hash values are identical before/after simulated upgrade for same canonical inputs.
- No callsites use non-stable hashers for grouping/distinct key paths.

### 3. Equality vs Ordering Separation
Formalize:

```rust
pub trait EqualitySemantics {
    fn equals(a: &Value, b: &Value) -> bool;
}

pub trait OrderingSemantics {
    fn compare(a: &Value, b: &Value) -> Ordering;
}
```

Requirements:
- `DISTINCT` uses equality semantics.
- `ORDER` uses ordering semantics.
- No implicit mixing.

Acceptance criteria:
- Distinct code paths compile against equality contract only.
- Order/sort code paths compile against ordering contract only.
- Comparator-based equality usage is removed from grouping/distinct internals.

### 4. DISTINCT Semantic Boundary Lock
- Keep row-level kernel DISTINCT as identity dedupe on `DataKey`.
- Use canonical `GroupKey` equality for value DISTINCT paths.
- No code path infers equality from ordering (`Ordering::Equal`) in grouping/dedup logic.
- No external behavior change.

Acceptance criteria:
- Existing row-level kernel DISTINCT behavior remains parity-stable on current test corpus.
- Value DISTINCT behavior is canonicalized through `GroupKey` with deterministic results across insertion-order variation.
- Invariant coverage exists for:
  - identical `DataKey` values never duplicate under row DISTINCT
  - different `DataKey` values remain distinct under row DISTINCT even when projected values are equal

### 5. Direction Derivation Unification (Audit Cleanup)
- Unify scan-direction logic under one canonical plan helper boundary.
- Keep behavior unchanged.

Acceptance criteria:
- Direction derivation callsites use canonical plan helper functions.
- No duplicate direction-policy branches remain in executor route/load helpers.

## Out of Scope
- Aggregate state rewrite.
- `ExecutionShape` enum.
- Planner grouped surface split.
- `GROUP BY` routing.
- Blocking enforcement.
- Cardinality estimation.

## Risk and Rollback
| Area | Risk | Rollback |
| --- | --- | --- |
| Stable hashing and canonicalization | High | Feature-flag/hash-boundary rollback to previous distinct substrate while preserving API surface. |
| Equality vs ordering split | Medium | Temporarily keep compatibility adapters while retaining explicit boundary traits. |
| DISTINCT semantic boundary lock | Medium | Keep kernel DISTINCT identity path unchanged and roll back only value DISTINCT canonicalization callsite wiring if needed. |

## Test Matrix by Phase
| Phase | Unit | Integration | Property | Upgrade |
| --- | --- | --- | --- | --- |
| Phase 1: GroupKey contract | canonicalization cases, map ordering | distinct/group key call paths | normalization idempotence, key determinism | N/A |
| Phase 2: Stable hash | fixed-seed vectors | grouping/distinct key hashing flow | hash consistency over randomized canonical inputs | hash stability before/after simulated upgrade |
| Phase 3: Equality vs ordering | trait boundary tests | distinct vs order route tests | comparator/equality separation invariants | N/A |
| Phase 4: DISTINCT boundary lock | row distinct identity tests, value distinct reducer tests | end-to-end row/value distinct parity queries | insertion-order invariance | parity fixtures for row DISTINCT identity behavior |
| Phase 5: Direction unification | helper behavior tests | route/load direction parity | randomized order-slot parity | N/A |

## Expected Result
You now have:
- deterministic equality behavior
- stable hash behavior
- canonical key materialization
- explicit DISTINCT domain boundaries:
  - row DISTINCT (`DataKey` identity)
  - value DISTINCT (`GroupKey` canonical equality)

This is the base for all grouped execution work in `0.32+`.
