# 0.31 Roadmap - GROUP BY Substrate Release

## Status

Draft design guidance for release `0.31`.

This document defines required substrate work before shipping full `GROUP BY` behavior.

## Scope

`0.31` is a substrate release, not the final feature release.

It must establish deterministic grouping foundations across key canonicalization, aggregate state ownership, execution-shape boundaries, and planner/executor contracts.

## A. Strict Prerequisites for `GROUP BY`

These are structural requirements. Without them, grouping will leak invariants or become a bolt-on.

### 1. Canonical Key Materialization Contract

#### Problem

Grouping requires deterministic canonical grouping keys, but canonicalization logic is currently distributed across:

- `Value`
- index normalization
- ordered key semantics

There must be one authoritative grouping-key contract.

#### Deliverable

Introduce:

```rust
pub struct GroupKey {
    raw: Value,              // canonical Value
    fingerprint: KeyHash,    // stable hash
}
```

And:

```rust
pub trait CanonicalKey {
    fn canonical_key(&self) -> Result<GroupKey, KeyError>;
}
```

#### Requirements

- Map ordering is fully canonical.
- Decimal/BigInt representations are normalized.
- Comparator-based equality is forbidden.
- Hashing and equality are definitionally equivalent.

This becomes the canonical base for:

- `GROUP BY` keys
- `DISTINCT` keys
- future partition keys

### 2. Aggregate Execution State Contract Unification

Current shape includes:

```rust
pub struct AggregateSpec {
    kind: AggregateKind,
    target_field: Option<String>,
}
```

`GROUP BY` requires isolated state per group, so aggregate state must be unified under one canonical state machine.

#### Deliverable

```rust
pub trait AggregateState {
    fn apply(&mut self, row: &Entity) -> Result<(), AggregateError>;
    fn finalize(self) -> Value;
}
```

```rust
pub trait AggregateFactory {
    fn create(&self) -> Box<dyn AggregateState>;
}
```

#### Requirement

The current fold/kernel distinction must collapse to one canonical aggregate state model.

### 3. Execution Shape Boundary: Streaming vs Materializing

`GROUP BY` is inherently blocking and potentially memory-heavy.

Execution shape must be explicit.

#### Deliverable

```rust
pub enum ExecutionShape {
    Streaming,
    Blocking,
    PartitionedBlocking,
}
```

#### Requirements

- Planner labels `GROUP BY` as `Blocking` (or stricter variant).
- Executor tracks memory and enforces blocking boundaries.
- Streaming-only routes are rejected when shape requires blocking.

### 4. Deterministic Storage-Level Hashing

`GROUP BY` requires hash-map state keyed by canonical keys.

Hashing must be stable across upgrades.

#### Deliverable

```rust
pub type StableHash = u64;
```

And an internal hashing module under `db::hash` with fixed-seed deterministic hashing.

#### Requirements

- No dependence on randomized `std::hash` defaults.
- Explicit stable hash implementation and seed ownership.

This also supports:

- `DISTINCT`
- future joins
- dedupe streams

### 5. Planner Output Surface Separation

Current planner surface blends:

- `LogicalPlan`
- `AccessPlan`
- executor-facing payloads

`GROUP BY` requires explicit typed output.

#### Deliverable

```rust
pub struct GroupPlan {
    group_fields: Vec<FieldSlot>,
    aggregates: Vec<AggregateSpec>,
}
```

#### Requirement

Do not hide grouping as flags inside `LogicalPlan`. Grouping must be explicit and typed.

## B. Helpful Infrastructure (Strongly Recommended for `0.31`)

These are not strict blockers but will prevent near-term rewrites.

### 6. Storage Metrics Expansion

Extend `StorageReport` with per-entity metrics:

- `total_rows`
- `total_bytes`
- `average_row_size`
- `median_row_size`
- `p95_row_size`
- `max_row_size`
- `index_entry_count`
- `index_bytes`

Rationale:

- estimate grouping memory pressure
- detect skew
- support a future planner cost model

`median` may be approximate (for example PÂ² estimator).

### 7. Cardinality Estimation Hooks

Add:

```rust
pub struct EntityStats {
    row_count: u64,
    distinct_estimates: BTreeMap<FieldName, u64>,
}
```

Approximate counts are acceptable initially.

Rationale:

- warn about high group cardinality
- support future execution-shape decisions

### 8. Explicit Executor Memory Budget Tracking

Add:

```rust
pub struct ExecutionBudget {
    memory_bytes: u64,
    row_count: u64,
}
```

`GROUP BY` must enforce budget checks to prevent:

- canister OOM
- runaway grouping paths

### 9. Equality vs Ordering Contract Formalization

Grouping depends on equality semantics; ordering is secondary.

Define explicit contracts:

```rust
pub trait EqualitySemantics {
    fn equals(a: &Value, b: &Value) -> bool;
}

pub trait OrderingSemantics {
    fn compare(a: &Value, b: &Value) -> Ordering;
}
```

Requirement: never mix equality and ordering semantics implicitly.

## C. Standardization and Architecture Hardening

These controls prevent aggregate and grouping entropy.

### 10. AggregateSpec Canonical Normal Form

Lock `AggregateSpec` as planner-final form:

- no implicit defaults
- no target-field ambiguity
- no executor-owned rewrites

Planner output must already be canonical.

### 11. Executor Layer Contract Tightening

`0.31` should enforce boundary clarity under grouping load.

#### Requirement

Forbid executor dependence on query-planner internals beyond the declared neutral contracts.

Add structural checks/tests to enforce this boundary.

### 12. Error Domain Segmentation

Introduce explicit domains:

```rust
enum GroupError
enum AggregateError
enum KeyCanonicalError
```

Do not overload `PlanError` or broad `InternalError` for grouping-specific taxonomy.

## What `0.31` Must Not Do

- Do not ship partial `GROUP BY` behavior.
- Do not add window functions.
- Do not add `HAVING`.
- Do not mix `DISTINCT` + `GROUP BY` feature expansion in the same release.
- Do not optimize early before substrate invariants are locked.

`0.31` is substrate, not feature-complete grouping.

## Suggested Changelog Theme (`0.31`)

**Aggregation Substrate Stabilization**

Headline items:

- canonical grouping key contract
- unified aggregate state model
- stable hashing layer
- explicit blocking execution classification
- expanded storage metrics

## Strategic View

`GROUP BY` is the first feature that strongly stresses:

- memory safety
- equality semantics
- planner/executor contract clarity
- state-machine correctness

If `0.31` lands the substrate correctly, `0.32` can ship complete `GROUP BY` behavior cleanly.
