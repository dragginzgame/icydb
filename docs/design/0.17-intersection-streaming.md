# 0.17 Composite Streaming Execution

**Status:** Draft
**Target:** `0.17.x`
**Scope Type:** Execution-layer internal refactor + capability expansion
**Storage/Wire Impact:** None
**Index Format Impact:** None

---

# 1. Purpose

Extend the ordered-key streaming model introduced in `0.15` and expanded in `0.16` to fully support **composite execution** without intermediate materialization.

Specifically:

* Replace materialized `Intersection` execution with streaming semantics.
* Preserve strict ordering guarantees (ASC/DESC).
* Preserve continuation correctness.
* Preserve existing invariant enforcement.
* Maintain zero public API change.

This milestone completes the “composite streaming” execution architecture.

---

# 2. Background

Current state (post-0.16):

| Access Plan    | Execution Model         |
| -------------- | ----------------------- |
| `Path`         | Streamed                |
| `Union`        | Stream-merged           |
| `Intersection` | Materialized `BTreeSet` |

`Intersection` currently:

1. Collects candidate keys from children.
2. Intersects sets in memory.
3. Wraps result in `VecOrderedKeyStream`.

This introduces:

* Memory amplification for large result sets.
* Loss of incremental pull behavior.
* Inconsistent execution strategy across composite nodes.
* Pushdown limitation for composite plans.

---

# 3. Goals

## Primary Goals

1. Implement `IntersectOrderedKeyStream<A, B>`.
2. Eliminate candidate-set materialization for `AccessPlan::Intersection`.
3. Preserve deterministic ordering and monotonic enforcement.
4. Preserve existing continuation semantics.
5. Preserve error classification and invariant boundaries.

## Secondary Goals

1. Enable future composite limit pushdown.
2. Reduce memory surface area of composite execution.
3. Remove drift risk between union and intersection code paths.

---

# 4. Non-Goals

* No planner redesign.
* No new public streaming API.
* No index format changes.
* No change to cursor token format.
* No change to strict/non-strict enum semantics.
* No cost-based optimizer in this milestone.

---

# 5. Design Overview

## 5.1 New Type

Add:

```rust
pub(crate) struct IntersectOrderedKeyStream<A, B> {
    left: A,
    right: B,
    direction: MergeDirection,
    left_last_pulled: Option<DataKey>,
    right_last_pulled: Option<DataKey>,
}
```

Where:

* `A: OrderedKeyStream`
* `B: OrderedKeyStream`

Semantics:

* Both inputs must already be ordered.
* Monotonic enforcement mirrors `MergeOrderedKeyStream`.
* Intersection is computed by advancing whichever side is “behind”.

---

## 5.2 Intersection Algorithm

### ASC case

```
loop:
    ensure left and right items
    if left == right:
        emit key
        advance both
    else if left < right:
        advance left
    else:
        advance right
```

### DESC case

Comparison reversed:

```
if left > right:
    advance left
else:
    advance right
```

Guarantees:

* No duplication.
* No omission.
* Stable order preserved.
* Strict monotonic invariant enforced per child stream.

---

# 6. Invariant Requirements

The following invariants must hold:

1. Each child stream must respect declared direction.
2. Monotonic violation = `InvariantViolation`.
3. No out-of-order key may be emitted.
4. Emitted stream must remain strictly ordered.
5. Duplicate keys must not be emitted.

All error classification must match existing `MergeOrderedKeyStream` semantics.

---

# 7. Executor Integration

Replace in:

`AccessPlan::produce_key_stream`

Current:

```
Self::Intersection(_) => {
    let keys = self.collect_candidate_keys(ctx)?;
    VecOrderedKeyStream::new(...)
}
```

New:

```
Self::Intersection(children) => {
    Self::produce_intersection_key_stream(ctx, children, ...)
}
```

Implementation mirrors `produce_union_key_stream` but uses pairwise intersection merging.

---

# 8. Pairwise Strategy

For N children:

* Use same pairwise reduction used by union.
* Combine in rounds:

  * (A ∩ B)
  * (result ∩ C)
  * etc.

This avoids building N-way intersection state.

---

# 9. Continuation Semantics

Continuation is currently anchored at the root plan level.

Intersection streaming must:

* Accept root-level anchor only.
* Pass anchor to each child path as currently done.
* Preserve monotonic resume behavior.

No new continuation format is introduced.

---

# 10. Limit Pushdown Implications

0.17 does NOT implement composite pushdown.

However:

Once intersection streams:

* Early stop becomes naturally possible.
* Composite pushdown becomes implementable in 0.18.

This milestone prepares that path.

---

# 11. Direction Handling Consolidation (Optional Add-On)

As identified in 0.16 audit:

Direction enforcement currently appears in multiple executor sites.

Optional addition:

Create:

```
executor::direction::apply_direction(Vec<DataKey>, Direction)
```

Or:

```
executor::direction::compare(a, b, Direction)
```

And refactor all ASC/DESC branching to use that helper.

This reduces drift risk.

---

# 12. Testing Matrix

## Required Tests

### 1. Basic ASC Intersection

```
[1,3,5] ∩ [3,4,5] → [3,5]
```

### 2. Basic DESC Intersection

```
[5,3,1] ∩ [6,5,3] → [5,3]
```

### 3. No Overlap

```
[1,2] ∩ [3,4] → []
```

### 4. Duplicate Suppression

If child streams internally duplicate (should not happen, but defensive):

Ensure no duplicate emission.

### 5. Monotonic Violation Rejection

Child stream emits out-of-order → invariant error.

### 6. Union + Intersection Composite Plan

Ensure nested composite shapes remain correct.

### 7. DESC + LIMIT + Continuation

Reproduce 0.16 quadrant coverage but for intersection.

---

# 13. Complexity Analysis

| Area            | Complexity |
| --------------- | ---------- |
| Stream type     | Moderate   |
| Executor wiring | Low        |
| Planner impact  | None       |
| Risk            | Medium-Low |

Most logic mirrors union merge logic but simplified.

---

# 14. Migration Impact

None.

* No storage change.
* No index change.
* No cursor token change.
* No wire change.
* No API change.

---

# 15. Expected Benefits

1. Removes materialization hotspot.
2. Reduces memory amplification.
3. Makes composite execution uniform.
4. Prepares composite pushdown.
5. Aligns execution architecture around streaming.

---

# 16. Risks

| Risk                                         | Mitigation                                |
| -------------------------------------------- | ----------------------------------------- |
| Infinite loop due to pointer advancement bug | Exhaustive test coverage                  |
| Incorrect DESC comparison                    | Reuse `MergeDirection`                    |
| Continuation edge-case regression            | Re-run 0.16 composite continuation matrix |
| Performance regression                       | Benchmark large intersection              |

---

# 17. Completion Criteria

* [ ] No `collect_candidate_keys` usage for `Intersection`.
* [ ] All composite execution produces `OrderedKeyStream`.
* [ ] No materialized `BTreeSet` in composite executor path.
* [ ] All 0.16 regression tests pass.
* [ ] New intersection tests pass.
* [ ] No explain/metrics regressions.
* [ ] `cargo test --workspace` passes.

---

# 18. Milestone Summary

0.15 — Stream abstraction
0.16 — Union streaming + temporal unification
0.17 — Intersection streaming (complete composite streaming model)

After 0.17, the execution engine becomes fully stream-native.

