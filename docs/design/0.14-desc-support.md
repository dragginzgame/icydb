# 0.14 — DESC Support (Single-Path IndexRange)

## 1. Purpose

Introduce deterministic descending-order traversal support for `AccessPath::IndexRange` (single-path only).

This enables:

* Reverse chronological pagination
* Leaderboard-style queries
* "Newest-first" result ordering
* Symmetric ordering semantics

This phase does **not** introduce:

* Composite access tree DESC
* DESC pushdown for union/intersection
* Binary cursor encoding
* Cost-based planner changes

---

## 2. Motivation

Current engine behavior:

* IndexRange traversal is strictly ascending (lexicographic RawIndexKey order).
* Pagination assumes forward progression.
* Bounds assume lower → upper semantics.

To fully support ordered queries, the engine must support:

```
ORDER BY <index> DESC
```

DESC support requires:

* Reversing traversal direction.
* Inverting bound construction.
* Reversing continuation semantics.

This is not merely iteration reversal — it requires strict bound math symmetry.

---

## 3. Scope

### In Scope

* `AccessPath::IndexRange`
* Forward-only pagination model adapted for reverse traversal
* Single-path execution plans
* Deterministic ordering
* Bound correctness for inclusive/exclusive cases

### Out of Scope

* Composite access trees (Union / Intersection)
* PK KeyRange DESC (unless trivial)
* Mixed ASC/DESC multi-field ordering
* Pushdown for composite trees
* Binary cursor encoding

---

## 4. Current Ascending Model (Recap)

For:

```
IndexRange {
    prefix,
    lower,
    upper
}
```

Execution:

```
start = composite(prefix, lower, suffix strategy)
end   = composite(prefix, upper, suffix strategy)
range((start_raw, end_raw))
```

Continuation:

```
start = Bound::Excluded(last_raw_key)
```

Traversal direction:

```
raw_key ascending
```

---

## 5. DESC Model Overview

DESC reverses:

* Traversal direction
* Boundary interpretation
* Continuation progression

Execution must become:

```
range((start_raw, end_raw)).rev()
```

But this alone is insufficient.

We must ensure:

* Correct inclusive/exclusive group semantics.
* Continuation resumes strictly before last key.
* No prefix leakage.
* Bound preservation remains intact.

---

## 6. Revised Execution Semantics (DESC)

Given:

```
IndexRange { prefix, lower, upper }
ORDER BY DESC
```

Ascending bounds remain:

```
start = composite(prefix, lower)
end   = composite(prefix, upper)
```

But traversal direction becomes:

```
entry_map.range((start_raw, end_raw)).rev()
```

Important:

* Bound construction does NOT invert.
* Only traversal direction inverts.

Reason:

RawIndexKey ordering remains lexicographic ascending.
Reversing iterator direction is sufficient.

---

## 7. Continuation Model (DESC)

Ascending continuation:

```
start = Bound::Excluded(last_raw_key)
```

Descending continuation:

We must resume strictly before last emitted key.

Thus:

```
end = Bound::Excluded(last_raw_key)
start = original lower bound
```

Execution:

```
range((start_raw, end_raw)).rev()
```

This ensures:

* No duplication.
* No omission.
* Strict reverse progression.

---

## 8. Critical Invariants

### Invariant 1 — Bound Preservation

Original `(prefix, lower, upper)` must remain intact.

DESC must never:

* Expand bounds.
* Escape prefix isolation.

---

### Invariant 2 — Strict Reverse Advancement

Continuation must use:

```
Bound::Excluded(last_raw_key)
```

On upper side of range.

Never Included.

---

### Invariant 3 — Symmetry

For any query Q:

```
ASC results reversed == DESC results
```

For identical bounds.

This must hold for all tested cases.

---

## 9. Edge Cases to Validate

### Case A — Upper Inclusive

```
<= 20
ORDER BY DESC
```

First page should start at largest <= 20.

Continuation must exclude last key.

---

### Case B — Upper Exclusive

```
< 20
ORDER BY DESC
```

Component group 20 must never appear.

---

### Case C — Lower Inclusive

```
>= 10
ORDER BY DESC
```

Lower bound must not be crossed when reversing.

---

### Case D — Page Boundary Inside Group

If descending page ends mid-group:

```
(7, 10, pk=3)
(7, 10, pk=2)
(7, 10, pk=1)
```

Continuation must resume at:

```
Excluded(last_raw_key)
```

Not at component-level boundary.

---

### Case E — Exhaustion

If continuation end <= lower bound:

Return empty.

---

## 10. API Changes

LogicalPlan must include order direction:

```rust
enum OrderDirection {
    Asc,
    Desc,
}
```

IndexRange execution must:

* Accept order direction.
* Apply `.rev()` on BTree range iterator if Desc.

Continuation envelope must include direction.

Plan fingerprint must include order direction.

---

## 11. Plan Identity Impact

Canonical and hash must incorporate:

* Order direction.

Otherwise:

```
ASC plan fingerprint == DESC plan fingerprint
```

Would be incorrect.

Plan identity must change with ordering direction.

---

## 12. Cursor Impact

Cursor envelope must include:

* Direction.

Continuation validation must verify:

* Direction matches plan.

Cursor anchor remains:

```
RawIndexKey
```

No change in cursor internal structure required.

Binary cursor remains deferred.

---

## 13. Testing Requirements

### Equivalence Tests

For multiple datasets:

```
ASC results reversed == DESC results
```

---

### Pagination Tests

* limit = 1
* limit = N
* multi-page continuation
* continuation at group boundaries
* inclusive/exclusive lower/upper

---

### Stress Tests

* Large prefix groups
* Unique index
* Non-unique index
* Empty range
* Exact boundary equality

---

## 14. Success Criteria

* No duplication across DESC pages.
* No omission.
* Strict prefix isolation.
* Bound correctness preserved.
* Fingerprint differs between ASC and DESC.
* Canonical comparison includes order direction.
* All symmetry tests pass.

---

## 15. Risks

1. Off-by-one continuation bugs.
2. Incorrect bound inversion.
3. Forgetting to include direction in fingerprint.
4. Plan hash drift from canonical ordering.
5. Interaction bugs with limit pushdown.

These must be validated explicitly.

---

## 16. Architectural Principle

DESC support must:

* Reuse ascending bound math.
* Reverse traversal direction only.
* Maintain strict symmetry.

This preserves conceptual simplicity.

---

## 17. Future Extensions

* DESC pushdown in composite trees.
* Mixed ASC/DESC multi-field support.
* DESC PK KeyRange.
* Cursor versioned encoding (0.13+).

---

## 18. Governance Commitment - PlanError Domain Split

0.14 will split `PlanError` into sub-domain error types and keep the root enum
as a typed dispatcher.

Current baseline:

* `PlanError` variants: 24

Target shape:

```rust
pub enum PlanError {
    Predicate(predicate::ValidateError),
    Order(OrderPlanError),
    Access(AccessPlanError),
    Policy(PlanPolicyError),
    Cursor(CursorPlanError),
}
```

Requirements for the split:

* Preserve typed, structured variants in each sub-domain enum.
* Do not collapse semantics into `InvalidPlan(String)`.
* Do not merge distinct failure classes behind formatted messages.
* Keep classification explicit for drift-sensitive audits.

---

# Final Assessment

0.14 DESC support:

* Moderate complexity.
* Strong engine capability expansion.
* Stresses pagination model.
* Does not require structural redesign.

It is an appropriate next step after limit pushdown.
